import{mapIcrc1TransferError as Tr,mapIcrc2ApproveError as Er,toIcrc1TransferRawRequest as Pr,toIcrc2ApproveRawRequest as Ar}from"@dfinity/ledger-icp";import{IDL as a}from"@dfinity/candid";var Ie=a.Vec(a.Nat8),bt=a.Record({owner:a.Principal,subaccount:a.Opt(Ie)}),he=a.Nat64,fe=a.Record({to:bt,fee:a.Opt(a.Nat),memo:a.Opt(a.Vec(a.Nat8)),from_subaccount:a.Opt(Ie),created_at_time:a.Opt(he),amount:a.Nat}),qt=a.Variant({GenericError:a.Record({message:a.Text,error_code:a.Nat}),TemporarilyUnavailable:a.Null,BadBurn:a.Record({min_burn_amount:a.Nat}),Duplicate:a.Record({duplicate_of:a.Nat}),BadFee:a.Record({expected_fee:a.Nat}),CreatedInFuture:a.Record({ledger_time:he}),TooOld:a.Null,InsufficientFunds:a.Record({balance:a.Nat})}),Se=a.Variant({Ok:a.Nat,Err:qt});import{IDL as o}from"@dfinity/candid";var J=o.Record({owner:o.Principal,subaccount:o.Opt(o.Vec(o.Nat8))}),ge=o.Record({fee:o.Opt(o.Nat),memo:o.Opt(o.Vec(o.Nat8)),from_subaccount:o.Opt(o.Vec(o.Nat8)),created_at_time:o.Opt(o.Nat64),amount:o.Nat,expected_allowance:o.Opt(o.Nat),expires_at:o.Opt(o.Nat64),spender:J}),wr=o.Record({to:J,fee:o.Opt(o.Nat),spender_subaccount:o.Opt(o.Vec(o.Nat8)),from:J,memo:o.Opt(o.Vec(o.Nat8)),created_at_time:o.Opt(o.Nat64),amount:o.Nat}),Mt=o.Variant({GenericError:o.Record({message:o.Text,error_code:o.Nat}),TemporarilyUnavailable:o.Null,Duplicate:o.Record({duplicate_of:o.Nat}),BadFee:o.Record({expected_fee:o.Nat}),AllowanceChanged:o.Record({current_allowance:o.Nat}),CreatedInFuture:o.Record({ledger_time:o.Nat64}),TooOld:o.Null,Expired:o.Record({ledger_time:o.Nat64}),InsufficientFunds:o.Record({balance:o.Nat})}),zt=o.Variant({GenericError:o.Record({message:o.Text,error_code:o.Nat}),TemporarilyUnavailable:o.Null,InsufficientAllowance:o.Record({allowance:o.Nat}),BadBurn:o.Record({min_burn_amount:o.Nat}),Duplicate:o.Record({duplicate_of:o.Nat}),BadFee:o.Record({expected_fee:o.Nat}),CreatedInFuture:o.Record({ledger_time:o.Nat64}),TooOld:o.Null,InsufficientFunds:o.Record({balance:o.Nat})}),Ce=o.Variant({Ok:o.Nat,Err:Mt}),br=o.Variant({Ok:o.Nat,Err:zt});import{assertNonNullish as Ot,nonNullish as E,notEmptyString as xt}from"@dfinity/utils";var _e="icrc21_call_consent_message",D="icrc25_request_permissions",W="icrc25_permissions",B="icrc25_supported_standards",A="icrc27_accounts",O="icrc29_status",x="icrc49_call_canister",G="granted",Te="denied",Ee="ask_on_use",Pe="ICRC-21",Ae="ICRC-25",Oe="ICRC-27",xe="ICRC-29",Ne="ICRC-49";import*as Y from"zod/v4";var Lt=Y.enum([_e,D,W,B,A,O,x]),F=Lt.extract([A,x]),we=Y.enum([G,Te,Ee]),Z=Y.enum([Pe,Ae,Oe,xe,Ne]);var be=5e3,k=60*2*1e3,X=5e3,qe=k,Me=X,ze=k,Le=X,Ue=k,ve=k,De=X,We={scopes:Object.values(F.enum).map(t=>({method:t}))};var N="toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=no, copyhistory=no",Be={width:576,height:625},Ge={...Be,position:"top-right",features:N},Dr={...Be,position:"center",features:N};var Ye="http://localhost:4943",Fe="https://icp-api.io";import*as p from"zod/v4";var S="2.0",Ut=p.literal(S),w=p.union([p.string(),p.number(),p.null()]),ke=p.object({jsonrpc:Ut,id:p.optional(w)}),vt=ke.extend({id:w}).merge(p.object({method:p.string(),params:p.optional(p.any())})).strict();var Gr=vt.omit({id:!0}).strict(),Ve=(i=>(i[i.PARSE_ERROR=-32700]="PARSE_ERROR",i[i.INVALID_REQUEST=-32600]="INVALID_REQUEST",i[i.METHOD_NOT_FOUND=-32601]="METHOD_NOT_FOUND",i[i.INVALID_PARAMS=-32602]="INVALID_PARAMS",i[i.INTERNAL_ERROR=-32603]="INTERNAL_ERROR",i[i.SERVER_ERROR=-32e3]="SERVER_ERROR",i))(Ve||{}),Dt=p.union([p.number(),p.nativeEnum(Ve)]),je=p.object({code:Dt,message:p.string(),data:p.optional(p.never())}),Wt=ke.extend({id:w}),ee=Wt.extend({error:je}).strict(),C=t=>ee.omit({error:!0}).merge(p.object({result:t,error:je}).partial()).strict().refine(({result:e,error:r})=>e!==void 0||r!==void 0,"Either result or error should be provided."),te=C(p.any());var Gt=async t=>{await new Promise(e=>{setTimeout(e,t)})},re=async({retries:t,isReady:e,fn:r,intervalInMilliseconds:s=500})=>{let c=e();if(c!=="pending")return c;let n=t-1;return n===0?"timeout":(r(),await Gt(s),await re({retries:n,intervalInMilliseconds:s,isReady:e,fn:r}))};var He=async({popup:t,id:e,isReady:r,timeoutInMilliseconds:s,intervalInMilliseconds:c})=>{let n=()=>{b({popup:t,msg:{jsonrpc:S,id:e,method:O},origin:"*"})};return await re({retries:s/(c??500),intervalInMilliseconds:c,isReady:r,fn:n})},$e=({id:t,...e})=>{b({msg:{jsonrpc:S,id:t,method:O},...e})},Qe=({id:t,...e})=>{b({msg:{jsonrpc:S,id:t,method:B},...e})},Ke=({id:t,...e})=>{b({msg:{jsonrpc:S,id:t,method:W},...e})},Je=({id:t,params:e,...r})=>{oe({msg:{jsonrpc:S,id:t,method:D,params:e},...r})},Ze=({id:t,...e})=>{oe({msg:{jsonrpc:S,id:t,method:A},...e})},Xe=({id:t,params:e,...r})=>{oe({msg:{jsonrpc:S,id:t,method:x,params:e},...r})},oe=({popup:t,...e})=>{t.focus(),b({popup:t,...e})},b=({popup:t,msg:e,origin:r})=>{t.postMessage(e,r)};import{UrlSchema as jt}from"@dfinity/zod-schemas";import*as I from"zod/v4";import*as et from"zod/v4";var q=et.string().refine(t=>{try{return btoa(atob(t))===t}catch{return!1}},{message:"Invalid base64 string"});import{base64ToUint8Array as Yt}from"@dfinity/utils";import{PrincipalTextSchema as Ft}from"@dfinity/zod-schemas";import*as V from"zod/v4";var kt=q.refine(t=>{try{return Yt(t).length===32}catch{return!1}},{message:"Subaccount must be exactly 32 bytes long."}),Vt=V.object({owner:Ft,subaccount:kt.optional()}).strict(),tt=V.array(Vt).min(1);var Ht=I.object({method:F}),$t=I.object({scope:Ht,state:we}).strict(),Qt=I.array($t),Kt=I.object({scopes:Qt}).strict(),rt=C(Kt),Jt=/^https:\/\/github\.com\/dfinity\/ICRC\/blob\/main\/ICRCs\/ICRC-\d+\/ICRC-\d+\.md$/,Zt=I.url().regex(Jt).refine(t=>{try{jt.parse(t)}catch{return!1}let e=/(ICRC-\d+)\.md/g.exec(t);if(e===null)return!1;let[r,s]=e;return Object.keys(Z.enum).includes(s)},{message:"The URL does not match any of the IcrcStandard values."}),Xt=I.array(I.object({name:Z,url:Zt}).strict()).min(1),ot=C(I.object({supportedStandards:Xt})),se=C(I.literal("ready")),st=C(I.object({accounts:tt})),er=I.object({contentMap:q,certificate:q}).strict(),nt=C(er.strict());var j=class extends Error{code;constructor({message:e,code:r}){super(e),this.code=r}},M=class extends Error{};import{UrlSchema as at}from"@dfinity/zod-schemas";import*as m from"zod/v4";import*as ct from"zod/v4";var it=t=>ct.custom(e=>t.implement(e));var tr=m.object({pollingIntervalInMilliseconds:m.number().positive().optional(),timeoutInMilliseconds:m.number().positive().optional()}),rr=m.object({position:m.enum(["top-right","center"]),width:m.number().positive(),height:m.number().positive(),features:m.string().optional()}),or=it(m.function({output:m.void()})).optional(),sr=at.optional(),pt=m.object({url:at,windowOptions:m.union([rr,m.string()]).optional(),connectionOptions:tr.optional(),onDisconnect:or,host:sr});import*as z from"zod/v4";var dt=z.object({timeoutInMilliseconds:z.number().positive()}),ne=z.object({requestId:w.optional()}).merge(dt.partial()),lo=ne.omit({timeoutInMilliseconds:!0}).merge(dt);import{AnonymousIdentity as yr,Certificate as Ir,HttpAgent as hr,lookupResultToBuffer as fr,requestIdOf as Sr,uint8ToBuf as _t}from"@dfinity/agent";import{Principal as Et}from"@dfinity/principal";import{assertNonNullish as Tt,base64ToUint8Array as gr}from"@dfinity/utils";import{uint8ToBuf as pr}from"@dfinity/agent";import{Principal as dr}from"@dfinity/principal";import{base64ToUint8Array as ur}from"@dfinity/utils";import{concat as nr,fromHex as ut,toHex as cr,uint8ToBuf as mt}from"@dfinity/agent";import ir from"borc";import*as _ from"simple-cbor";import{SelfDescribeCborSerializer as ar}from"simple-cbor";var ce=class{get name(){return"Principal"}get priority(){return 0}match(e){return e&&e._isPrincipal===!0}encode(e){return _.value.bytes(mt(e.toUint8Array()))}},ie=class{get name(){return"Buffer"}get priority(){return 1}match(e){return e instanceof ArrayBuffer||ArrayBuffer.isView(e)}encode(e){return _.value.bytes(e)}},ae=class{get name(){return"BigInt"}get priority(){return 1}match(e){return typeof e=="bigint"}encode(e){return e>BigInt(0)?_.value.tagged(2,_.value.bytes(ut(e.toString(16)))):_.value.tagged(3,_.value.bytes(ut((BigInt("-1")*e).toString(16))))}},de=ar.withDefaultEncoders(!0);de.addEncoder(new ce);de.addEncoder(new ie);de.addEncoder(new ae);function lt(t){let e=t.byteLength,r=BigInt(0);for(let s=0;s<e;s++)r=r*BigInt(256)+BigInt(t[s]);return r}var pe=class extends ir.Decoder{createByteString(e){return nr(...e)}createByteStringFromHeap(e,r){return e===r?new ArrayBuffer(0):new Uint8Array(this._heap.slice(e,r))}};function Rt(t){let e=new Uint8Array(t),r=new pe({size:e.byteLength,tags:{2:s=>lt(s),3:s=>-lt(s),55799:s=>s}});try{return r.decodeFirst(e)}catch(s){throw new Error(`Failed to decode CBOR: ${s}, input: ${cr(mt(e))}`)}}var ue=t=>{let{ingress_expiry:e,canister_id:r,...s}=Rt(pr(ur(t)));return{...s,canister_id:dr.fromUint8Array(r),ingress_expiry:BigInt(e.toFixed())}};import{Principal as yt}from"@dfinity/principal";import{arrayBufferToUint8Array as lr,base64ToUint8Array as mr}from"@dfinity/utils";var It=({requestMethod:t,responseMethod:e})=>{if(e!==t)throw new Error("The response method does not match the request method.")},ht=({responseArg:t,requestArg:e})=>{let r=mr(e),s=lr(t);if(!(({first:n,second:i})=>n.length===i.length&&n.every((d,u)=>d===i[u]))({first:r,second:s}))throw new Error("The response does not contain the request arguments.")},ft=({requestCanisterId:t,responseCanisterId:e})=>{if(t.toText()!==e.toText())throw new Error("The response canister ID does not match the requested canister ID.")},St=({requestSender:t,responseSender:e})=>{if((e instanceof Uint8Array?yt.fromUint8Array(e):e).toText()!==yt.fromText(t).toText())throw new Error("The response sender does not match the request sender.")};import{IDL as gt}from"@dfinity/candid";import{uint8ArrayToBase64 as Rr}from"@dfinity/utils";var le=({recordClass:t,rawArgs:e})=>Rr(new Uint8Array(gt.encode([t],[e]))),Ct=({recordClass:t,bytes:e})=>{let r=gt.decode([t],e);if(r.length!==1)throw new Error("More than one object returned. This is unexpected.");let[s]=r;return s};var Pt=({params:{method:t,arg:e,canisterId:r,sender:s},result:{contentMap:c}})=>{let n=ue(c);ft({requestCanisterId:Et.fromText(r),responseCanisterId:n.canister_id}),It({requestMethod:t,responseMethod:n.method_name}),ht({requestArg:e,responseArg:n.arg}),St({requestSender:s,responseSender:n.sender})},me=async({params:{canisterId:t},result:{certificate:e,contentMap:r},resultRecordClass:s,host:c})=>{let n=ue(r),{location:{hostname:i}}=window,d=["localhost","127.0.0.1"].includes(i),u=await hr.create({identity:new yr,host:d?c??Ye:Fe,...d&&{shouldFetchRootKey:!0}});Tt(u.rootKey,"Missing agent root key, which is required to certify the response.");let l=await Ir.create({certificate:_t(gr(e)),rootKey:u.rootKey,canisterId:Et.fromText(t)}),h=Sr(n),R=[_t(new TextEncoder().encode("request_status")),h],y=fr(l.lookup([...R,"reply"]));return Tt(y,"A reply cannot be resolved within the provided certificate. This is unexpected; it should have been known at this point."),Ct({recordClass:s,bytes:y})};import{isNullish as H}from"@dfinity/utils";var Re=()=>typeof window<"u";var At=({position:t,...e})=>(t==="center"?Cr:_r)(e),Cr=({width:t,height:e,features:r=N})=>{if(!Re()||H(window)||H(window.top))return;let{top:{innerWidth:s,innerHeight:c}}=window,n=c/2+screenY-e/2,i=s/2+screenX-t/2;return`${r}, width=${t}, height=${e}, top=${n}, left=${i}`},_r=({width:t,height:e,features:r=N})=>{if(!Re()||H(window)||H(window.top))return;let{top:{innerWidth:s,innerHeight:c}}=window,n=outerHeight-c,i=s-t;return`${r}, width=${t}, height=${e}, top=${n}, left=${i}`};var $=class t{#t;#e;#o;host;#r="connected";#s;constructor({origin:e,popup:r,onDisconnect:s,host:c}){this.#t=e,this.#e=r,this.#o=s,this.host=c,this.#r="connected",this.#s=setInterval(this.checkWalletStatusCallback,be)}static async connect({onDisconnect:e,...r}){return await this.connectSigner({options:r,init:s=>new t({...s,onDisconnect:e})})}static async connectSigner({options:e,init:r}){let{success:s,error:c}=pt.safeParse(e);if(!s)throw new Error(`Options cannot be parsed: ${c?.message??""}`);let{url:n,windowOptions:i,connectionOptions:d}=e,u=typeof i=="string"?i:At(i??Ge),l=window.open(n,"relyingPartyWindow",u);Ot(l,"Unable to open the signer window.");let h=()=>{l.close()};class R extends Error{}let y,L=({origin:f,data:T})=>{let{success:Q}=te.safeParse(T);if(!Q)return;let v;try{let{origin:P}=new URL(n);v=P}catch{y=new R(`The origin ${f} of the signer URL ${n} cannot be parsed.`);return}if(xt(f)&&f!==v){y=new R(`The response origin ${f} does not match the requested signer URL ${n}.`);return}let{success:K}=se.safeParse(T);K&&(y=r({origin:f,popup:l}))};window.addEventListener("message",L);let U=()=>{window.removeEventListener("message",L)},g=async()=>{if(await He({popup:l,isReady:()=>E(y)?y instanceof t?"ready":"error":"pending",id:crypto.randomUUID(),timeoutInMilliseconds:d?.timeoutInMilliseconds??qe,intervalInMilliseconds:d?.pollingIntervalInMilliseconds})==="timeout")throw new Error("Connection timeout. Unable to connect to the signer.");if(Ot(y,"Unexpected error. The request status succeeded, but the signer response is not defined."),y instanceof R)throw y;return y};try{return await g()}catch(f){throw h(),f}finally{U()}}disconnect=async()=>{clearInterval(this.#s),this.#e.close(),this.#o?.()};checkWalletStatusCallback=()=>{this.checkWalletStatus()};async checkWalletStatus(){let e=({data:c,id:n})=>{let{success:i,data:d}=se.safeParse(c);return i&&n===d?.id?{handled:!0,result:"connected"}:{handled:!0,result:"disconnected"}},r=c=>{$e({popup:this.#e,origin:this.#t,id:c})},s=async()=>{try{return await this.request({options:{timeoutInMilliseconds:De},postRequest:r,handleMessage:e})}catch{return"disconnected"}};this.#r=await s(),this.#r!=="connected"&&await this.disconnect()}request=async({options:e,postRequest:r,handleMessage:s})=>await new Promise((c,n)=>{let{connected:i,err:d}=this.assertWalletConnected();if(!i){n(d??new Error("Unexpected reason for disconnection."));return}let{success:u,error:l}=ne.safeParse(e);if(!u)throw new Error(`Wallet request options cannot be parsed: ${l?.message??""}`);let{requestId:h,timeoutInMilliseconds:R}=e,y=h??crypto.randomUUID(),L=setTimeout(()=>{n(new Error(`Request to signer timed out after ${R} milliseconds.`)),g()},R),U=({origin:f,data:T,source:Q})=>{let{success:v}=te.safeParse(T);if(!v)return;if(Q!==this.#e){n(new Error("The response is not originating from the window that was opened.")),g();return}if(xt(f)&&f!==this.#t){n(new Error(`The response origin ${f} does not match the signer origin ${this.#t}.`)),g();return}let{handled:K,result:P}=s({data:T,id:y});if(K&&E(P)){c(P),g();return}let ye=this.handleErrorMessage({data:T,id:y});ye.valid||(n(ye.error),g())};window.addEventListener("message",U);let g=()=>{clearTimeout(L),window.removeEventListener("message",U)};r(y)});assertWalletConnected(){return this.#r==="disconnected"?{connected:!1,err:new M("The signer has been disconnected. Your request cannot be processed.")}:this.#e.closed?{connected:!1,err:new M("The signer has been closed. Your request cannot be processed.")}:{connected:!0}}supportedStandards=async({options:{timeoutInMilliseconds:e,...r}={}}={})=>{let s=({data:n,id:i})=>{let{success:d,data:u}=ot.safeParse(n);if(d&&i===u?.id&&E(u?.result)){let{result:{supportedStandards:l}}=u;return{handled:!0,result:l}}return{handled:!1}},c=n=>{Qe({popup:this.#e,origin:this.#t,id:n})};return await this.request({options:{timeoutInMilliseconds:e??Me,...r},postRequest:c,handleMessage:s})};permissions=async({options:{timeoutInMilliseconds:e,...r}={}}={})=>{let s=c=>{Ke({popup:this.#e,origin:this.#t,id:c})};return await this.requestPermissionsScopes({options:{timeoutInMilliseconds:e??Le,...r},postRequest:s})};requestPermissions=async({options:{timeoutInMilliseconds:e,...r}={},params:s}={})=>{let c=n=>{Je({popup:this.#e,origin:this.#t,id:n,params:s??We})};return await this.requestPermissionsScopes({options:{timeoutInMilliseconds:e??ze,...r},postRequest:c})};requestPermissionsScopes=async({options:e,postRequest:r})=>{let s=({data:c,id:n})=>{let{success:i,data:d}=rt.safeParse(c);if(i&&n===d?.id&&E(d?.result)){let{result:{scopes:u}}=d;return{handled:!0,result:u}}return{handled:!1}};return await this.request({options:e,postRequest:r,handleMessage:s})};accounts=async({options:{timeoutInMilliseconds:e,...r}={}}={})=>{let s=({data:n,id:i})=>{let{success:d,data:u}=st.safeParse(n);if(d&&i===u?.id&&E(u?.result)){let{result:{accounts:l}}=u;return{handled:!0,result:l}}return{handled:!1}},c=n=>{Ze({popup:this.#e,origin:this.#t,id:n})};return await this.request({options:{timeoutInMilliseconds:e??Ue,...r},postRequest:c,handleMessage:s})};call=async({options:{timeoutInMilliseconds:e,...r}={},params:s})=>{let c=({data:d,id:u})=>{let{success:l,data:h}=nt.safeParse(d);if(l&&u===h?.id&&E(h?.result)){let{result:R}=h;return{handled:!0,result:R}}return{handled:!1}},n=d=>{Xe({popup:this.#e,origin:this.#t,id:d,params:s})},i=await this.request({options:{timeoutInMilliseconds:e??ve,...r},postRequest:n,handleMessage:c});return Pt({params:s,result:i}),i};handleErrorMessage=({data:e,id:r})=>{let{success:s,data:c}=ee.safeParse(e);return!s||r!==c?.id?{valid:!0}:{valid:!1,error:new j(c.error)}};requestPermissionsNotGranted=async({options:e}={})=>{let r=d=>d.filter(({state:u})=>u!==G).map(({scope:u})=>u),s=await this.permissions({options:e});if(s.length===0)throw new Error("The signer did not provide any data about the current set of permissions.");let c=r(s);if(c.length===0)return{allPermissionsGranted:!0};let n=await this.requestPermissions({options:e,params:{scopes:c}});if(n.length===0)throw new Error("The signer did not provide any data about the current set of permissions following the request.");return{allPermissionsGranted:r(n).length===0}}};var Nt="ryjl3-tyaaa-aaaaa-aaaba-cai",wt=class t extends ${static async connect({onDisconnect:e,host:r,...s}){return await this.connectSigner({options:s,init:c=>new t({...c,onDisconnect:e,host:r})})}icrc1Transfer=async({request:e,owner:r,ledgerCanisterId:s,options:c})=>{let n=Pr(e),i=le({recordClass:fe,rawArgs:n}),l={sender:r,method:"icrc1_transfer",canisterId:s??Nt,arg:i},h=await this.call({params:l,options:c}),R=await me({params:l,result:h,resultRecordClass:Se,host:this.host});if("Err"in R)throw Tr(R.Err);return R.Ok};icrc2Approve=async({request:e,owner:r,ledgerCanisterId:s,options:c})=>{let n=Ar(e),i=le({recordClass:ge,rawArgs:n}),l={sender:r,method:"icrc2_approve",canisterId:s??Nt,arg:i},h=await this.call({params:l,options:c}),R=await me({params:l,result:h,resultRecordClass:Ce,host:this.host});if("Err"in R)throw Er(R.Err);return R.Ok}};export{wt as IcpWallet};
//# sourceMappingURL=icp-wallet.js.map
