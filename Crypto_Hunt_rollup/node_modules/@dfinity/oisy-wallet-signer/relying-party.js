import{assertNonNullish as at,nonNullish as E,notEmptyString as pt}from"@dfinity/utils";var pe="icrc21_call_consent_message",L="icrc25_request_permissions",v="icrc25_permissions",D="icrc25_supported_standards",_="icrc27_accounts",P="icrc29_status",A="icrc49_call_canister",W="granted",ue="denied",de="ask_on_use",le="ICRC-21",me="ICRC-25",Re="ICRC-27",ye="ICRC-29",Ie="ICRC-49";import*as G from"zod/v4";var dt=G.enum([pe,L,v,D,_,P,A]),Y=dt.extract([_,A]),Se=G.enum([W,ue,de]),V=G.enum([le,me,Re,ye,Ie]);var he=5e3,B=60*2*1e3,Q=5e3,fe=B,ge=Q,Ce=B,Ee=Q,Te=B,_e=B,Pe=Q,Ae={scopes:Object.values(Y.enum).map(t=>({method:t}))};var x="toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=no, copyhistory=no",xe={width:576,height:625},Oe={...xe,position:"top-right",features:x},Zt={...xe,position:"center",features:x};import*as c from"zod/v4";var y="2.0",lt=c.literal(y),O=c.union([c.string(),c.number(),c.null()]),qe=c.object({jsonrpc:lt,id:c.optional(O)}),mt=qe.extend({id:O}).merge(c.object({method:c.string(),params:c.optional(c.any())})).strict();var er=mt.omit({id:!0}).strict(),we=(i=>(i[i.PARSE_ERROR=-32700]="PARSE_ERROR",i[i.INVALID_REQUEST=-32600]="INVALID_REQUEST",i[i.METHOD_NOT_FOUND=-32601]="METHOD_NOT_FOUND",i[i.INVALID_PARAMS=-32602]="INVALID_PARAMS",i[i.INTERNAL_ERROR=-32603]="INTERNAL_ERROR",i[i.SERVER_ERROR=-32e3]="SERVER_ERROR",i))(we||{}),Rt=c.union([c.number(),c.nativeEnum(we)]),be=c.object({code:Rt,message:c.string(),data:c.optional(c.never())}),yt=qe.extend({id:O}),K=yt.extend({error:be}).strict(),f=t=>K.omit({error:!0}).merge(c.object({result:t,error:be}).partial()).strict().refine(({result:e,error:r})=>e!==void 0||r!==void 0,"Either result or error should be provided."),J=f(c.any());var St=async t=>{await new Promise(e=>{setTimeout(e,t)})},Z=async({retries:t,isReady:e,fn:r,intervalInMilliseconds:o=500})=>{let n=e();if(n!=="pending")return n;let s=t-1;return s===0?"timeout":(r(),await St(o),await Z({retries:s,intervalInMilliseconds:o,isReady:e,fn:r}))};var Ne=async({popup:t,id:e,isReady:r,timeoutInMilliseconds:o,intervalInMilliseconds:n})=>{let s=()=>{q({popup:t,msg:{jsonrpc:y,id:e,method:P},origin:"*"})};return await Z({retries:o/(n??500),intervalInMilliseconds:n,isReady:r,fn:s})},Me=({id:t,...e})=>{q({msg:{jsonrpc:y,id:t,method:P},...e})},ze=({id:t,...e})=>{q({msg:{jsonrpc:y,id:t,method:D},...e})},Ue=({id:t,...e})=>{q({msg:{jsonrpc:y,id:t,method:v},...e})},Le=({id:t,params:e,...r})=>{X({msg:{jsonrpc:y,id:t,method:L,params:e},...r})},ve=({id:t,...e})=>{X({msg:{jsonrpc:y,id:t,method:_},...e})},De=({id:t,params:e,...r})=>{X({msg:{jsonrpc:y,id:t,method:A,params:e},...r})},X=({popup:t,...e})=>{t.focus(),q({popup:t,...e})},q=({popup:t,msg:e,origin:r})=>{t.postMessage(e,r)};import{UrlSchema as Et}from"@dfinity/zod-schemas";import*as d from"zod/v4";import*as We from"zod/v4";var w=We.string().refine(t=>{try{return btoa(atob(t))===t}catch{return!1}},{message:"Invalid base64 string"});import{base64ToUint8Array as ht}from"@dfinity/utils";import{PrincipalTextSchema as ft}from"@dfinity/zod-schemas";import*as j from"zod/v4";var gt=w.refine(t=>{try{return ht(t).length===32}catch{return!1}},{message:"Subaccount must be exactly 32 bytes long."}),Ct=j.object({owner:ft,subaccount:gt.optional()}).strict(),Ge=j.array(Ct).min(1);var Tt=d.object({method:Y}),_t=d.object({scope:Tt,state:Se}).strict(),Pt=d.array(_t),At=d.object({scopes:Pt}).strict(),Ye=f(At),xt=/^https:\/\/github\.com\/dfinity\/ICRC\/blob\/main\/ICRCs\/ICRC-\d+\/ICRC-\d+\.md$/,Ot=d.url().regex(xt).refine(t=>{try{Et.parse(t)}catch{return!1}let e=/(ICRC-\d+)\.md/g.exec(t);if(e===null)return!1;let[r,o]=e;return Object.keys(V.enum).includes(o)},{message:"The URL does not match any of the IcrcStandard values."}),qt=d.array(d.object({name:V,url:Ot}).strict()).min(1),Be=f(d.object({supportedStandards:qt})),ee=f(d.literal("ready")),je=f(d.object({accounts:Ge})),wt=d.object({contentMap:w,certificate:w}).strict(),ke=f(wt.strict());var k=class extends Error{code;constructor({message:e,code:r}){super(e),this.code=r}},b=class extends Error{};import{UrlSchema as He}from"@dfinity/zod-schemas";import*as u from"zod/v4";import*as Fe from"zod/v4";var $e=t=>Fe.custom(e=>t.implement(e));var bt=u.object({pollingIntervalInMilliseconds:u.number().positive().optional(),timeoutInMilliseconds:u.number().positive().optional()}),Nt=u.object({position:u.enum(["top-right","center"]),width:u.number().positive(),height:u.number().positive(),features:u.string().optional()}),Mt=$e(u.function({output:u.void()})).optional(),zt=He.optional(),Ve=u.object({url:He,windowOptions:u.union([Nt,u.string()]).optional(),connectionOptions:bt.optional(),onDisconnect:Mt,host:zt});import*as N from"zod/v4";var Qe=N.object({timeoutInMilliseconds:N.number().positive()}),te=N.object({requestId:O.optional()}).merge(Qe.partial()),_r=te.omit({timeoutInMilliseconds:!0}).merge(Qe);import{AnonymousIdentity as Gr,Certificate as Yr,HttpAgent as Br,lookupResultToBuffer as jr,requestIdOf as kr,uint8ToBuf as Fr}from"@dfinity/agent";import{Principal as kt}from"@dfinity/principal";import{assertNonNullish as Vr,base64ToUint8Array as Qr}from"@dfinity/utils";import{uint8ToBuf as Wt}from"@dfinity/agent";import{Principal as Gt}from"@dfinity/principal";import{base64ToUint8Array as Yt}from"@dfinity/utils";import{concat as Ut,fromHex as Ke,toHex as Lt,uint8ToBuf as Ze}from"@dfinity/agent";import vt from"borc";import*as g from"simple-cbor";import{SelfDescribeCborSerializer as Dt}from"simple-cbor";var re=class{get name(){return"Principal"}get priority(){return 0}match(e){return e&&e._isPrincipal===!0}encode(e){return g.value.bytes(Ze(e.toUint8Array()))}},oe=class{get name(){return"Buffer"}get priority(){return 1}match(e){return e instanceof ArrayBuffer||ArrayBuffer.isView(e)}encode(e){return g.value.bytes(e)}},se=class{get name(){return"BigInt"}get priority(){return 1}match(e){return typeof e=="bigint"}encode(e){return e>BigInt(0)?g.value.tagged(2,g.value.bytes(Ke(e.toString(16)))):g.value.tagged(3,g.value.bytes(Ke((BigInt("-1")*e).toString(16))))}},ie=Dt.withDefaultEncoders(!0);ie.addEncoder(new re);ie.addEncoder(new oe);ie.addEncoder(new se);function Je(t){let e=t.byteLength,r=BigInt(0);for(let o=0;o<e;o++)r=r*BigInt(256)+BigInt(t[o]);return r}var ne=class extends vt.Decoder{createByteString(e){return Ut(...e)}createByteStringFromHeap(e,r){return e===r?new ArrayBuffer(0):new Uint8Array(this._heap.slice(e,r))}};function Xe(t){let e=new Uint8Array(t),r=new ne({size:e.byteLength,tags:{2:o=>Je(o),3:o=>-Je(o),55799:o=>o}});try{return r.decodeFirst(e)}catch(o){throw new Error(`Failed to decode CBOR: ${o}, input: ${Lt(Ze(e))}`)}}var et=t=>{let{ingress_expiry:e,canister_id:r,...o}=Xe(Wt(Yt(t)));return{...o,canister_id:Gt.fromUint8Array(r),ingress_expiry:BigInt(e.toFixed())}};import{Principal as tt}from"@dfinity/principal";import{arrayBufferToUint8Array as Bt,base64ToUint8Array as jt}from"@dfinity/utils";var rt=({requestMethod:t,responseMethod:e})=>{if(e!==t)throw new Error("The response method does not match the request method.")},ot=({responseArg:t,requestArg:e})=>{let r=jt(e),o=Bt(t);if(!(({first:s,second:i})=>s.length===i.length&&s.every((a,p)=>a===i[p]))({first:r,second:o}))throw new Error("The response does not contain the request arguments.")},st=({requestCanisterId:t,responseCanisterId:e})=>{if(t.toText()!==e.toText())throw new Error("The response canister ID does not match the requested canister ID.")},nt=({requestSender:t,responseSender:e})=>{if((e instanceof Uint8Array?tt.fromUint8Array(e):e).toText()!==tt.fromText(t).toText())throw new Error("The response sender does not match the request sender.")};var it=({params:{method:t,arg:e,canisterId:r,sender:o},result:{contentMap:n}})=>{let s=et(n);st({requestCanisterId:kt.fromText(r),responseCanisterId:s.canister_id}),rt({requestMethod:t,responseMethod:s.method_name}),ot({requestArg:e,responseArg:s.arg}),nt({requestSender:o,responseSender:s.sender})};import{isNullish as F}from"@dfinity/utils";var ce=()=>typeof window<"u";var ct=({position:t,...e})=>(t==="center"?Ft:$t)(e),Ft=({width:t,height:e,features:r=x})=>{if(!ce()||F(window)||F(window.top))return;let{top:{innerWidth:o,innerHeight:n}}=window,s=n/2+screenY-e/2,i=o/2+screenX-t/2;return`${r}, width=${t}, height=${e}, top=${s}, left=${i}`},$t=({width:t,height:e,features:r=x})=>{if(!ce()||F(window)||F(window.top))return;let{top:{innerWidth:o,innerHeight:n}}=window,s=outerHeight-n,i=o-t;return`${r}, width=${t}, height=${e}, top=${s}, left=${i}`};var ut=class t{#t;#e;#o;host;#r="connected";#s;constructor({origin:e,popup:r,onDisconnect:o,host:n}){this.#t=e,this.#e=r,this.#o=o,this.host=n,this.#r="connected",this.#s=setInterval(this.checkWalletStatusCallback,he)}static async connect({onDisconnect:e,...r}){return await this.connectSigner({options:r,init:o=>new t({...o,onDisconnect:e})})}static async connectSigner({options:e,init:r}){let{success:o,error:n}=Ve.safeParse(e);if(!o)throw new Error(`Options cannot be parsed: ${n?.message??""}`);let{url:s,windowOptions:i,connectionOptions:a}=e,p=typeof i=="string"?i:ct(i??Oe),R=window.open(s,"relyingPartyWindow",p);at(R,"Unable to open the signer window.");let S=()=>{R.close()};class I extends Error{}let l,M=({origin:m,data:C})=>{let{success:$}=J.safeParse(C);if(!$)return;let U;try{let{origin:T}=new URL(s);U=T}catch{l=new I(`The origin ${m} of the signer URL ${s} cannot be parsed.`);return}if(pt(m)&&m!==U){l=new I(`The response origin ${m} does not match the requested signer URL ${s}.`);return}let{success:H}=ee.safeParse(C);H&&(l=r({origin:m,popup:R}))};window.addEventListener("message",M);let z=()=>{window.removeEventListener("message",M)},h=async()=>{if(await Ne({popup:R,isReady:()=>E(l)?l instanceof t?"ready":"error":"pending",id:crypto.randomUUID(),timeoutInMilliseconds:a?.timeoutInMilliseconds??fe,intervalInMilliseconds:a?.pollingIntervalInMilliseconds})==="timeout")throw new Error("Connection timeout. Unable to connect to the signer.");if(at(l,"Unexpected error. The request status succeeded, but the signer response is not defined."),l instanceof I)throw l;return l};try{return await h()}catch(m){throw S(),m}finally{z()}}disconnect=async()=>{clearInterval(this.#s),this.#e.close(),this.#o?.()};checkWalletStatusCallback=()=>{this.checkWalletStatus()};async checkWalletStatus(){let e=({data:n,id:s})=>{let{success:i,data:a}=ee.safeParse(n);return i&&s===a?.id?{handled:!0,result:"connected"}:{handled:!0,result:"disconnected"}},r=n=>{Me({popup:this.#e,origin:this.#t,id:n})},o=async()=>{try{return await this.request({options:{timeoutInMilliseconds:Pe},postRequest:r,handleMessage:e})}catch{return"disconnected"}};this.#r=await o(),this.#r!=="connected"&&await this.disconnect()}request=async({options:e,postRequest:r,handleMessage:o})=>await new Promise((n,s)=>{let{connected:i,err:a}=this.assertWalletConnected();if(!i){s(a??new Error("Unexpected reason for disconnection."));return}let{success:p,error:R}=te.safeParse(e);if(!p)throw new Error(`Wallet request options cannot be parsed: ${R?.message??""}`);let{requestId:S,timeoutInMilliseconds:I}=e,l=S??crypto.randomUUID(),M=setTimeout(()=>{s(new Error(`Request to signer timed out after ${I} milliseconds.`)),h()},I),z=({origin:m,data:C,source:$})=>{let{success:U}=J.safeParse(C);if(!U)return;if($!==this.#e){s(new Error("The response is not originating from the window that was opened.")),h();return}if(pt(m)&&m!==this.#t){s(new Error(`The response origin ${m} does not match the signer origin ${this.#t}.`)),h();return}let{handled:H,result:T}=o({data:C,id:l});if(H&&E(T)){n(T),h();return}let ae=this.handleErrorMessage({data:C,id:l});ae.valid||(s(ae.error),h())};window.addEventListener("message",z);let h=()=>{clearTimeout(M),window.removeEventListener("message",z)};r(l)});assertWalletConnected(){return this.#r==="disconnected"?{connected:!1,err:new b("The signer has been disconnected. Your request cannot be processed.")}:this.#e.closed?{connected:!1,err:new b("The signer has been closed. Your request cannot be processed.")}:{connected:!0}}supportedStandards=async({options:{timeoutInMilliseconds:e,...r}={}}={})=>{let o=({data:s,id:i})=>{let{success:a,data:p}=Be.safeParse(s);if(a&&i===p?.id&&E(p?.result)){let{result:{supportedStandards:R}}=p;return{handled:!0,result:R}}return{handled:!1}},n=s=>{ze({popup:this.#e,origin:this.#t,id:s})};return await this.request({options:{timeoutInMilliseconds:e??ge,...r},postRequest:n,handleMessage:o})};permissions=async({options:{timeoutInMilliseconds:e,...r}={}}={})=>{let o=n=>{Ue({popup:this.#e,origin:this.#t,id:n})};return await this.requestPermissionsScopes({options:{timeoutInMilliseconds:e??Ee,...r},postRequest:o})};requestPermissions=async({options:{timeoutInMilliseconds:e,...r}={},params:o}={})=>{let n=s=>{Le({popup:this.#e,origin:this.#t,id:s,params:o??Ae})};return await this.requestPermissionsScopes({options:{timeoutInMilliseconds:e??Ce,...r},postRequest:n})};requestPermissionsScopes=async({options:e,postRequest:r})=>{let o=({data:n,id:s})=>{let{success:i,data:a}=Ye.safeParse(n);if(i&&s===a?.id&&E(a?.result)){let{result:{scopes:p}}=a;return{handled:!0,result:p}}return{handled:!1}};return await this.request({options:e,postRequest:r,handleMessage:o})};accounts=async({options:{timeoutInMilliseconds:e,...r}={}}={})=>{let o=({data:s,id:i})=>{let{success:a,data:p}=je.safeParse(s);if(a&&i===p?.id&&E(p?.result)){let{result:{accounts:R}}=p;return{handled:!0,result:R}}return{handled:!1}},n=s=>{ve({popup:this.#e,origin:this.#t,id:s})};return await this.request({options:{timeoutInMilliseconds:e??Te,...r},postRequest:n,handleMessage:o})};call=async({options:{timeoutInMilliseconds:e,...r}={},params:o})=>{let n=({data:a,id:p})=>{let{success:R,data:S}=ke.safeParse(a);if(R&&p===S?.id&&E(S?.result)){let{result:I}=S;return{handled:!0,result:I}}return{handled:!1}},s=a=>{De({popup:this.#e,origin:this.#t,id:a,params:o})},i=await this.request({options:{timeoutInMilliseconds:e??_e,...r},postRequest:s,handleMessage:n});return it({params:o,result:i}),i};handleErrorMessage=({data:e,id:r})=>{let{success:o,data:n}=K.safeParse(e);return!o||r!==n?.id?{valid:!0}:{valid:!1,error:new k(n.error)}};requestPermissionsNotGranted=async({options:e}={})=>{let r=a=>a.filter(({state:p})=>p!==W).map(({scope:p})=>p),o=await this.permissions({options:e});if(o.length===0)throw new Error("The signer did not provide any data about the current set of permissions.");let n=r(o);if(n.length===0)return{allPermissionsGranted:!0};let s=await this.requestPermissions({options:e,params:{scopes:n}});if(s.length===0)throw new Error("The signer did not provide any data about the current set of permissions following the request.");return{allPermissionsGranted:r(s).length===0}}};export{ut as RelyingParty};
//# sourceMappingURL=relying-party.js.map
