{
  "version": 3,
  "sources": ["../src/icp-wallet.ts", "../src/constants/icrc-1.idl.constants.ts", "../src/constants/icrc-2.idl.constants.ts", "../src/relying-party.ts", "../src/constants/icrc.constants.ts", "../src/types/icrc-standards.ts", "../src/constants/relying-party.constants.ts", "../src/constants/window.constants.ts", "../src/constants/core.constants.ts", "../src/types/rpc.ts", "../src/utils/timeout.utils.ts", "../src/handlers/relying-party.handlers.ts", "../src/types/icrc-responses.ts", "../src/types/blob.ts", "../src/types/icrc-accounts.ts", "../src/types/relying-party-errors.ts", "../src/types/relying-party-options.ts", "../src/utils/zod.utils.ts", "../src/types/relying-party-requests.ts", "../src/utils/call.utils.ts", "../src/utils/agentjs-cbor-copy.utils.ts", "../src/agent/agentjs-cbor-copy.ts", "../src/utils/call.assert.utils.ts", "../src/utils/idl.utils.ts", "../src/utils/window.utils.ts", "../src/utils/env.utils.ts"],
  "sourcesContent": ["import {\n  mapIcrc1TransferError,\n  mapIcrc2ApproveError,\n  toIcrc1TransferRawRequest,\n  toIcrc2ApproveRawRequest,\n  type BlockHeight,\n  type Icrc1TransferRequest,\n  type Icrc2ApproveRequest\n} from '@dfinity/ledger-icp';\nimport type {\n  Icrc1TransferResult,\n  ApproveResult as Icrc2ApproveResult\n} from '@dfinity/ledger-icp/dist/candid/ledger';\nimport type {PrincipalText} from '@dfinity/zod-schemas';\nimport {TransferArgs, TransferResult} from './constants/icrc-1.idl.constants';\nimport {ApproveArgs, ApproveResult} from './constants/icrc-2.idl.constants';\nimport {RelyingParty} from './relying-party';\nimport type {IcrcAccount} from './types/icrc-accounts';\nimport type {IcrcCallCanisterRequestParams} from './types/icrc-requests';\nimport type {Origin} from './types/post-message';\nimport type {RelyingPartyOptions} from './types/relying-party-options';\nimport type {RelyingPartyRequestOptions} from './types/relying-party-requests';\nimport {decodeResponse} from './utils/call.utils';\nimport {encodeIdl} from './utils/idl.utils';\n\nconst ICP_LEDGER_CANISTER_ID = 'ryjl3-tyaaa-aaaaa-aaaba-cai';\n\nexport class IcpWallet extends RelyingParty {\n  /**\n   * Establishes a connection with an ICP Wallet.\n   *\n   * @override\n   * @static\n   * @param {RelyingPartyOptions} options - The options to initialize the ICP Wallet signer.\n   * @returns {Promise<IcpWallet>} A promise that resolves to an object, which can be used to interact with the ICP Wallet when it is connected.\n   */\n  static async connect({onDisconnect, host, ...rest}: RelyingPartyOptions): Promise<IcpWallet> {\n    return await this.connectSigner({\n      options: rest,\n      init: (params: {origin: Origin; popup: Window}) =>\n        new IcpWallet({\n          ...params,\n          onDisconnect,\n          host\n        })\n    });\n  }\n\n  /**\n   * Transfer ICP to the destination Account. Returns the index of the block containing the tx if it was successful.\n   *\n   * @param {Object} params - The transfer parameters.\n   * @param {Icrc1TransferRequest} params.request - The request object containing transfer details.\n   * @param {string} params.owner - The owner of the wallet\n   * @param {PrincipalText} [params.ledgerCanisterId] - Optional ledger canister ID, if not provided, uses the default ICP ledger canister ID.\n   * @param {RelyingPartyRequestOptions} [params.options] - Optional parameters for the request, such as request ID, authorization, or timeout.\n   *\n   * @returns {Promise<BlockHeight>} The block height of the transfer transaction if successful.\n   */\n  public icrc1Transfer = async ({\n    request,\n    owner,\n    ledgerCanisterId,\n    options\n  }: {\n    options?: RelyingPartyRequestOptions;\n    request: Icrc1TransferRequest;\n    ledgerCanisterId?: PrincipalText;\n  } & Pick<IcrcAccount, 'owner'>): Promise<BlockHeight> => {\n    // TODO: should we convert ic-js to zod? or should we map Icrc1TransferRequest to zod?\n    const rawArgs = toIcrc1TransferRawRequest(request);\n\n    const arg = encodeIdl({\n      recordClass: TransferArgs,\n      rawArgs\n    });\n\n    const canisterId = ledgerCanisterId ?? ICP_LEDGER_CANISTER_ID;\n\n    const method = 'icrc1_transfer';\n\n    const callParams: IcrcCallCanisterRequestParams = {\n      sender: owner,\n      method,\n      canisterId,\n      arg\n    };\n\n    // TODO: uncomment nonce and add TODO - not yet supported by agent-js\n\n    const callResult = await this.call({\n      params: callParams,\n      options\n    });\n\n    const response = await decodeResponse<Icrc1TransferResult>({\n      params: callParams,\n      result: callResult,\n      resultRecordClass: TransferResult,\n      host: this.host\n    });\n\n    if ('Err' in response) {\n      throw mapIcrc1TransferError(response.Err);\n    }\n\n    return response.Ok;\n  };\n\n  public icrc2Approve = async ({\n    request,\n    owner,\n    ledgerCanisterId,\n    options\n  }: {\n    options?: RelyingPartyRequestOptions;\n    request: Icrc2ApproveRequest;\n    ledgerCanisterId?: PrincipalText;\n  } & Pick<IcrcAccount, 'owner'>): Promise<BlockHeight> => {\n    const rawArgs = toIcrc2ApproveRawRequest(request);\n\n    const arg = encodeIdl({\n      recordClass: ApproveArgs,\n      rawArgs\n    });\n\n    const canisterId = ledgerCanisterId ?? ICP_LEDGER_CANISTER_ID;\n\n    const method = 'icrc2_approve';\n\n    const callParams: IcrcCallCanisterRequestParams = {\n      sender: owner,\n      method,\n      canisterId,\n      arg\n    };\n\n    // TODO: uncomment nonce and add TODO - not yet supported by agent-js\n\n    const callResult = await this.call({\n      params: callParams,\n      options\n    });\n\n    const response = await decodeResponse<Icrc2ApproveResult>({\n      params: callParams,\n      result: callResult,\n      resultRecordClass: ApproveResult,\n      host: this.host\n    });\n\n    if ('Err' in response) {\n      throw mapIcrc2ApproveError(response.Err);\n    }\n\n    return response.Ok;\n  };\n}\n", "import {IDL} from '@dfinity/candid';\n\n/**\n * TODO: All the constants of this module should be exposed by the IDL files - i.e. should be generated as exposed by didc\n */\n\nconst Subaccount = IDL.Vec(IDL.Nat8);\nconst Account = IDL.Record({\n  owner: IDL.Principal,\n  subaccount: IDL.Opt(Subaccount)\n});\n\nconst Timestamp = IDL.Nat64;\n\nexport const TransferArgs = IDL.Record({\n  to: Account,\n  fee: IDL.Opt(IDL.Nat),\n  memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n  from_subaccount: IDL.Opt(Subaccount),\n  created_at_time: IDL.Opt(Timestamp),\n  amount: IDL.Nat\n});\n\nexport const TransferError = IDL.Variant({\n  GenericError: IDL.Record({\n    message: IDL.Text,\n    error_code: IDL.Nat\n  }),\n  TemporarilyUnavailable: IDL.Null,\n  BadBurn: IDL.Record({min_burn_amount: IDL.Nat}),\n  Duplicate: IDL.Record({duplicate_of: IDL.Nat}),\n  BadFee: IDL.Record({expected_fee: IDL.Nat}),\n  CreatedInFuture: IDL.Record({ledger_time: Timestamp}),\n  TooOld: IDL.Null,\n  InsufficientFunds: IDL.Record({balance: IDL.Nat})\n});\n\nexport const TransferResult = IDL.Variant({Ok: IDL.Nat, Err: TransferError});\n", "import {IDL} from '@dfinity/candid';\n\n/**\n * TODO: All the constants of this module should be exposed by the IDL files - i.e. should be generated as exposed by didc\n */\n\nconst Account = IDL.Record({\n  owner: IDL.Principal,\n  subaccount: IDL.Opt(IDL.Vec(IDL.Nat8))\n});\n\nexport const ApproveArgs = IDL.Record({\n  fee: IDL.Opt(IDL.Nat),\n  memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n  from_subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)),\n  created_at_time: IDL.Opt(IDL.Nat64),\n  amount: IDL.Nat,\n  expected_allowance: IDL.Opt(IDL.Nat),\n  expires_at: IDL.Opt(IDL.Nat64),\n  spender: Account\n});\n\nexport const TransferFromArgs = IDL.Record({\n  to: Account,\n  fee: IDL.Opt(IDL.Nat),\n  spender_subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)),\n  from: Account,\n  memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n  created_at_time: IDL.Opt(IDL.Nat64),\n  amount: IDL.Nat\n});\n\nconst ApproveError = IDL.Variant({\n  GenericError: IDL.Record({\n    message: IDL.Text,\n    error_code: IDL.Nat\n  }),\n  TemporarilyUnavailable: IDL.Null,\n  Duplicate: IDL.Record({duplicate_of: IDL.Nat}),\n  BadFee: IDL.Record({expected_fee: IDL.Nat}),\n  AllowanceChanged: IDL.Record({current_allowance: IDL.Nat}),\n  CreatedInFuture: IDL.Record({ledger_time: IDL.Nat64}),\n  TooOld: IDL.Null,\n  Expired: IDL.Record({ledger_time: IDL.Nat64}),\n  InsufficientFunds: IDL.Record({balance: IDL.Nat})\n});\n\nconst TransferFromError = IDL.Variant({\n  GenericError: IDL.Record({\n    message: IDL.Text,\n    error_code: IDL.Nat\n  }),\n  TemporarilyUnavailable: IDL.Null,\n  InsufficientAllowance: IDL.Record({allowance: IDL.Nat}),\n  BadBurn: IDL.Record({min_burn_amount: IDL.Nat}),\n  Duplicate: IDL.Record({duplicate_of: IDL.Nat}),\n  BadFee: IDL.Record({expected_fee: IDL.Nat}),\n  CreatedInFuture: IDL.Record({ledger_time: IDL.Nat64}),\n  TooOld: IDL.Null,\n  InsufficientFunds: IDL.Record({balance: IDL.Nat})\n});\n\nexport const ApproveResult = IDL.Variant({Ok: IDL.Nat, Err: ApproveError});\nexport const TransferFromResult = IDL.Variant({Ok: IDL.Nat, Err: TransferFromError});\n", "import {assertNonNullish, nonNullish, notEmptyString} from '@dfinity/utils';\nimport {ICRC25_PERMISSION_GRANTED} from './constants/icrc.constants';\nimport {\n  RELYING_PARTY_CHECK_WALLET_STATUS_INTERVAL,\n  RELYING_PARTY_CONNECT_TIMEOUT_IN_MILLISECONDS,\n  RELYING_PARTY_DEFAULT_SCOPES,\n  RELYING_PARTY_TIMEOUT_ACCOUNTS,\n  RELYING_PARTY_TIMEOUT_CALL_CANISTER,\n  RELYING_PARTY_TIMEOUT_PERMISSIONS,\n  RELYING_PARTY_TIMEOUT_REQUEST_PERMISSIONS,\n  RELYING_PARTY_TIMEOUT_REQUEST_STATUS,\n  RELYING_PARTY_TIMEOUT_REQUEST_SUPPORTED_STANDARD\n} from './constants/relying-party.constants';\nimport {DEFAULT_SIGNER_WINDOW_TOP_RIGHT} from './constants/window.constants';\nimport {\n  permissions,\n  requestAccounts,\n  requestCallCanister,\n  requestPermissions,\n  requestStatus,\n  requestSupportedStandards,\n  retryRequestStatus\n} from './handlers/relying-party.handlers';\nimport type {IcrcAccounts} from './types/icrc-accounts';\nimport type {IcrcAnyRequestedScopes, IcrcCallCanisterRequestParams} from './types/icrc-requests';\nimport {\n  IcrcAccountsResponseSchema,\n  IcrcCallCanisterResponseSchema,\n  IcrcReadyResponseSchema,\n  IcrcScopesResponseSchema,\n  IcrcSupportedStandardsResponseSchema,\n  type IcrcCallCanisterResult,\n  type IcrcScopeMethod,\n  type IcrcScopesArray,\n  type IcrcSupportedStandards\n} from './types/icrc-responses';\nimport type {Origin} from './types/post-message';\nimport type {RelyingPartyMessageEvent, RelyingPartyMessageEventData} from './types/relying-party';\nimport {\n  RelyingPartyDisconnectedError,\n  RelyingPartyResponseError\n} from './types/relying-party-errors';\nimport {\n  RelyingPartyOptionsSchema,\n  type RelyingPartyHost,\n  type RelyingPartyOptions\n} from './types/relying-party-options';\nimport {\n  RelyingPartyRequestOptionsSchema,\n  type RelyingPartyRequestOptions,\n  type RelyingPartyRequestOptionsWithTimeout\n} from './types/relying-party-requests';\nimport {\n  RpcResponseWithErrorSchema,\n  RpcResponseWithResultOrErrorSchema,\n  type RpcId\n} from './types/rpc';\nimport {assertCallResponse} from './utils/call.utils';\nimport type {ReadyOrError} from './utils/timeout.utils';\nimport {windowFeatures} from './utils/window.utils';\n\ntype WalletStatus = 'connected' | 'disconnected';\n\nexport class RelyingParty {\n  readonly #origin: Origin;\n  readonly #popup: Window;\n\n  readonly #onDisconnect;\n\n  protected readonly host: RelyingPartyHost;\n\n  #walletStatus: WalletStatus = 'connected';\n  readonly #walletStatusInterval: NodeJS.Timeout;\n\n  // TODO: maybe we also want to make the relying party a bit more opiniated in the sense that on connect or each time a request is sent, we can first check if the desired standards is supported.\n  // e.g. I'm the client and I ask for \"accounts\" but actually the signer does not support accounts.\n\n  protected constructor({\n    origin,\n    popup,\n    onDisconnect,\n    host\n  }: {origin: Origin; popup: Window} & Pick<RelyingPartyOptions, 'onDisconnect' | 'host'>) {\n    this.#origin = origin;\n    this.#popup = popup;\n\n    this.#onDisconnect = onDisconnect;\n\n    this.host = host;\n\n    this.#walletStatus = 'connected';\n    this.#walletStatusInterval = setInterval(\n      this.checkWalletStatusCallback,\n      RELYING_PARTY_CHECK_WALLET_STATUS_INTERVAL\n    );\n  }\n\n  // TODO: create an opinionated extends of RelyingParty which does connect + request accounts in one short\n  // According Pete during UX review, this is the standard wallet UX people are expecting.\n  // IcpWallet extends SomethingNew extends RelyingParty\n\n  /**\n   * Establishes a connection with a signer.\n   *\n   * @static\n   * @param {RelyingPartyOptions} options - The options to initialize the signer.\n   * @returns {Promise<RelyingParty>} A promise that resolves to an object, which can be used to interact with the signer when it is connected.\n   */\n  static async connect({onDisconnect, ...rest}: RelyingPartyOptions): Promise<RelyingParty> {\n    return await this.connectSigner({\n      options: rest,\n      init: (params: {origin: Origin; popup: Window}) =>\n        new RelyingParty({\n          ...params,\n          onDisconnect\n        })\n    });\n  }\n\n  protected static async connectSigner<T extends RelyingParty>({\n    options,\n    init\n  }: {\n    options: RelyingPartyOptions;\n    init: (params: {origin: Origin; popup: Window}) => T;\n  }): Promise<T> {\n    const {success: optionsSuccess, error} = RelyingPartyOptionsSchema.safeParse(options);\n\n    if (!optionsSuccess) {\n      throw new Error(`Options cannot be parsed: ${error?.message ?? ''}`);\n    }\n\n    const {url, windowOptions, connectionOptions} = options;\n\n    const popupFeatures =\n      typeof windowOptions === 'string'\n        ? windowOptions\n        : windowFeatures(windowOptions ?? DEFAULT_SIGNER_WINDOW_TOP_RIGHT);\n\n    const popup = window.open(url, 'relyingPartyWindow', popupFeatures);\n\n    assertNonNullish(popup, 'Unable to open the signer window.');\n\n    const close = (): void => {\n      popup.close();\n    };\n\n    class MessageError extends Error {}\n\n    let response: T | MessageError | undefined;\n\n    const onMessage = ({origin, data: msgData}: MessageEvent): void => {\n      const {success} = RpcResponseWithResultOrErrorSchema.safeParse(msgData);\n\n      if (!success) {\n        // We are only interested in JSON-RPC messages, so we are ignoring any other messages emitted at the window level, as the consumer might be using other events.\n        return;\n      }\n\n      let expectedOrigin: string;\n\n      try {\n        const {origin: relyingPartyOrigin} = new URL(url);\n        expectedOrigin = relyingPartyOrigin;\n      } catch (_err: unknown) {\n        // Unlikely to happen if window.open succeeded\n        response = new MessageError(\n          `The origin ${origin} of the signer URL ${url} cannot be parsed.`\n        );\n        return;\n      }\n\n      // In our test suite, origin is set to empty string when the message originate from the same window - i.e. when retryRequestStatus are emitted.// In our test suite, the origin is set to an empty string when the message originates from the same window. This occurs when `retryRequestStatus` events are emitted to `*`.\n      if (notEmptyString(origin) && origin !== expectedOrigin) {\n        response = new MessageError(\n          `The response origin ${origin} does not match the requested signer URL ${url}.`\n        );\n        return;\n      }\n\n      const {success: isWalletReady} = IcrcReadyResponseSchema.safeParse(msgData);\n      if (isWalletReady) {\n        response = init({origin, popup});\n      }\n    };\n\n    window.addEventListener('message', onMessage);\n\n    const disconnect = (): void => {\n      window.removeEventListener('message', onMessage);\n\n      // TODO: it should maybe also automatically close the window on disconnect?\n    };\n\n    const connect = async (): Promise<T> => {\n      const result = await retryRequestStatus({\n        popup,\n        isReady: (): ReadyOrError | 'pending' =>\n          nonNullish(response) ? (response instanceof RelyingParty ? 'ready' : 'error') : 'pending',\n        id: crypto.randomUUID(),\n        timeoutInMilliseconds:\n          connectionOptions?.timeoutInMilliseconds ?? RELYING_PARTY_CONNECT_TIMEOUT_IN_MILLISECONDS,\n        intervalInMilliseconds: connectionOptions?.pollingIntervalInMilliseconds\n      });\n\n      if (result === 'timeout') {\n        throw new Error('Connection timeout. Unable to connect to the signer.');\n      }\n\n      assertNonNullish(\n        response,\n        'Unexpected error. The request status succeeded, but the signer response is not defined.'\n      );\n\n      if (response instanceof MessageError) {\n        throw response;\n      }\n\n      return response;\n    };\n\n    try {\n      return await connect();\n    } catch (err: unknown) {\n      // We close the popup only in case of an error. If the connection is successful, the developers will interact with the relying party and are responsible for disconnecting it.\n      close();\n\n      throw err;\n    } finally {\n      // We remove the event listener because this implementation scopes message exchanges to individual functions. Each function subscribes to messages, notifies the relying party, and waits for a response.\n      disconnect();\n    }\n  }\n\n  /**\n   * Disconnects the signer by closing the associated popup window.\n   *\n   * @returns {Promise<void>} A promise that resolves when the signer has been successfully disconnected.\n   */\n  // eslint-disable-next-line require-await\n  disconnect = async (): Promise<void> => {\n    clearInterval(this.#walletStatusInterval);\n    this.#popup.close();\n    this.#onDisconnect?.();\n  };\n\n  private checkWalletStatusCallback = (): void => {\n    void this.checkWalletStatus();\n  };\n\n  private async checkWalletStatus() {\n    const handleMessage = ({\n      data,\n      id\n    }: {\n      data: RelyingPartyMessageEventData;\n      id: RpcId;\n    }): {handled: boolean; result: WalletStatus} => {\n      const {success: isWalletReady, data: walletReadyData} =\n        IcrcReadyResponseSchema.safeParse(data);\n      if (isWalletReady && id === walletReadyData?.id) {\n        return {handled: true, result: 'connected'};\n      }\n\n      // This can only happen in the rare event that the Wallet is disconnected immediately after the postMessage inquiring about the status is emitted.\n      return {handled: true, result: 'disconnected'};\n    };\n\n    const postRequest = (id: RpcId): void => {\n      requestStatus({\n        popup: this.#popup,\n        origin: this.#origin,\n        id\n      });\n    };\n\n    const checkWalletStatus = async (): Promise<WalletStatus> => {\n      try {\n        return await this.request<WalletStatus>({\n          options: {\n            timeoutInMilliseconds: RELYING_PARTY_TIMEOUT_REQUEST_STATUS\n          },\n          postRequest,\n          handleMessage\n        });\n      } catch (_err: unknown) {\n        return 'disconnected';\n      }\n    };\n\n    this.#walletStatus = await checkWalletStatus();\n\n    if (this.#walletStatus === 'connected') {\n      return;\n    }\n\n    await this.disconnect();\n  }\n\n  /**\n   * Sends an asynchronous request to the signer and handles the response with the provided handlers.\n   *\n   * @template T - The type of the result expected from the response.\n   *\n   * @param {Object} params - Parameters for the request.\n   * @param {RelyingPartyRequestOptions} params.options - Options for configuring the signer request.\n   * @param {(id: RpcId) => void} params.postRequest - The request function that sends the request to the signer using either the provided ID or a generated ID.\n   * @param {(params: { data: RelyingPartyMessageEventData; id: RpcId }) => Promise<{ handled: boolean; result?: T }>} params.handleMessage -\n   *        A function to handle incoming messages, which should return an object indicating whether the message was handled and optionally include the result. If both `handled` is `true` and the `result` is not `null`, the process is disconnected, i.e., no more listeners will await an answer from the relying party.\n   *\n   * @returns {Promise<T>} A promise that resolves with the result of the request.\n   *\n   * @throws {Error} If the signer request options cannot be parsed or if the request times out.\n   *\n   * @private\n   */\n  private readonly request = async <T>({\n    options,\n    postRequest,\n    handleMessage\n  }: {\n    options: Omit<RelyingPartyRequestOptions, 'timeoutInMilliseconds'> &\n      Required<Pick<RelyingPartyRequestOptions, 'timeoutInMilliseconds'>>;\n    postRequest: (id: RpcId) => void;\n    handleMessage: (params: {data: RelyingPartyMessageEventData; id: RpcId}) => {\n      handled: boolean;\n      result?: T;\n    };\n  }): Promise<T> =>\n    await new Promise<T>((resolve, reject) => {\n      const {connected, err} = this.assertWalletConnected();\n      if (!connected) {\n        reject(err ?? new Error('Unexpected reason for disconnection.'));\n        return;\n      }\n\n      const {success: optionsSuccess, error} = RelyingPartyRequestOptionsSchema.safeParse(options);\n\n      if (!optionsSuccess) {\n        throw new Error(`Wallet request options cannot be parsed: ${error?.message ?? ''}`);\n      }\n\n      const {requestId: userRequestId, timeoutInMilliseconds} = options;\n\n      const requestId = userRequestId ?? crypto.randomUUID();\n\n      const timeoutId = setTimeout(() => {\n        reject(\n          new Error(`Request to signer timed out after ${timeoutInMilliseconds} milliseconds.`)\n        );\n        disconnect();\n      }, timeoutInMilliseconds);\n\n      const onMessage = ({origin, data, source}: RelyingPartyMessageEvent) => {\n        const {success} = RpcResponseWithResultOrErrorSchema.safeParse(data);\n\n        if (!success) {\n          // We are only interested in JSON-RPC messages, so we are ignoring any other messages emitted at the window level, as the consumer might be using other events.\n          return;\n        }\n\n        if (source !== this.#popup) {\n          reject(new Error('The response is not originating from the window that was opened.'));\n\n          disconnect();\n          return;\n        }\n\n        if (notEmptyString(origin) && origin !== this.#origin) {\n          reject(\n            new Error(\n              `The response origin ${origin} does not match the signer origin ${this.#origin}.`\n            )\n          );\n\n          disconnect();\n          return;\n        }\n\n        const {handled, result} = handleMessage({data, id: requestId});\n\n        if (handled && nonNullish(result)) {\n          resolve(result);\n          disconnect();\n          return;\n        }\n\n        const checkError = this.handleErrorMessage({data, id: requestId});\n\n        if (!checkError.valid) {\n          reject(checkError.error);\n          disconnect();\n        }\n      };\n\n      window.addEventListener('message', onMessage);\n\n      const disconnect = (): void => {\n        clearTimeout(timeoutId);\n        window.removeEventListener('message', onMessage);\n      };\n\n      postRequest(requestId);\n    });\n\n  private assertWalletConnected(): {connected: boolean; err?: RelyingPartyDisconnectedError} {\n    // TODO: this use case is not covered yet with a unit test. Some issue with mocking the timer.\n    // On the contrary, the other use case, the popup being closed, is already covered.\n    if (this.#walletStatus === 'disconnected') {\n      return {\n        connected: false,\n        err: new RelyingPartyDisconnectedError(\n          'The signer has been disconnected. Your request cannot be processed.'\n        )\n      };\n    }\n\n    // Can happen given that the polling for the status wallet happens every RELYING_PARTY_CHECK_WALLET_STATUS_INTERVAL seconds\n    if (this.#popup.closed) {\n      return {\n        connected: false,\n        err: new RelyingPartyDisconnectedError(\n          'The signer has been closed. Your request cannot be processed.'\n        )\n      };\n    }\n\n    return {\n      connected: true\n    };\n  }\n\n  /**\n   * List the standards supported by the signer.\n   *\n   * @async\n   * @param {RelyingPartyRequestOptions} options - The options for the signer request, which may include parameters such as timeout settings and other request-specific configurations.\n   * @returns {Promise<IcrcSupportedStandards>} A promise that resolves to an object containing the supported ICRC standards by the relying party. This includes details about each standard that the relying party can handle.\n   * @see [ICRC25 Supported Standards](https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_supported_standards)\n   */\n  supportedStandards = async ({\n    options: {timeoutInMilliseconds, ...rest} = {}\n  }: {options?: RelyingPartyRequestOptions} = {}): Promise<IcrcSupportedStandards> => {\n    const handleMessage = ({\n      data,\n      id\n    }: {\n      data: RelyingPartyMessageEventData;\n      id: RpcId;\n    }): {handled: boolean; result?: IcrcSupportedStandards} => {\n      const {success: isSupportedStandards, data: supportedStandardsData} =\n        IcrcSupportedStandardsResponseSchema.safeParse(data);\n\n      if (\n        isSupportedStandards &&\n        id === supportedStandardsData?.id &&\n        nonNullish(supportedStandardsData?.result)\n      ) {\n        const {\n          result: {supportedStandards: result}\n        } = supportedStandardsData;\n        return {handled: true, result};\n      }\n\n      return {handled: false};\n    };\n\n    const postRequest = (id: RpcId): void => {\n      requestSupportedStandards({\n        popup: this.#popup,\n        origin: this.#origin,\n        id\n      });\n    };\n\n    return await this.request<IcrcSupportedStandards>({\n      options: {\n        timeoutInMilliseconds:\n          timeoutInMilliseconds ?? RELYING_PARTY_TIMEOUT_REQUEST_SUPPORTED_STANDARD,\n        ...rest\n      },\n      postRequest,\n      handleMessage\n    });\n  };\n\n  /**\n   * Query the state of all permissions of the signer.\n   *\n   * @async\n   * @param {RelyingPartyRequestOptions} options - The options for the signer request, which may include parameters such as timeout settings and other request-specific configurations.\n   * @returns {Promise<IcrcScopes>} A promise that resolves to all permissions the signer knows about. The result might be empty if no permissions were ever requested or if the permissions are outdated.\n   * @see [ICRC25 Permissions](https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_permissions)\n   */\n  permissions = async ({\n    options: {timeoutInMilliseconds, ...rest} = {}\n  }: {\n    options?: RelyingPartyRequestOptions;\n  } = {}): Promise<IcrcScopesArray> => {\n    const postRequest = (id: RpcId): void => {\n      permissions({\n        popup: this.#popup,\n        origin: this.#origin,\n        id\n      });\n    };\n\n    return await this.requestPermissionsScopes({\n      options: {\n        timeoutInMilliseconds: timeoutInMilliseconds ?? RELYING_PARTY_TIMEOUT_PERMISSIONS,\n        ...rest\n      },\n      postRequest\n    });\n  };\n\n  /**\n   * Request permissions from the signer.\n   *\n   * @async\n   * @param {Object} args - The arguments object.\n   * @param {RelyingPartyRequestOptions} [args.options] - The options for the signer request, which may include parameters such as timeout settings and other request-specific configurations.\n   * @param {Partial<IcrcAnyRequestedScopes>} [args.params] - The specific scopes being requested from the signer. These define the permissions that the signer may grant.\n   * @returns {Promise<IcrcScopesArray>} A promise that resolves to the permissions that were confirmed by the user of the signer.\n   * @see [ICRC25 Request Permissions](https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_request_permissions)\n   */\n  requestPermissions = async ({\n    options: {timeoutInMilliseconds, ...rest} = {},\n    params\n  }: {\n    options?: RelyingPartyRequestOptions;\n    params?: IcrcAnyRequestedScopes;\n  } = {}): Promise<IcrcScopesArray> => {\n    const postRequest = (id: RpcId): void => {\n      requestPermissions({\n        popup: this.#popup,\n        origin: this.#origin,\n        id,\n        params: params ?? RELYING_PARTY_DEFAULT_SCOPES\n      });\n    };\n\n    return await this.requestPermissionsScopes({\n      options: {\n        timeoutInMilliseconds: timeoutInMilliseconds ?? RELYING_PARTY_TIMEOUT_REQUEST_PERMISSIONS,\n        ...rest\n      },\n      postRequest\n    });\n  };\n\n  private readonly requestPermissionsScopes = async ({\n    options,\n    postRequest\n  }: {\n    options: RelyingPartyRequestOptionsWithTimeout;\n    postRequest: (id: RpcId) => void;\n  }): Promise<IcrcScopesArray> => {\n    const handleMessage = ({\n      data,\n      id\n    }: {\n      data: RelyingPartyMessageEventData;\n      id: RpcId;\n    }): {handled: boolean; result?: IcrcScopesArray} => {\n      const {success: isRequestPermissions, data: requestPermissionsData} =\n        IcrcScopesResponseSchema.safeParse(data);\n\n      if (\n        isRequestPermissions &&\n        id === requestPermissionsData?.id &&\n        nonNullish(requestPermissionsData?.result)\n      ) {\n        const {\n          result: {scopes}\n        } = requestPermissionsData;\n\n        return {handled: true, result: scopes};\n      }\n\n      return {handled: false};\n    };\n\n    return await this.request<IcrcScopesArray>({\n      options,\n      postRequest,\n      handleMessage\n    });\n  };\n\n  /**\n   * List the accounts supported by the signer.\n   *\n   * @async\n   * @param {RelyingPartyRequestOptions} options - The options for the signer request, which may include parameters such as timeout settings and other request-specific configurations.\n   * @returns {Promise<IcrcAccounts>} A promise that resolves to an object containing the supported ICRC accounts by the signer.\n   * @see [ICRC27 Get Accounts](https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_27_accounts.md)\n   */\n  accounts = async ({\n    options: {timeoutInMilliseconds, ...rest} = {}\n  }: {options?: RelyingPartyRequestOptions} = {}): Promise<IcrcAccounts> => {\n    const handleMessage = ({\n      data,\n      id\n    }: {\n      data: RelyingPartyMessageEventData;\n      id: RpcId;\n    }): {handled: boolean; result?: IcrcAccounts} => {\n      const {success: isAccounts, data: accountsData} = IcrcAccountsResponseSchema.safeParse(data);\n\n      if (isAccounts && id === accountsData?.id && nonNullish(accountsData?.result)) {\n        const {\n          result: {accounts: result}\n        } = accountsData;\n        return {handled: true, result};\n      }\n\n      return {handled: false};\n    };\n\n    const postRequest = (id: RpcId): void => {\n      requestAccounts({\n        popup: this.#popup,\n        origin: this.#origin,\n        id\n      });\n    };\n\n    return await this.request<IcrcAccounts>({\n      options: {\n        timeoutInMilliseconds: timeoutInMilliseconds ?? RELYING_PARTY_TIMEOUT_ACCOUNTS,\n        ...rest\n      },\n      postRequest,\n      handleMessage\n    });\n  };\n\n  // TODO: This method is marked as `protected` because it lacks response validation.\n  // Validation is deferred to opinionated implementations like `IcpWallet` or `IcrcWallet`.\n  // If you wish to make this method public, ensure that proper validation is implemented first.\n  /**\n   * Call a canister method via the signer.\n   *\n   * @async\n   * @template T - The type of the argument being passed to the canister call.\n   * @param {Object} args - The arguments for the call.\n   * @param {IcrcCallCanisterRequestParams} args.params - The parameters required to call the canister, including the canister ID, method name, and the encoded argument payload.\n   * @param {RelyingPartyRequestOptions} [args.options] - The options for the signer request, which may include parameters such as timeout settings and other request-specific configurations.\n   * @returns {Promise<IcrcCallCanisterResult>} A promise that resolves to the result of the canister call.\n   * @see [ICRC49 Call Canister](https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_49_call_canister.md)\n   */\n  protected call = async ({\n    options: {timeoutInMilliseconds, ...rest} = {},\n    params\n  }: {\n    options?: RelyingPartyRequestOptions;\n    params: IcrcCallCanisterRequestParams;\n  }): Promise<IcrcCallCanisterResult> => {\n    const handleMessage = ({\n      data,\n      id\n    }: {\n      data: RelyingPartyMessageEventData;\n      id: RpcId;\n    }): {handled: boolean; result?: IcrcCallCanisterResult} => {\n      const {success: isCallCanister, data: resultData} =\n        IcrcCallCanisterResponseSchema.safeParse(data);\n\n      if (isCallCanister && id === resultData?.id && nonNullish(resultData?.result)) {\n        const {result} = resultData;\n        return {handled: true, result};\n      }\n\n      return {handled: false};\n    };\n\n    // TODO: Automatically generate a nonce if not provided by the consumer.\n    // TODO: Improve typings. Externally, it can be undefined, but internally it should not be.\n    // TODO: Assert the nonce during the decoding of the response.\n\n    const postRequest = (id: RpcId): void => {\n      requestCallCanister({\n        popup: this.#popup,\n        origin: this.#origin,\n        id,\n        params\n      });\n    };\n\n    const result = await this.request<IcrcCallCanisterResult>({\n      options: {\n        timeoutInMilliseconds: timeoutInMilliseconds ?? RELYING_PARTY_TIMEOUT_CALL_CANISTER,\n        ...rest\n      },\n      postRequest,\n      handleMessage\n    });\n\n    assertCallResponse({\n      params,\n      result\n    });\n\n    return result;\n  };\n\n  private readonly handleErrorMessage = ({\n    data,\n    id\n  }: {\n    data: RelyingPartyMessageEventData;\n    id: RpcId;\n  }): {valid: true} | {valid: false; error: RelyingPartyResponseError | Error} => {\n    const {success: isError, data: errorData} = RpcResponseWithErrorSchema.safeParse(data);\n\n    if (!isError || id !== errorData?.id) {\n      return {valid: true};\n    }\n\n    return {\n      valid: false,\n      error: new RelyingPartyResponseError(errorData.error)\n    };\n  };\n\n  /**\n   * Checks the current set of permissions and automatically requests any that have not yet been granted.\n   * This is useful for dApps that wish to request all necessary permissions up-front.\n   *\n   * @async\n   * @param {RelyingPartyRequestOptions} options - The options for the signer request, which may include parameters such as timeout settings and other request-specific configurations.\n   * @returns {Promise<{allPermissionsGranted: boolean}>} - A promise resolving to an object indicating whether all required permissions have been granted.\n   */\n  requestPermissionsNotGranted = async ({\n    options\n  }: {\n    options?: RelyingPartyRequestOptions;\n  } = {}): Promise<{allPermissionsGranted: boolean}> => {\n    const findNotGranted = (permissions: IcrcScopesArray): IcrcScopeMethod[] =>\n      permissions.filter(({state}) => state !== ICRC25_PERMISSION_GRANTED).map(({scope}) => scope);\n\n    const permissions = await this.permissions({options});\n\n    if (permissions.length === 0) {\n      throw new Error('The signer did not provide any data about the current set of permissions.');\n    }\n\n    const notGrantedScopes = findNotGranted(permissions);\n\n    if (notGrantedScopes.length === 0) {\n      return {allPermissionsGranted: true};\n    }\n\n    const result = await this.requestPermissions({\n      options,\n      params: {\n        scopes: notGrantedScopes\n      }\n    });\n\n    if (result.length === 0) {\n      throw new Error(\n        'The signer did not provide any data about the current set of permissions following the request.'\n      );\n    }\n\n    const remainingNotGrantedScopes = findNotGranted(result);\n\n    return {allPermissionsGranted: remainingNotGrantedScopes.length === 0};\n  };\n}\n", "export const ICRC21_CALL_CONSENT_MESSAGE = 'icrc21_call_consent_message';\nexport const ICRC25_REQUEST_PERMISSIONS = 'icrc25_request_permissions';\nexport const ICRC25_PERMISSIONS = 'icrc25_permissions';\nexport const ICRC25_SUPPORTED_STANDARDS = 'icrc25_supported_standards';\nexport const ICRC27_ACCOUNTS = 'icrc27_accounts';\nexport const ICRC29_STATUS = 'icrc29_status';\nexport const ICRC49_CALL_CANISTER = 'icrc49_call_canister';\n\nexport const ICRC25_PERMISSION_GRANTED = 'granted';\nexport const ICRC25_PERMISSION_DENIED = 'denied';\nexport const ICRC25_PERMISSION_ASK_ON_USE = 'ask_on_use';\n\nexport const ICRC21 = 'ICRC-21';\nexport const ICRC25 = 'ICRC-25';\nexport const ICRC27 = 'ICRC-27';\nexport const ICRC29 = 'ICRC-29';\nexport const ICRC49 = 'ICRC-49';\n", "import * as z from 'zod/v4';\nimport {\n  ICRC21,\n  ICRC21_CALL_CONSENT_MESSAGE,\n  ICRC25,\n  ICRC25_PERMISSION_ASK_ON_USE,\n  ICRC25_PERMISSION_DENIED,\n  ICRC25_PERMISSION_GRANTED,\n  ICRC25_PERMISSIONS,\n  ICRC25_REQUEST_PERMISSIONS,\n  ICRC25_SUPPORTED_STANDARDS,\n  ICRC27,\n  ICRC27_ACCOUNTS,\n  ICRC29,\n  ICRC29_STATUS,\n  ICRC49,\n  ICRC49_CALL_CANISTER\n} from '../constants/icrc.constants';\n\nexport const IcrcMethodSchema = z.enum([\n  ICRC21_CALL_CONSENT_MESSAGE,\n  ICRC25_REQUEST_PERMISSIONS,\n  ICRC25_PERMISSIONS,\n  ICRC25_SUPPORTED_STANDARDS,\n  ICRC27_ACCOUNTS,\n  ICRC29_STATUS,\n  ICRC49_CALL_CANISTER\n]);\n\nexport const IcrcScopedMethodSchema = IcrcMethodSchema.extract([\n  ICRC27_ACCOUNTS,\n  ICRC49_CALL_CANISTER\n]);\n\nexport type IcrcScopedMethod = z.infer<typeof IcrcScopedMethodSchema>;\n\nexport const IcrcPermissionStateSchema = z.enum([\n  ICRC25_PERMISSION_GRANTED,\n  ICRC25_PERMISSION_DENIED,\n  ICRC25_PERMISSION_ASK_ON_USE\n]);\n\nexport type IcrcPermissionState = z.infer<typeof IcrcPermissionStateSchema>;\n\nexport const IcrcStandardSchema = z.enum([ICRC21, ICRC25, ICRC27, ICRC29, ICRC49]);\n", "import type {IcrcRequestedScopes} from '../types/icrc-requests';\nimport {IcrcScopedMethodSchema} from '../types/icrc-standards';\n\nexport const RELYING_PARTY_CHECK_WALLET_STATUS_INTERVAL = 5000;\n\nconst RELYING_PARTY_TIMEOUT_IN_MILLISECONDS_WITH_USER_INTERACTION = 60 * 2 * 1000;\nconst RELYING_PARTY_TIMEOUT_IN_MILLISECONDS_WITHOUT_USER_INTERACTION = 5000;\n\nexport const RELYING_PARTY_CONNECT_TIMEOUT_IN_MILLISECONDS =\n  RELYING_PARTY_TIMEOUT_IN_MILLISECONDS_WITH_USER_INTERACTION;\nexport const RELYING_PARTY_TIMEOUT_REQUEST_SUPPORTED_STANDARD =\n  RELYING_PARTY_TIMEOUT_IN_MILLISECONDS_WITHOUT_USER_INTERACTION;\nexport const RELYING_PARTY_TIMEOUT_REQUEST_PERMISSIONS =\n  RELYING_PARTY_TIMEOUT_IN_MILLISECONDS_WITH_USER_INTERACTION;\nexport const RELYING_PARTY_TIMEOUT_PERMISSIONS =\n  RELYING_PARTY_TIMEOUT_IN_MILLISECONDS_WITHOUT_USER_INTERACTION;\nexport const RELYING_PARTY_TIMEOUT_ACCOUNTS =\n  RELYING_PARTY_TIMEOUT_IN_MILLISECONDS_WITH_USER_INTERACTION;\nexport const RELYING_PARTY_TIMEOUT_CALL_CANISTER =\n  RELYING_PARTY_TIMEOUT_IN_MILLISECONDS_WITH_USER_INTERACTION;\nexport const RELYING_PARTY_TIMEOUT_REQUEST_STATUS =\n  RELYING_PARTY_TIMEOUT_IN_MILLISECONDS_WITHOUT_USER_INTERACTION;\n\nexport const RELYING_PARTY_DEFAULT_SCOPES: IcrcRequestedScopes = {\n  scopes: Object.values(IcrcScopedMethodSchema.enum).map((method) => ({method}))\n};\n", "import type {WindowOptions} from '../types/relying-party-options';\n\nexport const DEFAULT_SIGNER_WINDOW_FEATURES =\n  'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=no, copyhistory=no';\n\nexport const DEFAULT_SIGNER_WINDOW_SIZE: Pick<WindowOptions, 'width' | 'height'> = {\n  width: 576,\n  height: 625\n};\n\nexport const DEFAULT_SIGNER_WINDOW_TOP_RIGHT: WindowOptions = {\n  ...DEFAULT_SIGNER_WINDOW_SIZE,\n  position: 'top-right',\n  features: DEFAULT_SIGNER_WINDOW_FEATURES\n};\n\nexport const DEFAULT_SIGNER_WINDOW_CENTER: WindowOptions = {\n  ...DEFAULT_SIGNER_WINDOW_SIZE,\n  position: 'center',\n  features: DEFAULT_SIGNER_WINDOW_FEATURES\n};\n", "export const DEFAULT_POLLING_INTERVAL_IN_MILLISECONDS = 500;\n\nexport const LOCAL_REPLICA_URL = 'http://localhost:4943';\nexport const MAINNET_REPLICA_URL = 'https://icp-api.io';\n", "import * as z from 'zod/v4';\n\n// JSON-RPC 2.0 Specification\n// https://www.jsonrpc.org/specification\n\nexport const JSON_RPC_VERSION_2 = '2.0';\n\nconst JsonRpcSchema = z.literal(JSON_RPC_VERSION_2);\n\nexport const RpcIdSchema = z.union([z.string(), z.number(), z.null()]);\n\nexport type RpcId = z.infer<typeof RpcIdSchema>;\n\nconst RpcSchema = z.object({\n  jsonrpc: JsonRpcSchema,\n  id: z.optional(RpcIdSchema)\n});\n\nexport const RpcRequestSchema = RpcSchema.extend({\n  id: RpcIdSchema\n})\n  .merge(\n    z.object({\n      method: z.string(),\n      params: z.optional(z.any())\n    })\n  )\n  .strict();\n\ntype _RpcRequest = z.infer<typeof RpcRequestSchema>;\n\nexport const inferRpcRequestWithoutParamsSchema = <M extends string>({method}: {method: M}) =>\n  RpcRequestSchema.omit({method: true, params: true})\n    .strict()\n    .extend({\n      id: RpcIdSchema,\n      method: z.literal(method)\n    });\n\ntype RpcRequestWithoutParamsReturnType<M extends string> = ReturnType<\n  typeof inferRpcRequestWithoutParamsSchema<M>\n>;\n\ntype _RpcRequestWithoutParams<M extends string> = z.infer<RpcRequestWithoutParamsReturnType<M>>;\n\nexport const inferRpcRequestWithParamsSchema = <T extends z.ZodTypeAny, M extends string>({\n  params,\n  method\n}: {\n  params: T;\n  method: M;\n}) =>\n  RpcRequestSchema.omit({method: true})\n    .extend({\n      id: RpcIdSchema,\n      method: z.literal(method)\n    })\n    .merge(\n      z.object({\n        params\n      })\n    );\n\nexport const RpcNotificationSchema = RpcRequestSchema.omit({id: true}).strict();\n\nexport enum RpcErrorCode {\n  /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */\n  PARSE_ERROR = -32700,\n  /**\n   * The JSON sent is not a valid Request object.\n   */\n  INVALID_REQUEST = -32600,\n  /**\n   * The method does not exist / is not available.\n   */\n  METHOD_NOT_FOUND = -32601,\n  /**\n   * Invalid method parameter(s).\n   */\n  INVALID_PARAMS = -32602,\n  /**\n   * Internal JSON-RPC error.\n   */\n  INTERNAL_ERROR = -32603,\n  /**\n   * Reserved for implementation-defined server-errors.\n   */\n  SERVER_ERROR = -32000\n}\n\nconst RpcResponseErrorCodeSchema = z.union([z.number(), z.nativeEnum(RpcErrorCode)]);\n\nexport type RpcResponseErrorCode = z.infer<typeof RpcResponseErrorCodeSchema>;\n\nconst RpcResponseErrorSchema = z.object({\n  code: RpcResponseErrorCodeSchema,\n  message: z.string(),\n  data: z.optional(z.never())\n});\n\nexport type RpcResponseError = z.infer<typeof RpcResponseErrorSchema>;\n\nconst RpcResponseSchema = RpcSchema.extend({\n  id: RpcIdSchema\n});\n\nexport type RpcResponse = z.infer<typeof RpcResponseSchema>;\n\nexport const RpcResponseWithErrorSchema = RpcResponseSchema.extend({\n  error: RpcResponseErrorSchema\n}).strict();\n\nexport type RpcResponseWithError = z.infer<typeof RpcResponseWithErrorSchema>;\n\nexport const inferRpcResponseSchema = <T extends z.ZodTypeAny>(result: T) =>\n  RpcResponseWithErrorSchema.omit({error: true})\n    .merge(\n      z\n        .object({\n          result,\n          error: RpcResponseErrorSchema\n        })\n        .partial()\n    )\n    .strict()\n    .refine(\n      ({result, error}) => result !== undefined || error !== undefined,\n      'Either result or error should be provided.'\n    );\n\nexport const RpcResponseWithResultOrErrorSchema = inferRpcResponseSchema(z.any());\n", "import {DEFAULT_POLLING_INTERVAL_IN_MILLISECONDS} from '../constants/core.constants';\n\nexport const waitForMilliseconds = async (milliseconds: number): Promise<void> => {\n  await new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n};\n\nexport type ReadyOrError = 'ready' | 'error';\n\nexport const retryUntilReady = async ({\n  retries,\n  isReady,\n  fn,\n  intervalInMilliseconds = DEFAULT_POLLING_INTERVAL_IN_MILLISECONDS\n}: {\n  retries: number;\n  isReady: () => ReadyOrError | 'pending';\n  fn: () => void;\n  intervalInMilliseconds?: number;\n}): Promise<ReadyOrError | 'timeout'> => {\n  const ready = isReady();\n\n  if (ready !== 'pending') {\n    return ready;\n  }\n\n  const remainingRetries = retries - 1;\n\n  if (remainingRetries === 0) {\n    return 'timeout';\n  }\n\n  fn();\n\n  await waitForMilliseconds(intervalInMilliseconds);\n\n  return await retryUntilReady({retries: remainingRetries, intervalInMilliseconds, isReady, fn});\n};\n", "import {DEFAULT_POLLING_INTERVAL_IN_MILLISECONDS} from '../constants/core.constants';\nimport {\n  ICRC25_PERMISSIONS,\n  ICRC25_REQUEST_PERMISSIONS,\n  ICRC25_SUPPORTED_STANDARDS,\n  ICRC27_ACCOUNTS,\n  ICRC29_STATUS,\n  ICRC49_CALL_CANISTER\n} from '../constants/icrc.constants';\nimport type {\n  IcrcAccountsRequest,\n  IcrcAnyRequestedScopes,\n  IcrcCallCanisterRequest,\n  IcrcCallCanisterRequestParams,\n  IcrcPermissionsRequest,\n  IcrcRequestAnyPermissionsRequest,\n  IcrcStatusRequest,\n  IcrcSupportedStandardsRequest\n} from '../types/icrc-requests';\nimport type {Origin} from '../types/post-message';\nimport {JSON_RPC_VERSION_2, type RpcId} from '../types/rpc';\nimport {retryUntilReady, type ReadyOrError} from '../utils/timeout.utils';\n\ninterface Request {\n  id: RpcId;\n  popup: Window;\n  origin: Origin;\n}\n\ntype Response<T> = {msg: T} & Pick<Request, 'origin' | 'popup'>;\n\nexport const retryRequestStatus = async ({\n  popup,\n  id,\n  isReady,\n  timeoutInMilliseconds,\n  intervalInMilliseconds\n}: Omit<Request, 'origin'> & {\n  isReady: () => ReadyOrError | 'pending';\n  timeoutInMilliseconds: number;\n  intervalInMilliseconds?: number;\n}): Promise<ReadyOrError | 'timeout'> => {\n  const requestInitialStatus = (): void => {\n    const msg: IcrcStatusRequest = {\n      jsonrpc: JSON_RPC_VERSION_2,\n      id,\n      method: ICRC29_STATUS\n    };\n\n    // Since we are polling, we don't want to force the popup to the front in case the user has intentionally brought another window to the forefront.\n    postMsg({popup, msg, origin: '*'});\n  };\n\n  return await retryUntilReady({\n    retries:\n      timeoutInMilliseconds / (intervalInMilliseconds ?? DEFAULT_POLLING_INTERVAL_IN_MILLISECONDS),\n    intervalInMilliseconds,\n    isReady,\n    fn: requestInitialStatus\n  });\n};\n\nexport const requestStatus = ({id, ...rest}: Request): void => {\n  const msg: IcrcStatusRequest = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    method: ICRC29_STATUS\n  };\n\n  // Requesting status does not require user interaction therefore it can be queried without focusing the popup.\n  postMsg({msg, ...rest});\n};\n\nexport const requestSupportedStandards = ({id, ...rest}: Request): void => {\n  const msg: IcrcSupportedStandardsRequest = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    method: ICRC25_SUPPORTED_STANDARDS\n  };\n\n  // Requesting supported standards does not require user interaction therefore it can be queried without focusing the popup.\n  postMsg({msg, ...rest});\n};\n\nexport const permissions = ({id, ...rest}: Request): void => {\n  const msg: IcrcPermissionsRequest = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    method: ICRC25_PERMISSIONS\n  };\n\n  // Requesting the state of all permissions does not require user interaction therefore it can be queried without focusing the popup.\n  postMsg({msg, ...rest});\n};\n\nexport const requestPermissions = ({\n  id,\n  params,\n  ...rest\n}: Request & {params: IcrcAnyRequestedScopes}): void => {\n  const msg: IcrcRequestAnyPermissionsRequest = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    method: ICRC25_REQUEST_PERMISSIONS,\n    params\n  };\n\n  focusAndPostMsg({msg, ...rest});\n};\n\nexport const requestAccounts = ({id, ...rest}: Request): void => {\n  const msg: IcrcAccountsRequest = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    method: ICRC27_ACCOUNTS\n  };\n\n  focusAndPostMsg({msg, ...rest});\n};\n\nexport const requestCallCanister = ({\n  id,\n  params,\n  ...rest\n}: Request & {params: IcrcCallCanisterRequestParams}): void => {\n  const msg: IcrcCallCanisterRequest = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    method: ICRC49_CALL_CANISTER,\n    params\n  };\n\n  focusAndPostMsg({msg, ...rest});\n};\n\nconst focusAndPostMsg = <T>({popup, ...rest}: Response<T>): void => {\n  // We focus the popup to bring it to front.\n  popup.focus();\n\n  postMsg({popup, ...rest});\n};\n\nconst postMsg = <T>({popup, msg, origin}: Response<T>): void => {\n  popup.postMessage(msg, origin);\n};\n", "import {UrlSchema} from '@dfinity/zod-schemas';\nimport * as z from 'zod/v4';\nimport {IcrcBlobSchema} from './blob';\nimport {IcrcAccountsSchema} from './icrc-accounts';\nimport {\n  IcrcPermissionStateSchema,\n  IcrcScopedMethodSchema,\n  IcrcStandardSchema\n} from './icrc-standards';\nimport {inferRpcResponseSchema} from './rpc';\n\nconst IcrcScopeMethodSchema = z.object({\n  method: IcrcScopedMethodSchema\n});\n\nexport type IcrcScopeMethod = z.infer<typeof IcrcScopeMethodSchema>;\n\nexport const IcrcScopeSchema = z\n  .object({\n    scope: IcrcScopeMethodSchema,\n    state: IcrcPermissionStateSchema\n  })\n  .strict();\n\nexport type IcrcScope = z.infer<typeof IcrcScopeSchema>;\n\nexport const IcrcScopesArraySchema = z.array(IcrcScopeSchema);\n\nexport type IcrcScopesArray = z.infer<typeof IcrcScopesArraySchema>;\n\nexport const IcrcScopesSchema = z\n  .object({\n    scopes: IcrcScopesArraySchema\n  })\n  .strict();\n\nexport type IcrcScopes = z.infer<typeof IcrcScopesSchema>;\n\n// icrc25_request_permissions and icrc25_permissions\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_request_permissions\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_permissions\nexport const IcrcScopesResponseSchema = inferRpcResponseSchema(IcrcScopesSchema);\n\nexport type IcrcScopesResponse = z.infer<typeof IcrcScopesResponseSchema>;\n\n// icrc25_supported_standards\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_supported_standards\nconst urlRegex =\n  /^https:\\/\\/github\\.com\\/dfinity\\/ICRC\\/blob\\/main\\/ICRCs\\/ICRC-\\d+\\/ICRC-\\d+\\.md$/;\n\nconst SupportedStandardsUrlSchema = z\n  .url()\n  .regex(urlRegex)\n  .refine(\n    (url) => {\n      try {\n        UrlSchema.parse(url);\n      } catch (_err: unknown) {\n        return false;\n      }\n\n      const match = /(ICRC-\\d+)\\.md/g.exec(url);\n\n      if (match === null) {\n        return false;\n      }\n\n      const [_, icrc] = match;\n\n      return Object.keys(IcrcStandardSchema.enum).includes(icrc);\n    },\n    {\n      message: 'The URL does not match any of the IcrcStandard values.'\n    }\n  );\n\nexport const IcrcSupportedStandardsSchema = z\n  .array(\n    z\n      .object({\n        name: IcrcStandardSchema,\n        url: SupportedStandardsUrlSchema\n      })\n      .strict()\n  )\n  .min(1);\n\nexport type IcrcSupportedStandards = z.infer<typeof IcrcSupportedStandardsSchema>;\n\nexport const IcrcSupportedStandardsResponseSchema = inferRpcResponseSchema(\n  z.object({\n    supportedStandards: IcrcSupportedStandardsSchema\n  })\n);\n\nexport type IcrcSupportedStandardsResponse = z.infer<typeof IcrcSupportedStandardsResponseSchema>;\n\n// icrc29_status\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_29_window_post_message_transport.md\n\nexport const IcrcReadyResponseSchema = inferRpcResponseSchema(z.literal('ready'));\n\nexport type IcrcReadyResponse = z.infer<typeof IcrcReadyResponseSchema>;\n\n// icrc27_accounts\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_27_accounts.md#icrc-27-get-accounts\n\nexport const IcrcAccountsResponseSchema = inferRpcResponseSchema(\n  z.object({\n    accounts: IcrcAccountsSchema\n  })\n);\n\nexport type IcrcAccountsResponse = z.infer<typeof IcrcAccountsResponseSchema>;\n\n// icrc49_call_canister\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_49_call_canister.md\n\nexport const IcrcCallCanisterResultSchema = z\n  .object({\n    contentMap: IcrcBlobSchema,\n    certificate: IcrcBlobSchema\n  })\n  .strict();\n\nexport type IcrcCallCanisterResult = z.infer<typeof IcrcCallCanisterResultSchema>;\n\nexport const IcrcCallCanisterResponseSchema = inferRpcResponseSchema(\n  IcrcCallCanisterResultSchema.strict()\n);\n\nexport type IcrcCallCanisterResponse = z.infer<typeof IcrcCallCanisterResponseSchema>;\n", "import * as z from 'zod/v4';\n\nexport const IcrcBlobSchema = z.string().refine(\n  (val) => {\n    try {\n      return btoa(atob(val)) === val;\n    } catch (_err: unknown) {\n      return false;\n    }\n  },\n  {\n    message: 'Invalid base64 string'\n  }\n);\n\nexport type IcrcBlob = z.infer<typeof IcrcBlobSchema>;\n", "import {base64ToUint8Array} from '@dfinity/utils';\nimport {PrincipalTextSchema} from '@dfinity/zod-schemas';\nimport * as z from 'zod/v4';\nimport {IcrcBlobSchema} from './blob';\n\nconst IcrcSubaccountSchema = IcrcBlobSchema.refine(\n  (value) => {\n    try {\n      return base64ToUint8Array(value).length === 32;\n    } catch (_err: unknown) {\n      return false;\n    }\n  },\n  {\n    message: 'Subaccount must be exactly 32 bytes long.'\n  }\n);\n\nexport const IcrcAccountSchema = z\n  .object({\n    owner: PrincipalTextSchema,\n    subaccount: IcrcSubaccountSchema.optional()\n  })\n  .strict();\n\nexport type IcrcAccount = z.infer<typeof IcrcAccountSchema>;\n\nexport const IcrcAccountsSchema = z.array(IcrcAccountSchema).min(1);\n\nexport type IcrcAccounts = z.infer<typeof IcrcAccountsSchema>;\n", "import type {RpcResponseError, RpcResponseErrorCode} from './rpc';\n\nexport class RelyingPartyResponseError extends Error {\n  code: RpcResponseErrorCode;\n\n  constructor({message, code}: RpcResponseError) {\n    super(message);\n\n    this.code = code;\n  }\n}\n\nexport class RelyingPartyDisconnectedError extends Error {}\n", "import {UrlSchema} from '@dfinity/zod-schemas';\nimport * as z from 'zod/v4';\nimport {createFunctionSchema} from '../utils/zod.utils';\n\nconst ConnectionOptionsSchema = z.object({\n  /**\n   * Specifies the interval in milliseconds at which the signer is checked (polled) to determine if it is ready.\n   * Must be a positive number.\n   *\n   * @default 500 - The default polling interval is set to 500 milliseconds.\n   */\n  pollingIntervalInMilliseconds: z.number().positive().optional(),\n\n  /**\n   * Specifies the maximum duration in milliseconds for attempting to establish a connection to the signer.\n   * If the connection is not established within this duration, the process will time out.\n   * Must be a positive number.\n   *\n   * @default 120_000 - The default timeout is set to 120,000 milliseconds (2 minutes).\n   */\n  timeoutInMilliseconds: z.number().positive().optional()\n});\n\nexport type ConnectionOptions = z.infer<typeof ConnectionOptionsSchema>;\n\nconst WindowOptionsSchema = z.object({\n  /**\n   * Specifies the position of the signer window.\n   */\n  position: z.enum(['top-right', 'center']),\n\n  /**\n   * Specifies a width greater than zero of the signer window.\n   */\n  width: z.number().positive(),\n\n  /**\n   * Specifies a height greater than zero of the signer window.\n   */\n  height: z.number().positive(),\n\n  /**\n   * Optional features for the signer Window object.\n   */\n  features: z.string().optional()\n});\n\nexport type WindowOptions = z.infer<typeof WindowOptionsSchema>;\n\nconst OnDisconnectSchema = createFunctionSchema(z.function({output: z.void()})).optional();\n\nexport type OnDisconnect = z.infer<typeof OnDisconnectSchema>;\n\nconst RelyingPartyHostSchema = UrlSchema.optional();\n\nexport type RelyingPartyHost = z.infer<typeof RelyingPartyHostSchema>;\n\nexport const RelyingPartyOptionsSchema = z.object({\n  /**\n   * The URL of the signer.\n   */\n  url: UrlSchema,\n\n  /**\n   * Optional window options to display the signer, which can be an object of type WindowOptions or a string.\n   * If a string is passed, those are applied as-is to the window that is opened (see https://developer.mozilla.org/en-US/docs/Web/API/Window/open#windowfeatures for more information).\n   */\n  windowOptions: z.union([WindowOptionsSchema, z.string()]).optional(),\n\n  /**\n   * The connection options for establishing the connection with the signer.\n   */\n  connectionOptions: ConnectionOptionsSchema.optional(),\n\n  /**\n   * Optional callback function that is triggered when the relying party disconnects from the wallet.\n   */\n  onDisconnect: OnDisconnectSchema,\n\n  /**\n   * The host of the replica to which the relying party wallet might be connected.\n   * This is useful for local development if your local replica runs on a port other than the default, as an agent must be created to decode the response.\n   * If \"localhost\" or \"127.0.0.1\" is provided, it will automatically connect to a local replica and fetch the root key for the agent.\n   */\n  host: RelyingPartyHostSchema\n});\n\nexport type RelyingPartyOptions = z.infer<typeof RelyingPartyOptionsSchema>;\n", "import * as z from 'zod/v4';\n\n/**\n * In Zod v4, functions are no longer treated as standard Zod schemas (see: https://zod.dev/v4/changelog?id=zfunction).\n * Since this library uses functions as schemas, we need a workaround to parse them.\n * This utility provides that workaround, following the approach recommended\n * in the Zod migration guide:\n * https://github.com/colinhacks/zod/issues/4143#issuecomment-2845134912\n *\n * Note: The downside of this workaround is that using `safeParse` to validate a function schema\n * will throw an error instead of returning a success or failure result. However, since our implementation\n * exclusively uses `parse`, this utility is acceptable for our use case.\n */\nexport const createFunctionSchema = <T extends z.core.$ZodFunction>(schema: T) =>\n  z.custom<Parameters<T['implement']>[0]>((fn) =>\n    schema.implement(fn as Parameters<T['implement']>[0])\n  );\n", "import * as z from 'zod/v4';\nimport {RpcIdSchema} from './rpc';\n\nexport const RelyingPartyRequestOptionsTimeoutSchema = z.object({\n  /**\n   * Specifies the maximum duration in milliseconds for attempting to request an interaction with the relying party.\n   * If the relying party does not answer within this duration, the process will time out.\n   * Must be a positive number.\n   */\n  timeoutInMilliseconds: z.number().positive()\n});\n\nexport const RelyingPartyRequestOptionsSchema = z\n  .object({\n    /**\n     * A custom identifier for the request, used to correlate responses with their corresponding requests.\n     *\n     * The relying party is expected to include this ID in its response, ensuring that the response can be accurately matched to the original request.\n     *\n     * If not provided, the library will generate a unique identifier automatically.\n     */\n    requestId: RpcIdSchema.optional()\n  })\n  .merge(RelyingPartyRequestOptionsTimeoutSchema.partial());\n\nexport type RelyingPartyRequestOptions = z.infer<typeof RelyingPartyRequestOptionsSchema>;\n\nexport const RelyingPartyRequestOptionsWithTimeoutSchema = RelyingPartyRequestOptionsSchema.omit({\n  timeoutInMilliseconds: true\n}).merge(RelyingPartyRequestOptionsTimeoutSchema);\n\nexport type RelyingPartyRequestOptionsWithTimeout = z.infer<\n  typeof RelyingPartyRequestOptionsWithTimeoutSchema\n>;\n", "import {\n  AnonymousIdentity,\n  Certificate,\n  HttpAgent,\n  lookupResultToBuffer,\n  requestIdOf,\n  uint8ToBuf\n} from '@dfinity/agent';\nimport type {RecordClass, VariantClass} from '@dfinity/candid/lib/cjs/idl';\nimport {Principal} from '@dfinity/principal';\nimport {assertNonNullish, base64ToUint8Array} from '@dfinity/utils';\nimport {LOCAL_REPLICA_URL, MAINNET_REPLICA_URL} from '../constants/core.constants';\nimport type {IcrcCallCanisterRequestParams} from '../types/icrc-requests';\nimport type {IcrcCallCanisterResult} from '../types/icrc-responses';\nimport type {RelyingPartyHost} from '../types/relying-party-options';\nimport {decodeCallRequest} from './agentjs-cbor-copy.utils';\nimport {\n  assertCallArg,\n  assertCallCanisterId,\n  assertCallMethod,\n  assertCallSender\n} from './call.assert.utils';\nimport {decodeIdl} from './idl.utils';\n\nexport const assertCallResponse = ({\n  params: {method, arg, canisterId, sender},\n  result: {contentMap}\n}: {\n  params: IcrcCallCanisterRequestParams;\n  result: IcrcCallCanisterResult;\n}) => {\n  const callRequest = decodeCallRequest(contentMap);\n\n  assertCallCanisterId({\n    requestCanisterId: Principal.fromText(canisterId),\n    responseCanisterId: callRequest.canister_id\n  });\n\n  assertCallMethod({\n    requestMethod: method,\n    responseMethod: callRequest.method_name\n  });\n\n  assertCallArg({\n    requestArg: arg,\n    responseArg: callRequest.arg\n  });\n\n  assertCallSender({\n    requestSender: sender,\n    responseSender: callRequest.sender\n  });\n};\n\nexport const decodeResponse = async <T>({\n  params: {canisterId},\n  result: {certificate: cert, contentMap},\n  resultRecordClass,\n  host\n}: {\n  params: IcrcCallCanisterRequestParams;\n  result: IcrcCallCanisterResult;\n  resultRecordClass: RecordClass | VariantClass;\n  host?: RelyingPartyHost;\n}): Promise<T> => {\n  // TODO: improve performance by avoiding the need to decode the call requests multiple times. For example. IcpWallet and IcrcWallet could use a new protected function of RelyingParty that would extend call and return the callRequest that is asserted.\n  const callRequest = decodeCallRequest(contentMap);\n\n  // We have to create an agent to retrieve the rootKey, which is both inefficient and a bit ugly to some extension.\n  const {\n    location: {hostname}\n  } = window;\n\n  const localhost = ['localhost', '127.0.0.1'].includes(hostname);\n\n  const agent = await HttpAgent.create({\n    identity: new AnonymousIdentity(),\n    host: localhost ? (host ?? LOCAL_REPLICA_URL) : MAINNET_REPLICA_URL,\n    ...(localhost && {shouldFetchRootKey: true})\n  });\n\n  assertNonNullish(\n    agent.rootKey,\n    'Missing agent root key, which is required to certify the response.'\n  );\n\n  const certificate = await Certificate.create({\n    certificate: uint8ToBuf(base64ToUint8Array(cert)),\n    rootKey: agent.rootKey,\n    canisterId: Principal.fromText(canisterId)\n  });\n\n  const requestId = requestIdOf(callRequest);\n\n  const path = [uint8ToBuf(new TextEncoder().encode('request_status')), requestId];\n\n  const reply = lookupResultToBuffer(certificate.lookup([...path, 'reply']));\n\n  // TODO: Instead of blindly throwing a general exception we can read the rejection and provide an error that contains details such as reject_message, error_code and reject_code.\n  assertNonNullish(\n    reply,\n    'A reply cannot be resolved within the provided certificate. This is unexpected; it should have been known at this point.'\n  );\n\n  return decodeIdl<T>({\n    recordClass: resultRecordClass,\n    bytes: reply\n  });\n};\n", "import {type CallRequest, type Expiry, uint8ToBuf} from '@dfinity/agent';\nimport {Principal} from '@dfinity/principal';\nimport {base64ToUint8Array} from '@dfinity/utils';\nimport type {BigNumber} from 'bignumber.js';\nimport {decode} from '../agent/agentjs-cbor-copy';\nimport type {IcrcBlob} from '../types/blob';\n\nexport const decodeCallRequest = (contentMap: IcrcBlob): CallRequest => {\n  type CborCallRequest = Omit<CallRequest, 'ingress_expiry' | 'canister_id'> & {\n    ingress_expiry: BigNumber;\n    canister_id: Uint8Array;\n  };\n\n  // The decode function copied from agent-js is buggy or does not support decoding the ingress_expiry to BigInt or Expiry. It seems that the value is a BigNumber. That's why we have to strip it from the response and convert it manually.\n  // It does not parse Principal neither.\n  const {ingress_expiry, canister_id, ...callRequestRest} = decode<CborCallRequest>(\n    uint8ToBuf(base64ToUint8Array(contentMap))\n  );\n\n  return {\n    ...callRequestRest,\n    canister_id: Principal.fromUint8Array(canister_id),\n    // There is no constructor or setter to create an agent-js Expiry from a bigint. Type which is expected by CallRequest. Given that we solely require the wrapped BigInt in this function, we can resolve the issue with an ugly cast.\n    ingress_expiry: BigInt(ingress_expiry.toFixed()) as unknown as Expiry\n  } as CallRequest;\n};\n", "/* eslint-disable */\n\n/**\n * \u26A0\uFE0F !!!WARNING!!! \u26A0\uFE0F\n * This module is a copy/paste of the CBOR module, which is not exposed by Agent-js.\n * It is not covered by any tests (\u203C\uFE0F) in this library and contain multiple issues (\u203C\uFE0F) based on ESLint results.\n */\n\n// This file is based on:\n// https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses\nimport {concat, fromHex, toHex, uint8ToBuf} from '@dfinity/agent';\nimport {Principal} from '@dfinity/principal';\nimport borc from 'borc';\nimport * as cbor from 'simple-cbor';\nimport {CborEncoder, SelfDescribeCborSerializer} from 'simple-cbor';\n\n// We are using hansl/simple-cbor for CBOR serialization, to avoid issues with\n// encoding the uint64 values that the HTTP handler of the client expects for\n// canister IDs. However, simple-cbor does not yet provide deserialization so\n// we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR\n// decoder.\n\nclass PrincipalEncoder implements CborEncoder<Principal> {\n  public get name() {\n    return 'Principal';\n  }\n\n  public get priority() {\n    return 0;\n  }\n\n  public match(value: any): boolean {\n    return value && value._isPrincipal === true;\n  }\n\n  public encode(v: Principal): cbor.CborValue {\n    return cbor.value.bytes(uint8ToBuf(v.toUint8Array()));\n  }\n}\n\nclass BufferEncoder implements CborEncoder<ArrayBuffer> {\n  public get name() {\n    return 'Buffer';\n  }\n\n  public get priority() {\n    return 1;\n  }\n\n  public match(value: any): boolean {\n    return value instanceof ArrayBuffer || ArrayBuffer.isView(value);\n  }\n\n  public encode(v: ArrayBuffer): cbor.CborValue {\n    return cbor.value.bytes(v);\n  }\n}\n\nclass BigIntEncoder implements CborEncoder<BigInt> {\n  public get name() {\n    return 'BigInt';\n  }\n\n  public get priority() {\n    return 1;\n  }\n\n  public match(value: any): boolean {\n    return typeof value === `bigint`;\n  }\n\n  public encode(v: bigint): cbor.CborValue {\n    // Always use a bigint encoding.\n    if (v > BigInt(0)) {\n      return cbor.value.tagged(2, cbor.value.bytes(fromHex(v.toString(16))));\n    } else {\n      return cbor.value.tagged(3, cbor.value.bytes(fromHex((BigInt('-1') * v).toString(16))));\n    }\n  }\n}\n\nconst serializer = SelfDescribeCborSerializer.withDefaultEncoders(true);\nserializer.addEncoder(new PrincipalEncoder());\nserializer.addEncoder(new BufferEncoder());\nserializer.addEncoder(new BigIntEncoder());\n\nexport enum CborTag {\n  Uint64LittleEndian = 71,\n  Semantic = 55799\n}\n\n/**\n * Encode a JavaScript value into CBOR.\n */\nexport function encode(value: any): ArrayBuffer {\n  return serializer.serialize(value);\n}\n\nfunction decodePositiveBigInt(buf: Uint8Array): bigint {\n  const len = buf.byteLength;\n  let res = BigInt(0);\n  for (let i = 0; i < len; i++) {\n    res = res * BigInt(0x100) + BigInt(buf[i]);\n  }\n\n  return res;\n}\n\n// A BORC subclass that decodes byte strings to ArrayBuffer instead of the Buffer class.\nclass Uint8ArrayDecoder extends borc.Decoder {\n  public createByteString(raw: ArrayBuffer[]): ArrayBuffer {\n    return concat(...raw);\n  }\n\n  public createByteStringFromHeap(start: number, end: number): ArrayBuffer {\n    if (start === end) {\n      return new ArrayBuffer(0);\n    }\n\n    // @ts-ignore TS2740: Type Uint8Array<any> is missing the following properties from type ArrayBuffer\n    return new Uint8Array((this as any)._heap.slice(start, end));\n  }\n}\n\nexport function decode<T>(input: ArrayBuffer): T {\n  const buffer = new Uint8Array(input);\n  const decoder = new Uint8ArrayDecoder({\n    size: buffer.byteLength,\n    tags: {\n      // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).\n      2: (val) => decodePositiveBigInt(val),\n      3: (val) => -decodePositiveBigInt(val),\n      [CborTag.Semantic]: (value: T): T => value\n    }\n  });\n\n  try {\n    // @ts-ignore incorrect types - Uint8Array excepted by decodeFirst\n    return decoder.decodeFirst(buffer);\n  } catch (e: unknown) {\n    throw new Error(`Failed to decode CBOR: ${e}, input: ${toHex(uint8ToBuf(buffer))}`);\n  }\n}\n", "import {Principal} from '@dfinity/principal';\nimport {arrayBufferToUint8Array, base64ToUint8Array} from '@dfinity/utils';\nimport type {PrincipalText} from '@dfinity/zod-schemas';\nimport type {IcrcBlob} from '../types/blob';\nimport type {Method} from '../types/icrc-requests';\n\nexport const assertCallMethod = ({\n  requestMethod,\n  responseMethod\n}: {\n  responseMethod: string;\n  requestMethod: Method;\n}) => {\n  if (responseMethod !== requestMethod) {\n    throw new Error('The response method does not match the request method.');\n  }\n};\n\nexport const assertCallArg = ({\n  responseArg,\n  requestArg: requestArgBlob\n}: {\n  responseArg: ArrayBuffer;\n  requestArg: IcrcBlob;\n}) => {\n  const requestArg = base64ToUint8Array(requestArgBlob);\n  const callRequestArg = arrayBufferToUint8Array(responseArg);\n\n  const uint8ArrayEqual = ({first, second}: {first: Uint8Array; second: Uint8Array}): boolean =>\n    first.length === second.length && first.every((value, index) => value === second[index]);\n\n  if (!uint8ArrayEqual({first: requestArg, second: callRequestArg})) {\n    throw new Error('The response does not contain the request arguments.');\n  }\n};\n\nexport const assertCallCanisterId = ({\n  requestCanisterId,\n  responseCanisterId\n}: {\n  responseCanisterId: Principal;\n  requestCanisterId: Principal;\n}) => {\n  if (requestCanisterId.toText() !== responseCanisterId.toText()) {\n    throw new Error('The response canister ID does not match the requested canister ID.');\n  }\n};\n\nexport const assertCallSender = ({\n  requestSender,\n  responseSender\n}: {\n  responseSender: Uint8Array | Principal;\n  requestSender: PrincipalText;\n}) => {\n  const receivedSender =\n    responseSender instanceof Uint8Array\n      ? Principal.fromUint8Array(responseSender)\n      : responseSender;\n\n  if (receivedSender.toText() !== Principal.fromText(requestSender).toText()) {\n    throw new Error('The response sender does not match the request sender.');\n  }\n};\n", "import {IDL} from '@dfinity/candid';\nimport type {RecordClass, VariantClass} from '@dfinity/candid/lib/cjs/idl';\nimport {uint8ArrayToBase64} from '@dfinity/utils';\nimport type {IcrcBlob} from '../types/blob';\n\nexport const encodeIdl = <T>({\n  recordClass,\n  rawArgs\n}: {\n  recordClass: RecordClass | VariantClass;\n  rawArgs: T;\n}): IcrcBlob => uint8ArrayToBase64(new Uint8Array(IDL.encode([recordClass], [rawArgs])));\n\nexport const decodeIdl = <T>({\n  recordClass,\n  bytes\n}: {\n  recordClass: RecordClass | VariantClass;\n  bytes: ArrayBuffer;\n}): T => {\n  const result = IDL.decode([recordClass], bytes);\n\n  if (result.length !== 1) {\n    throw new Error('More than one object returned. This is unexpected.');\n  }\n\n  // We have to use another ugly type cast because IDL.decode does not accept generics. Additionally, the agent-js implementation does not provide any hints, as its decodeReturnValue relies on the type 'any,' which is bad practice.\n  const [response] = result as unknown as [T];\n  return response;\n};\n", "import {isNullish} from '@dfinity/utils';\nimport {DEFAULT_SIGNER_WINDOW_FEATURES} from '../constants/window.constants';\nimport type {WindowOptions} from '../types/relying-party-options';\nimport {isBrowser} from './env.utils';\n\nexport const windowFeatures = ({position, ...rest}: WindowOptions): string | undefined => {\n  const fn = position === 'center' ? windowCenter : windowTopRight;\n  return fn(rest);\n};\n\nconst windowCenter = ({\n  width,\n  height,\n  features = DEFAULT_SIGNER_WINDOW_FEATURES\n}: Omit<WindowOptions, 'position'>): string | undefined => {\n  if (!isBrowser()) {\n    return undefined;\n  }\n\n  if (isNullish(window) || isNullish(window.top)) {\n    return undefined;\n  }\n\n  const {\n    top: {innerWidth, innerHeight}\n  } = window;\n\n  const y = innerHeight / 2 + screenY - height / 2;\n  const x = innerWidth / 2 + screenX - width / 2;\n\n  return `${features}, width=${width}, height=${height}, top=${y}, left=${x}`;\n};\n\nconst windowTopRight = ({\n  width,\n  height,\n  features = DEFAULT_SIGNER_WINDOW_FEATURES\n}: Omit<WindowOptions, 'position'>): string | undefined => {\n  if (!isBrowser()) {\n    return undefined;\n  }\n\n  if (isNullish(window) || isNullish(window.top)) {\n    return undefined;\n  }\n\n  const {\n    top: {innerWidth, innerHeight}\n  } = window;\n\n  const y = outerHeight - innerHeight;\n  const x = innerWidth - width;\n\n  return `${features}, width=${width}, height=${height}, top=${y}, left=${x}`;\n};\n", "/**\n * Checks if the current environment is a browser.\n * @returns {boolean} True if the current environment is a browser, false otherwise.\n */\nexport const isBrowser = (): boolean => typeof window !== `undefined`;\n"],
  "mappings": "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",
  "names": ["mapIcrc1TransferError", "mapIcrc2ApproveError", "toIcrc1TransferRawRequest", "toIcrc2ApproveRawRequest", "IDL", "Subaccount", "Account", "Timestamp", "TransferArgs", "TransferError", "TransferResult", "IDL", "Account", "ApproveArgs", "TransferFromArgs", "ApproveError", "TransferFromError", "ApproveResult", "TransferFromResult", "assertNonNullish", "nonNullish", "notEmptyString", "ICRC21_CALL_CONSENT_MESSAGE", "ICRC25_REQUEST_PERMISSIONS", "ICRC25_PERMISSIONS", "ICRC25_SUPPORTED_STANDARDS", "ICRC27_ACCOUNTS", "ICRC29_STATUS", "ICRC49_CALL_CANISTER", "ICRC25_PERMISSION_GRANTED", "ICRC25_PERMISSION_DENIED", "ICRC25_PERMISSION_ASK_ON_USE", "ICRC21", "ICRC25", "ICRC27", "ICRC29", "ICRC49", "z", "IcrcMethodSchema", "ICRC21_CALL_CONSENT_MESSAGE", "ICRC25_REQUEST_PERMISSIONS", "ICRC25_PERMISSIONS", "ICRC25_SUPPORTED_STANDARDS", "ICRC27_ACCOUNTS", "ICRC29_STATUS", "ICRC49_CALL_CANISTER", "IcrcScopedMethodSchema", "IcrcPermissionStateSchema", "ICRC25_PERMISSION_GRANTED", "ICRC25_PERMISSION_DENIED", "ICRC25_PERMISSION_ASK_ON_USE", "IcrcStandardSchema", "ICRC21", "ICRC25", "ICRC27", "ICRC29", "ICRC49", "RELYING_PARTY_CHECK_WALLET_STATUS_INTERVAL", "RELYING_PARTY_TIMEOUT_IN_MILLISECONDS_WITH_USER_INTERACTION", "RELYING_PARTY_TIMEOUT_IN_MILLISECONDS_WITHOUT_USER_INTERACTION", "RELYING_PARTY_CONNECT_TIMEOUT_IN_MILLISECONDS", "RELYING_PARTY_TIMEOUT_REQUEST_SUPPORTED_STANDARD", "RELYING_PARTY_TIMEOUT_REQUEST_PERMISSIONS", "RELYING_PARTY_TIMEOUT_PERMISSIONS", "RELYING_PARTY_TIMEOUT_ACCOUNTS", "RELYING_PARTY_TIMEOUT_CALL_CANISTER", "RELYING_PARTY_TIMEOUT_REQUEST_STATUS", "RELYING_PARTY_DEFAULT_SCOPES", "IcrcScopedMethodSchema", "method", "DEFAULT_SIGNER_WINDOW_FEATURES", "DEFAULT_SIGNER_WINDOW_SIZE", "DEFAULT_SIGNER_WINDOW_TOP_RIGHT", "DEFAULT_SIGNER_WINDOW_CENTER", "LOCAL_REPLICA_URL", "MAINNET_REPLICA_URL", "z", "JSON_RPC_VERSION_2", "JsonRpcSchema", "RpcIdSchema", "RpcSchema", "RpcRequestSchema", "RpcNotificationSchema", "RpcRequestSchema", "RpcErrorCode", "RpcResponseErrorCodeSchema", "RpcResponseErrorSchema", "RpcResponseSchema", "RpcSchema", "RpcIdSchema", "RpcResponseWithErrorSchema", "inferRpcResponseSchema", "result", "error", "RpcResponseWithResultOrErrorSchema", "waitForMilliseconds", "milliseconds", "resolve", "retryUntilReady", "retries", "isReady", "fn", "intervalInMilliseconds", "ready", "remainingRetries", "retryRequestStatus", "popup", "id", "isReady", "timeoutInMilliseconds", "intervalInMilliseconds", "requestInitialStatus", "postMsg", "JSON_RPC_VERSION_2", "ICRC29_STATUS", "retryUntilReady", "requestStatus", "rest", "requestSupportedStandards", "ICRC25_SUPPORTED_STANDARDS", "permissions", "ICRC25_PERMISSIONS", "requestPermissions", "params", "focusAndPostMsg", "ICRC25_REQUEST_PERMISSIONS", "requestAccounts", "ICRC27_ACCOUNTS", "requestCallCanister", "ICRC49_CALL_CANISTER", "msg", "origin", "UrlSchema", "z", "z", "IcrcBlobSchema", "val", "base64ToUint8Array", "PrincipalTextSchema", "z", "IcrcSubaccountSchema", "IcrcBlobSchema", "value", "base64ToUint8Array", "IcrcAccountSchema", "PrincipalTextSchema", "IcrcAccountsSchema", "IcrcScopeMethodSchema", "IcrcScopedMethodSchema", "IcrcScopeSchema", "IcrcPermissionStateSchema", "IcrcScopesArraySchema", "IcrcScopesSchema", "IcrcScopesResponseSchema", "inferRpcResponseSchema", "urlRegex", "SupportedStandardsUrlSchema", "url", "UrlSchema", "match", "_", "icrc", "IcrcStandardSchema", "IcrcSupportedStandardsSchema", "IcrcSupportedStandardsResponseSchema", "IcrcReadyResponseSchema", "IcrcAccountsResponseSchema", "IcrcAccountsSchema", "IcrcCallCanisterResultSchema", "IcrcBlobSchema", "IcrcCallCanisterResponseSchema", "RelyingPartyResponseError", "message", "code", "RelyingPartyDisconnectedError", "UrlSchema", "z", "z", "createFunctionSchema", "schema", "fn", "ConnectionOptionsSchema", "WindowOptionsSchema", "OnDisconnectSchema", "createFunctionSchema", "RelyingPartyHostSchema", "UrlSchema", "RelyingPartyOptionsSchema", "RelyingPartyRequestOptionsTimeoutSchema", "RelyingPartyRequestOptionsSchema", "RpcIdSchema", "RelyingPartyRequestOptionsWithTimeoutSchema", "AnonymousIdentity", "Certificate", "HttpAgent", "lookupResultToBuffer", "requestIdOf", "uint8ToBuf", "Principal", "assertNonNullish", "base64ToUint8Array", "uint8ToBuf", "Principal", "base64ToUint8Array", "concat", "fromHex", "toHex", "uint8ToBuf", "borc", "cbor", "SelfDescribeCborSerializer", "PrincipalEncoder", "value", "v", "BufferEncoder", "BigIntEncoder", "serializer", "decodePositiveBigInt", "buf", "len", "res", "i", "Uint8ArrayDecoder", "borc", "raw", "concat", "start", "end", "decode", "input", "buffer", "decoder", "val", "value", "e", "toHex", "uint8ToBuf", "decodeCallRequest", "contentMap", "ingress_expiry", "canister_id", "callRequestRest", "decode", "uint8ToBuf", "base64ToUint8Array", "Principal", "Principal", "arrayBufferToUint8Array", "base64ToUint8Array", "assertCallMethod", "requestMethod", "responseMethod", "assertCallArg", "responseArg", "requestArgBlob", "requestArg", "callRequestArg", "first", "second", "value", "index", "assertCallCanisterId", "requestCanisterId", "responseCanisterId", "assertCallSender", "requestSender", "responseSender", "IDL", "uint8ArrayToBase64", "encodeIdl", "recordClass", "rawArgs", "decodeIdl", "bytes", "result", "response", "assertCallResponse", "method", "arg", "canisterId", "sender", "contentMap", "callRequest", "decodeCallRequest", "assertCallCanisterId", "Principal", "assertCallMethod", "assertCallArg", "assertCallSender", "decodeResponse", "cert", "resultRecordClass", "host", "hostname", "localhost", "agent", "HttpAgent", "AnonymousIdentity", "LOCAL_REPLICA_URL", "MAINNET_REPLICA_URL", "assertNonNullish", "certificate", "Certificate", "uint8ToBuf", "base64ToUint8Array", "requestId", "requestIdOf", "path", "reply", "lookupResultToBuffer", "decodeIdl", "isNullish", "isBrowser", "windowFeatures", "position", "rest", "windowCenter", "windowTopRight", "width", "height", "features", "DEFAULT_SIGNER_WINDOW_FEATURES", "isBrowser", "isNullish", "innerWidth", "innerHeight", "y", "x", "RelyingParty", "_RelyingParty", "#origin", "#popup", "#onDisconnect", "#walletStatus", "#walletStatusInterval", "origin", "popup", "onDisconnect", "host", "RELYING_PARTY_CHECK_WALLET_STATUS_INTERVAL", "rest", "params", "options", "init", "optionsSuccess", "error", "RelyingPartyOptionsSchema", "url", "windowOptions", "connectionOptions", "popupFeatures", "windowFeatures", "DEFAULT_SIGNER_WINDOW_TOP_RIGHT", "assertNonNullish", "close", "MessageError", "response", "onMessage", "msgData", "success", "RpcResponseWithResultOrErrorSchema", "expectedOrigin", "relyingPartyOrigin", "notEmptyString", "isWalletReady", "IcrcReadyResponseSchema", "disconnect", "connect", "retryRequestStatus", "nonNullish", "RELYING_PARTY_CONNECT_TIMEOUT_IN_MILLISECONDS", "err", "handleMessage", "data", "id", "walletReadyData", "postRequest", "requestStatus", "checkWalletStatus", "RELYING_PARTY_TIMEOUT_REQUEST_STATUS", "resolve", "reject", "connected", "RelyingPartyRequestOptionsSchema", "userRequestId", "timeoutInMilliseconds", "requestId", "timeoutId", "source", "handled", "result", "checkError", "RelyingPartyDisconnectedError", "isSupportedStandards", "supportedStandardsData", "IcrcSupportedStandardsResponseSchema", "requestSupportedStandards", "RELYING_PARTY_TIMEOUT_REQUEST_SUPPORTED_STANDARD", "permissions", "RELYING_PARTY_TIMEOUT_PERMISSIONS", "requestPermissions", "RELYING_PARTY_DEFAULT_SCOPES", "RELYING_PARTY_TIMEOUT_REQUEST_PERMISSIONS", "isRequestPermissions", "requestPermissionsData", "IcrcScopesResponseSchema", "scopes", "isAccounts", "accountsData", "IcrcAccountsResponseSchema", "requestAccounts", "RELYING_PARTY_TIMEOUT_ACCOUNTS", "isCallCanister", "resultData", "IcrcCallCanisterResponseSchema", "requestCallCanister", "RELYING_PARTY_TIMEOUT_CALL_CANISTER", "assertCallResponse", "isError", "errorData", "RpcResponseWithErrorSchema", "RelyingPartyResponseError", "findNotGranted", "state", "ICRC25_PERMISSION_GRANTED", "scope", "notGrantedScopes", "ICP_LEDGER_CANISTER_ID", "IcpWallet", "_IcpWallet", "RelyingParty", "onDisconnect", "host", "rest", "params", "request", "owner", "ledgerCanisterId", "options", "rawArgs", "toIcrc1TransferRawRequest", "arg", "encodeIdl", "TransferArgs", "callParams", "callResult", "response", "decodeResponse", "TransferResult", "mapIcrc1TransferError", "toIcrc2ApproveRawRequest", "ApproveArgs", "ApproveResult", "mapIcrc2ApproveError"]
}
