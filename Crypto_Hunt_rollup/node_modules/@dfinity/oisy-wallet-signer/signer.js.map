{
  "version": 3,
  "sources": ["../src/i18n/en.json", "../src/signer.ts", "../src/constants/icrc.constants.ts", "../src/types/icrc-standards.ts", "../src/constants/signer.constants.ts", "../src/types/rpc.ts", "../src/handlers/signer.handlers.ts", "../src/handlers/signer-errors.handlers.ts", "../src/handlers/signer-success.handlers.ts", "../src/services/signer.service.ts", "../src/api/signer.api.ts", "../src/agent/agentjs-cbor-copy.ts", "../src/api/icrc21-canister.api.ts", "../src/declarations/icrc-21.idl.js", "../src/api/agent.api.ts", "../src/agent/custom-http-agent.ts", "../src/agent/custom-transform-agent.ts", "../src/agent/http-agent-provider.ts", "../src/constants/core.constants.ts", "../src/builders/signer.builders.ts", "../src/constants/icrc-1.idl.constants.ts", "../src/constants/icrc-2.idl.constants.ts", "../src/utils/builders.utils.ts", "../src/utils/format.utils.ts", "../src/utils/idl.utils.ts", "../src/constants/signer.builders.constants.ts", "../src/utils/icrc-21.utils.ts", "../src/sessions/signer.sessions.ts", "../src/utils/storage.utils.ts", "../src/types/icrc-requests.ts", "../src/types/blob.ts", "../src/types/signer-errors.ts", "../src/types/signer-prompts.ts", "../src/utils/zod.utils.ts", "../src/types/icrc-accounts.ts", "../src/types/icrc-responses.ts", "../src/types/post-message.ts"],
  "sourcesContent": ["{\n  \"core\": {\n    \"amount\": \"Amount\",\n    \"from\": \"From\",\n    \"to\": \"To\",\n    \"fee\": \"Fee\",\n    \"memo\": \"Memo\"\n  },\n  \"icrc1_transfer\": {\n    \"title\": \"Approve the transfer of funds\"\n  },\n  \"icrc2_approve\": {\n    \"title\": \"Authorize another address to withdraw from your account\",\n    \"address_is_allowed\": \"The following address is allowed to withdraw from your account\",\n    \"your_account\": \"Your account\",\n    \"requested_withdrawal_allowance\": \"Requested withdrawal allowance\",\n    \"withdrawal_allowance\": {\n      \"some\": \"Current withdrawal allowance\",\n      \"none\": \"The allowance will be set to {amount} {symbol} independently of any previous allowance. Until this transaction has been executed the spender can still exercise the previous allowance (if any) to it's full amount.\"\n    },\n    \"expiration_date\": {\n      \"title\": \"Expiration date\",\n      \"none\": \"No expiration.\"\n    },\n    \"approval_fee\": \"Approval fee\",\n    \"approver_account_transaction_fees\": \"Transaction fees to be paid by\"\n  },\n  \"icrc2_transfer_from\": {\n    \"title\": \"Transfer from a withdrawal account\",\n    \"withdrawal_account\": \"Withdrawal account\",\n    \"sending_the_transfer_request\": \"Account sending the transfer request\",\n    \"amount_to_withdraw\": \"Amount to withdraw\",\n    \"fee_paid_by_withdrawal_account\": \"Fee paid by withdrawal account\"\n  }\n}\n", "import {assertNonNullish, isNullish, nonNullish} from '@dfinity/utils';\nimport {\n  ICRC21_CALL_CONSENT_MESSAGE,\n  ICRC25_PERMISSION_ASK_ON_USE,\n  ICRC25_PERMISSION_DENIED,\n  ICRC25_PERMISSION_GRANTED,\n  ICRC25_REQUEST_PERMISSIONS,\n  ICRC27_ACCOUNTS,\n  ICRC49_CALL_CANISTER\n} from './constants/icrc.constants';\nimport {SIGNER_DEFAULT_SCOPES, SignerErrorCode} from './constants/signer.constants';\nimport {\n  notifyErrorActionAborted,\n  notifyErrorBusy,\n  notifyErrorMissingPrompt,\n  notifyErrorPermissionNotGranted,\n  notifyErrorRequestNotSupported\n} from './handlers/signer-errors.handlers';\nimport {\n  notifyAccounts as notifyAccountsHandlers,\n  notifyPermissionScopes,\n  notifyReady,\n  notifySupportedStandards,\n  type NotifyPermissions\n} from './handlers/signer-success.handlers';\nimport {notifyError} from './handlers/signer.handlers';\nimport {SignerService} from './services/signer.service';\nimport {\n  readSessionValidScopes,\n  saveSessionScopes,\n  sessionScopeState\n} from './sessions/signer.sessions';\nimport type {IcrcAccounts} from './types/icrc-accounts';\nimport {\n  IcrcAccountsRequestSchema,\n  IcrcCallCanisterRequestSchema,\n  IcrcPermissionsRequestSchema,\n  IcrcRequestAnyPermissionsRequestSchema,\n  IcrcStatusRequestSchema,\n  IcrcSupportedStandardsRequestSchema\n} from './types/icrc-requests';\nimport type {IcrcScope, IcrcScopesArray} from './types/icrc-responses';\nimport {\n  IcrcPermissionStateSchema,\n  IcrcScopedMethodSchema,\n  type IcrcPermissionState,\n  type IcrcScopedMethod\n} from './types/icrc-standards';\nimport type {Origin} from './types/post-message';\nimport {RpcRequestSchema, type RpcId} from './types/rpc';\nimport type {SignerMessageEvent} from './types/signer';\nimport {MissingPromptError} from './types/signer-errors';\nimport type {Notify} from './types/signer-handlers';\nimport type {SignerOptions} from './types/signer-options';\nimport {\n  AccountsPromptSchema,\n  CallCanisterPromptSchema,\n  ConsentMessagePromptSchema,\n  PermissionsPromptSchema,\n  type AccountsApproval,\n  type AccountsPrompt,\n  type AccountsPromptPayload,\n  type CallCanisterPrompt,\n  type ConsentMessagePrompt,\n  type PermissionsConfirmation,\n  type PermissionsPrompt,\n  type PermissionsPromptPayload,\n  type Prompts,\n  type RegisterPrompts,\n  type Rejection\n} from './types/signer-prompts';\n\nexport class Signer {\n  readonly #signerOptions: SignerOptions;\n\n  // eslint-disable-next-line local-rules/use-option-type-wrapper\n  #walletOrigin: string | undefined | null;\n\n  #permissionsPrompt: PermissionsPrompt | undefined;\n  #accountsPrompt: AccountsPrompt | undefined;\n  #consentMessagePrompt: ConsentMessagePrompt | undefined;\n  #callCanisterPrompt: CallCanisterPrompt | undefined;\n\n  // TODO: improve implementation to avoid an unexpected misusage in the future where an issue in the code would lead the busy flag to be reset to idle while effectively still being busy\n  #busy = false;\n\n  readonly #signerService = new SignerService();\n\n  private constructor(options: SignerOptions) {\n    this.#signerOptions = options;\n\n    window.addEventListener('message', this.onMessageListener);\n  }\n\n  /**\n   * Creates a signer that listens and communicates with a relying party.\n   *\n   * @static\n   * @param {SignerOptions} options - The options for the signer.\n   * @returns {Signer} The connected signer.\n   */\n  static init(options: SignerOptions): Signer {\n    return new Signer(options);\n  }\n\n  /**\n   * Disconnects the signer, removing the message event listener and cleanup.\n   * @returns {void}\n   */\n  disconnect = (): void => {\n    window.removeEventListener('message', this.onMessageListener);\n    this.#walletOrigin = null;\n  };\n\n  // TODO: onbeforeunload, the signer should notify an error 4001 if and only if there is a pending request at the same time.\n  // This means that the signer will have to keep track of its activity.\n  // See https://github.com/dfinity/wg-identity-authentication/pull/212\n\n  private readonly onMessageListener = (message: SignerMessageEvent): void => {\n    void this.onMessage(message);\n  };\n\n  private readonly onMessage = async (message: SignerMessageEvent): Promise<void> => {\n    const {data, origin} = message;\n\n    const {success, data: requestData} = RpcRequestSchema.safeParse(data);\n\n    if (!success) {\n      // We are only interested in JSON-RPC messages, so we are ignoring any other messages emitted at the window level, as the consumer might be using other events.\n      return;\n    }\n\n    const {handled: handledReadOnly} = this.handleReadOnlyMessage(message);\n    if (handledReadOnly) {\n      return;\n    }\n\n    const {busy} = this.assertNotBusy(message);\n    if (busy) {\n      return;\n    }\n\n    // TODO: wrap a try catch around all handler and notify \"Unexpected exception\" in case if issues\n\n    const {handled} = await this.handleMessage(message);\n    if (handled) {\n      return;\n    }\n\n    notifyErrorRequestNotSupported({\n      id: requestData?.id ?? null,\n      origin\n    });\n  };\n\n  /**\n   * Handles a potential readonly-only message request.\n   *\n   * The readonly-only message request might be triggered while the signer is busy processing requests.\n   * Since these informative requests do not impact the signer's behavior, it is acceptable to provide a response read-only requests.\n   *\n   * @private\n   * @param {SignerMessageEvent} message - The message event to process.\n   * @returns {{ handled: boolean }} - An object indicating whether the message was handled.\n   */\n  private handleReadOnlyMessage(message: SignerMessageEvent): {handled: boolean} {\n    const {handled: statusRequestHandled} = this.handleStatusRequest(message);\n    if (statusRequestHandled) {\n      return {handled: true};\n    }\n    const {handled: supportedStandardsRequestHandled} = this.handleSupportedStandards(message);\n    if (supportedStandardsRequestHandled) {\n      return {handled: true};\n    }\n    // TODO: handle read-only message requests in the future here (e.g. handleSupportedStandards(..))\n    return {handled: false};\n  }\n\n  private async handleMessage(message: SignerMessageEvent): Promise<{handled: boolean}> {\n    // At this point the connection with the relying party should have been initialized and the origin should be set.\n    const {valid} = this.assertNotUndefinedAndSameOrigin(message);\n    if (!valid) {\n      return {handled: true};\n    }\n\n    const {handled: permissionsHandled} = this.handlePermissionsRequest(message);\n    if (permissionsHandled) {\n      return {handled: true};\n    }\n\n    const {handled: requestsPermissionsHandled} =\n      await this.handleRequestPermissionsRequest(message);\n    if (requestsPermissionsHandled) {\n      return {handled: true};\n    }\n\n    const {handled: accountsHandled} = await this.handleAccounts(message);\n    if (accountsHandled) {\n      return {handled: true};\n    }\n\n    const {handled: callCanisterHandled} = await this.handleCallCanister(message);\n    if (callCanisterHandled) {\n      return {handled: true};\n    }\n\n    return {handled: false};\n  }\n\n  private setWalletOrigin({origin}: Pick<SignerMessageEvent, 'origin'>) {\n    // We do not reassign the origin with the same value if it is already set. It is not a significant performance win.\n    // In addition, requesting the status is now triggered periodically.\n    if (nonNullish(this.#walletOrigin)) {\n      return;\n    }\n\n    this.#walletOrigin = origin;\n  }\n\n  /**\n   * When establishing a connection, validates the origin of a message event to ensure it matches the existing wallet origin - i.e. subsequent status requests - or is undefined - i.e. first status request.\n   * If the origin is invalid, it sends an error notification with the appropriate error code and message.\n   *\n   * @private\n   * @param {object} event - The message event to validate.\n   * @param {any} event.data - The data sent in the message event.\n   * @param {string} event.origin - The origin of the message event.\n   *\n   * @returns {object} An object containing a `valid` boolean property.\n   * @returns {boolean} returns `true` if the origin is either undefined or matches the expected wallet origin, otherwise returns `false` and notifies the error.\n   */\n  private assertUndefinedOrSameOrigin({data: msgData, origin}: SignerMessageEvent): {\n    valid: boolean;\n  } {\n    if (nonNullish(this.#walletOrigin) && this.#walletOrigin !== origin) {\n      const {data} = RpcRequestSchema.safeParse(msgData);\n\n      notifyError({\n        id: data?.id ?? null,\n        origin,\n        error: {\n          code: SignerErrorCode.ORIGIN_ERROR,\n          message: `The relying party's origin is not permitted to obtain the status of the signer.`\n        }\n      });\n\n      return {valid: false};\n    }\n\n    return {valid: true};\n  }\n\n  /**\n   * Checks if the signer is busy and notifies the relying party if it is.\n   *\n   * This is required for security reason to avoid the consumer of the signer to for example process a call canister while at the same time new permissions are requested.\n   *\n   * @private\n   * @param {object} event - The message event to validate.\n   * @param {any} event.data - The data sent in the message event.\n   * @param {string} event.origin - The origin of the message event.\n   *\n   * @returns {object} An object containing a `busy` boolean property.\n   * @returns {boolean} returns true` if the signer is busy, otherwise `false`.\n   */\n  private assertNotBusy({data: msgData, origin}: SignerMessageEvent): {busy: boolean} {\n    if (this.#busy) {\n      notifyErrorBusy({\n        id: msgData?.id ?? null,\n        origin\n      });\n      return {busy: true};\n    }\n\n    return {busy: false};\n  }\n\n  private async handleWithBusy(\n    handler: () => Promise<{handled: boolean}>\n  ): Promise<{handled: boolean}> {\n    this.#busy = true;\n\n    try {\n      return await handler();\n    } finally {\n      // For simplicity reasons we always reset to state idle even if it was not set to busy as we do not want to hang on a busy state if an exception is thrown.\n      this.setIdle();\n    }\n  }\n\n  // This function, strictly speaking, is useful for testing purposes to easily assert the busy flag is reset back to an idle state.\n  // What it does is obviously mandatory.\n  private setIdle() {\n    this.#busy = false;\n  }\n\n  /**\n   * Validates that the wallet origin is defined and matches the origin of the message event that established the connection.\n   * If the origin is invalid or the wallet origin is not defined, it sends an error notification\n   * with the appropriate error code and message.\n   *\n   * @private\n   * @param {object} event - The message event to validate.\n   * @param {any} event.data - The data sent in the message event.\n   * @param {string} event.origin - The origin of the message event.\n   *\n   * @returns {object} An object containing a `valid` boolean property.\n   * @returns {boolean} returns `true` if the wallet origin is defined and matches the origin of the message event, otherwise returns `false` and notifies the error.\n   */\n  private assertNotUndefinedAndSameOrigin({data: msgData, origin}: SignerMessageEvent): {\n    valid: boolean;\n  } {\n    if (isNullish(this.#walletOrigin) || this.#walletOrigin !== origin) {\n      const {data} = RpcRequestSchema.safeParse(msgData);\n\n      notifyError({\n        id: data?.id ?? null,\n        origin,\n        error: {\n          code: SignerErrorCode.ORIGIN_ERROR,\n          message: isNullish(this.#walletOrigin)\n            ? 'The relying party has not established a connection to the signer.'\n            : `The relying party's origin is not allowed to interact with the signer.`\n        }\n      });\n\n      return {valid: false};\n    }\n\n    return {valid: true};\n  }\n\n  /**\n   * Registers a prompt handler for a specified method in the signer service.\n   *\n   * @template T\n   * @param {RegisterPrompts<T>} options - An object containing the method and corresponding prompt handler.\n   * @param {T} options.method - The method for which the prompt handler is being registered. Supported methods include ICRC standards.\n   * @param {Prompts[T]} options.prompt - The prompt handler that should be registered. The prompt type depends on the method being registered.\n   *\n   * @throws {Error} Throws an error if the method is not supported or the prompt type does not match the expected type for the given method.\n   *\n   * @example\n   * // Register a permissions prompt\n   * register({\n   *   method: 'icrc25_request_permissions', // or alternatively using related constant ICRC25_REQUEST_PERMISSIONS\n   *   prompt: (payload) => {\n   *     payload.confirm(requestedScopes);\n   *   }\n   * });\n   */\n  register = <T extends keyof Prompts>({method, prompt}: RegisterPrompts<T>): void => {\n    // TODO: is there a way to avoid casting?\n    switch (method) {\n      case ICRC21_CALL_CONSENT_MESSAGE: {\n        ConsentMessagePromptSchema.parse(prompt);\n        this.#consentMessagePrompt = prompt as ConsentMessagePrompt;\n        return;\n      }\n      case ICRC25_REQUEST_PERMISSIONS: {\n        PermissionsPromptSchema.parse(prompt);\n        this.#permissionsPrompt = prompt as PermissionsPrompt;\n        return;\n      }\n      case ICRC27_ACCOUNTS: {\n        AccountsPromptSchema.parse(prompt);\n        this.#accountsPrompt = prompt as AccountsPrompt;\n        return;\n      }\n      case ICRC49_CALL_CANISTER: {\n        CallCanisterPromptSchema.parse(prompt);\n        this.#callCanisterPrompt = prompt as CallCanisterPrompt;\n        return;\n      }\n    }\n\n    throw new Error(\n      'The specified method is not supported. Please ensure you are using a supported standard.'\n    );\n  };\n\n  // TODO: maybe provide a prompt for the developer to get to know when status \"ready\" was exchanged?\n\n  /**\n   * Handles incoming status requests.\n   *\n   * Parses the message data to determine if it conforms to a status request, sends a notification indicating that the signer is ready and set the origin for asserting subsequent calls.\n   *\n   * @param {SignerMessageEvent} message - The incoming message event containing the data and origin.\n   * @returns {Object} An object with a boolean property `handled` indicating whether the request was handled.\n   */\n  private handleStatusRequest({data, origin, ...rest}: SignerMessageEvent): {handled: boolean} {\n    const {success: isStatusRequest, data: statusData} = IcrcStatusRequestSchema.safeParse(data);\n\n    if (isStatusRequest) {\n      const {valid} = this.assertUndefinedOrSameOrigin({data, origin, ...rest});\n      if (!valid) {\n        return {handled: true};\n      }\n\n      const {id} = statusData;\n      notifyReady({id, origin});\n\n      this.setWalletOrigin({origin});\n\n      return {handled: true};\n    }\n\n    return {handled: false};\n  }\n\n  /**\n   * Handles incoming messages to list the supported standards.\n   *\n   * Parses the message data to determine if it conforms to a supported standards request and responds with a notification with the supported standards.\n   *\n   * @param {SignerMessageEvent} message - The incoming message event containing the data and origin.\n   * @returns {Object} An object with a boolean property `handled` indicating whether the request was handled.\n   */\n  private handleSupportedStandards({data, origin}: SignerMessageEvent): {handled: boolean} {\n    const {success: isSupportedStandardsRequest, data: supportedStandardsData} =\n      IcrcSupportedStandardsRequestSchema.safeParse(data);\n\n    if (isSupportedStandardsRequest) {\n      const {id} = supportedStandardsData;\n      notifySupportedStandards({id, origin});\n      return {handled: true};\n    }\n\n    return {handled: false};\n  }\n\n  /**\n   * Handles incoming messages to list the permissions.\n   *\n   * Parses the message data to determine if it conforms to a permissions request and responds with a notification with the scopes of the permissions.\n   *\n   * @param {SignerMessageEvent} message - The incoming message event containing the data and origin.\n   * @returns {Object} An object with a boolean property `handled` indicating whether the request was handled.\n   */\n  private handlePermissionsRequest({data}: SignerMessageEvent): {handled: boolean} {\n    const {success: isPermissionsRequestRequest, data: permissionsRequestData} =\n      IcrcPermissionsRequestSchema.safeParse(data);\n\n    if (isPermissionsRequestRequest) {\n      const {id} = permissionsRequestData;\n\n      this.emitPermissions({id});\n\n      return {handled: true};\n    }\n\n    return {handled: false};\n  }\n\n  // TODO: user can answer to permissions prompts with ask_on_use?\n  // Maybe it's possible to resolve it without modifying the lib. To be double checked.\n\n  /**\n   * Handles incoming messages to request permissions.\n   *\n   * Parses the message data to determine if it conforms to a request permissions schema. If it does,\n   * forwards the parameters to the clients, as requesting permissions requires the user to review\n   * and approve or decline them.\n   *\n   * @param {SignerMessageEvent} message - The incoming message event containing the data and origin.\n   * @returns {Object} An object with a boolean property `handled` indicating whether the request was processed as a permissions request.\n   */\n  private async handleRequestPermissionsRequest({\n    data,\n    origin\n  }: SignerMessageEvent): Promise<{handled: boolean}> {\n    const handler = async (): Promise<{handled: boolean}> => {\n      const {success: isRequestPermissionsRequest, data: requestPermissionsData} =\n        IcrcRequestAnyPermissionsRequestSchema.safeParse(data);\n\n      if (!isRequestPermissionsRequest) {\n        return {handled: false};\n      }\n\n      const {\n        id: requestId,\n        params: {scopes: requestedScopes}\n      } = requestPermissionsData;\n\n      if (isNullish(this.#permissionsPrompt)) {\n        this.assertWalletOriginAndNotifyMissingPromptError(requestId);\n\n        return {handled: true};\n      }\n\n      // TODO: In the future, we might want to prompt only if the requested permissions are not already granted. We should prevent the case where the relying party requests permissions without first checking if those permissions have already been granted. Let's see how the signer is used by the community first.\n      // TODO: Can the newer version of TypeScript infer \"as IcrcScope\"?\n      const supportedRequestedScopes = requestedScopes\n        .filter(\n          ({method: requestedMethod}) => IcrcScopedMethodSchema.safeParse(requestedMethod).success\n        )\n        .map(\n          ({method}) =>\n            ({\n              scope: {method},\n              state: IcrcPermissionStateSchema.enum.denied\n            }) as const as IcrcScope\n        )\n        .sort(\n          ({scope: {method: methodA}}: IcrcScope, {scope: {method: methodB}}: IcrcScope): number =>\n            methodA.localeCompare(methodB)\n        );\n\n      // TODO: Maybe validating that the list of requested scopes contains at least one scope would be cool?\n      // Additionally, it may be beneficial to define a type that ensures at least one scope is present when responding to permission queries ([IcrcScope, ...IcrcScop[]] in Zod).\n      // Overall, it would be handy to enforce a minimum of one permission through types and behavior?\n\n      const promptFn = async (): Promise<void> => {\n        const confirmedScopes = await this.promptPermissions({\n          requestedScopes: supportedRequestedScopes,\n          origin\n        });\n\n        this.savePermissions({scopes: confirmedScopes});\n        this.emitPermissions({id: requestId});\n      };\n\n      await this.prompt({\n        requestId,\n        promptFn\n      });\n\n      return {handled: true};\n    };\n\n    return await this.handleWithBusy(handler);\n  }\n\n  private async promptPermissions(\n    payload: Omit<PermissionsPromptPayload, 'confirm'>\n  ): Promise<IcrcScopesArray> {\n    const promise = new Promise<IcrcScopesArray>((resolve, reject) => {\n      const confirm: PermissionsConfirmation = (scopes) => {\n        resolve(scopes);\n      };\n\n      // The consumer currently has no way to unregister the prompt, so we know that it is defined. However, to be future-proof, it's better to ensure it is defined.\n      if (isNullish(this.#permissionsPrompt)) {\n        reject(new MissingPromptError());\n        return;\n      }\n\n      this.#permissionsPrompt({...payload, confirm});\n    });\n\n    return await promise;\n  }\n\n  private emitPermissions({id}: Pick<NotifyPermissions, 'id'>): void {\n    assertNonNullish(this.#walletOrigin, \"The relying party's origin is unknown.\");\n\n    const {owner, sessionOptions} = this.#signerOptions;\n\n    const scopes = readSessionValidScopes({\n      owner: owner.getPrincipal(),\n      origin: this.#walletOrigin,\n      sessionOptions\n    });\n\n    // The relying party should always receive the full list of permissions, and those that have never been requested or have expired should be provided as \"ask_on_use\".\n    const allScopes = [\n      ...(scopes ?? []),\n      ...SIGNER_DEFAULT_SCOPES.filter(\n        ({scope: {method: defaultMethod}}) =>\n          (scopes ?? []).find(({scope: {method}}) => method === defaultMethod) === undefined\n      )\n    ];\n\n    notifyPermissionScopes({\n      id,\n      origin: this.#walletOrigin,\n      scopes: allScopes\n    });\n  }\n\n  private assertWalletOriginAndNotifyMissingPromptError(id: RpcId | undefined): void {\n    assertNonNullish(this.#walletOrigin, \"The relying party's origin is unknown.\");\n\n    notifyErrorMissingPrompt({\n      id: id ?? null,\n      origin: this.#walletOrigin\n    });\n  }\n\n  private savePermissions({scopes}: {scopes: IcrcScopesArray}): void {\n    assertNonNullish(this.#walletOrigin, \"The relying party's origin is unknown.\");\n\n    const {owner} = this.#signerOptions;\n\n    saveSessionScopes({owner: owner.getPrincipal(), origin: this.#walletOrigin, scopes});\n  }\n\n  /**\n   * Handles incoming messages to list the accounts.\n   *\n   * Parses the message data to determine if it conforms to a accounts request and responds with the accounts if the permissions are granted.\n   *\n   * @param {SignerMessageEvent} message - The incoming message event containing the data and origin.\n   * @returns {Object} An object with a boolean property `handled` indicating whether the request was handled.\n   */\n  private async handleAccounts({data, origin}: SignerMessageEvent): Promise<{handled: boolean}> {\n    const handler = async (): Promise<{handled: boolean}> => {\n      const {success: isAccountsRequest, data: accountsData} =\n        IcrcAccountsRequestSchema.safeParse(data);\n\n      if (!isAccountsRequest) {\n        return {handled: false};\n      }\n\n      const {id: requestId} = accountsData;\n\n      const notifyAccounts = async (): Promise<void> => {\n        const promptFn = async (): Promise<void> => {\n          const {result, accounts} = await this.promptAccounts({origin});\n\n          if (result === 'rejected') {\n            notifyErrorActionAborted({id: requestId, origin});\n            return;\n          }\n\n          notifyAccountsHandlers({accounts, id: requestId, origin});\n        };\n\n        await this.prompt({\n          requestId,\n          promptFn\n        });\n      };\n\n      const permission = await this.assertAndPromptPermissions({\n        method: ICRC27_ACCOUNTS,\n        requestId,\n        origin\n      });\n\n      switch (permission) {\n        case ICRC25_PERMISSION_DENIED: {\n          notifyErrorPermissionNotGranted({\n            id: requestId ?? null,\n            origin\n          });\n          break;\n        }\n        case ICRC25_PERMISSION_GRANTED: {\n          await notifyAccounts();\n          break;\n        }\n      }\n\n      return {handled: true};\n    };\n\n    return await this.handleWithBusy(handler);\n  }\n\n  private async prompt({\n    requestId,\n    promptFn\n  }: {\n    promptFn: () => Promise<void>;\n    requestId: RpcId;\n  }): Promise<void> {\n    try {\n      await promptFn();\n    } catch (err: unknown) {\n      if (err instanceof MissingPromptError) {\n        this.assertWalletOriginAndNotifyMissingPromptError(requestId);\n        return;\n      }\n\n      throw err;\n    }\n  }\n\n  // TODO: this can maybe be made generic. It's really similar to promptPermissions.\n  private async promptAccounts(\n    payload: Omit<AccountsPromptPayload, 'approve' | 'reject'>\n  ): Promise<{result: 'approved' | 'rejected'; accounts: IcrcAccounts}> {\n    const promise = new Promise<{result: 'approved' | 'rejected'; accounts: IcrcAccounts}>(\n      (resolve, reject) => {\n        const userReject: Rejection = () => {\n          resolve({result: 'rejected', accounts: []});\n        };\n\n        const approve: AccountsApproval = (accounts) => {\n          resolve({result: 'approved', accounts});\n        };\n\n        // The consumer currently has no way to unregister the prompt, so we know that it is defined. However, to be future-proof, it's better to ensure it is defined.\n        if (isNullish(this.#accountsPrompt)) {\n          reject(new MissingPromptError());\n          return;\n        }\n\n        this.#accountsPrompt({approve, reject: userReject, ...payload});\n      }\n    );\n\n    return await promise;\n  }\n\n  /**\n   * Handles incoming messages to call a canister.\n   *\n   * Parses the message data to determine if it conforms to a call canister request and responds with the result of the call if the permissions are granted and if the user accept the consent message.\n   *\n   * @param {SignerMessageEvent} message - The incoming message event containing the data and origin.\n   * @returns {Object} An object with a boolean property `handled` indicating whether the request was handled.\n   */\n  private async handleCallCanister({\n    data,\n    origin\n  }: SignerMessageEvent): Promise<{handled: boolean}> {\n    const handler = async (): Promise<{handled: boolean}> => {\n      const {success: isCallCanisterRequest, data: callData} =\n        IcrcCallCanisterRequestSchema.safeParse(data);\n\n      if (!isCallCanisterRequest) {\n        return {handled: false};\n      }\n\n      const {id: requestId, params} = callData;\n\n      const permission = await this.assertAndPromptPermissions({\n        method: ICRC49_CALL_CANISTER,\n        requestId,\n        origin\n      });\n\n      if (permission === ICRC25_PERMISSION_DENIED) {\n        notifyErrorPermissionNotGranted({\n          id: requestId ?? null,\n          origin\n        });\n        return {handled: true};\n      }\n\n      const notify: Notify = {\n        id: requestId,\n        origin\n      };\n\n      const {result: userConsent} = await this.#signerService.assertAndPromptConsentMessage({\n        notify,\n        params,\n        prompt: this.#consentMessagePrompt,\n        options: this.#signerOptions\n      });\n\n      if (userConsent !== 'approved') {\n        return {handled: true};\n      }\n\n      await this.#signerService.callCanister({\n        notify,\n        params,\n        options: this.#signerOptions,\n        prompt: this.#callCanisterPrompt\n      });\n\n      return {handled: true};\n    };\n\n    return await this.handleWithBusy(handler);\n  }\n\n  /**\n   * Asserts the current permission state for the given method and origin. If the permission\n   * is set to 'ask_on_use', prompts the user for permission and returns the updated state.\n   *\n   * @private\n   * @async\n   * @function\n   * @param {Object} params - The parameters for the function.\n   * @param {IcrcScopedMethod} params.method - The method for which permissions are being checked.\n   * @param {string} params.origin - The origin from where the request is made.\n   * @param {RpcId} params.requestId - The unique identifier for the RPC request.\n   *\n   * @returns {Promise<Omit<IcrcPermissionState, 'ask_on_use'>>} - A promise that resolves to the updated\n   * permission state ('granted' or 'denied'), or the current permission if no prompt is needed.\n   *\n   * @throws {Error} - Throws an error if the permission prompt fails.\n   */\n  private async assertAndPromptPermissions({\n    method,\n    origin,\n    requestId\n  }: {\n    method: IcrcScopedMethod;\n    origin: Origin;\n    requestId: RpcId;\n  }): Promise<Omit<IcrcPermissionState, 'ask_on_use'>> {\n    const {owner} = this.#signerOptions;\n\n    const currentPermission = sessionScopeState({\n      owner: owner.getPrincipal(),\n      origin,\n      method\n    });\n\n    switch (currentPermission) {\n      case ICRC25_PERMISSION_ASK_ON_USE: {\n        const promise = new Promise<Omit<IcrcPermissionState, 'ask_on_use'>>((resolve, reject) => {\n          const promptFn = async (): Promise<void> => {\n            const requestedScopes: IcrcScopesArray = [\n              {\n                scope: {\n                  method\n                },\n                state: ICRC25_PERMISSION_DENIED\n              }\n            ];\n\n            const confirmedScopes = await this.promptPermissions({\n              requestedScopes,\n              origin\n            });\n\n            this.savePermissions({scopes: confirmedScopes});\n\n            const approved =\n              confirmedScopes.find(\n                ({scope: {method: m}, state}) => m === method && state === ICRC25_PERMISSION_GRANTED\n              ) !== undefined;\n\n            if (approved) {\n              resolve(ICRC25_PERMISSION_GRANTED);\n              return;\n            }\n\n            resolve(ICRC25_PERMISSION_DENIED);\n          };\n\n          this.prompt({\n            requestId,\n            promptFn\n          }).catch((err) => {\n            reject(err);\n          });\n        });\n\n        return await promise;\n      }\n      default:\n        return currentPermission;\n    }\n  }\n}\n", "export const ICRC21_CALL_CONSENT_MESSAGE = 'icrc21_call_consent_message';\nexport const ICRC25_REQUEST_PERMISSIONS = 'icrc25_request_permissions';\nexport const ICRC25_PERMISSIONS = 'icrc25_permissions';\nexport const ICRC25_SUPPORTED_STANDARDS = 'icrc25_supported_standards';\nexport const ICRC27_ACCOUNTS = 'icrc27_accounts';\nexport const ICRC29_STATUS = 'icrc29_status';\nexport const ICRC49_CALL_CANISTER = 'icrc49_call_canister';\n\nexport const ICRC25_PERMISSION_GRANTED = 'granted';\nexport const ICRC25_PERMISSION_DENIED = 'denied';\nexport const ICRC25_PERMISSION_ASK_ON_USE = 'ask_on_use';\n\nexport const ICRC21 = 'ICRC-21';\nexport const ICRC25 = 'ICRC-25';\nexport const ICRC27 = 'ICRC-27';\nexport const ICRC29 = 'ICRC-29';\nexport const ICRC49 = 'ICRC-49';\n", "import * as z from 'zod/v4';\nimport {\n  ICRC21,\n  ICRC21_CALL_CONSENT_MESSAGE,\n  ICRC25,\n  ICRC25_PERMISSION_ASK_ON_USE,\n  ICRC25_PERMISSION_DENIED,\n  ICRC25_PERMISSION_GRANTED,\n  ICRC25_PERMISSIONS,\n  ICRC25_REQUEST_PERMISSIONS,\n  ICRC25_SUPPORTED_STANDARDS,\n  ICRC27,\n  ICRC27_ACCOUNTS,\n  ICRC29,\n  ICRC29_STATUS,\n  ICRC49,\n  ICRC49_CALL_CANISTER\n} from '../constants/icrc.constants';\n\nexport const IcrcMethodSchema = z.enum([\n  ICRC21_CALL_CONSENT_MESSAGE,\n  ICRC25_REQUEST_PERMISSIONS,\n  ICRC25_PERMISSIONS,\n  ICRC25_SUPPORTED_STANDARDS,\n  ICRC27_ACCOUNTS,\n  ICRC29_STATUS,\n  ICRC49_CALL_CANISTER\n]);\n\nexport const IcrcScopedMethodSchema = IcrcMethodSchema.extract([\n  ICRC27_ACCOUNTS,\n  ICRC49_CALL_CANISTER\n]);\n\nexport type IcrcScopedMethod = z.infer<typeof IcrcScopedMethodSchema>;\n\nexport const IcrcPermissionStateSchema = z.enum([\n  ICRC25_PERMISSION_GRANTED,\n  ICRC25_PERMISSION_DENIED,\n  ICRC25_PERMISSION_ASK_ON_USE\n]);\n\nexport type IcrcPermissionState = z.infer<typeof IcrcPermissionStateSchema>;\n\nexport const IcrcStandardSchema = z.enum([ICRC21, ICRC25, ICRC27, ICRC29, ICRC49]);\n", "import type {IcrcScopesArray, IcrcSupportedStandards} from '../types/icrc-responses';\nimport {IcrcScopedMethodSchema, IcrcStandardSchema} from '../types/icrc-standards';\nimport {ICRC25_PERMISSION_ASK_ON_USE} from './icrc.constants';\n\nexport enum SignerErrorCode {\n  /**\n   * The relying party's origin is not allowed to interact with the signer.\n   */\n  ORIGIN_ERROR = 500,\n\n  /**\n   * The signer has not registered a prompt to respond to permission requests.\n   */\n  PERMISSIONS_PROMPT_NOT_REGISTERED = 501,\n\n  /**\n   * The sender of a canister call does not match the owner of the signer.\n   */\n  SENDER_NOT_ALLOWED = 502,\n\n  /**\n   * The signer is currently processing a request and cannot handle new requests.\n   */\n  BUSY = 503,\n\n  /**\n   * Owner is not set on the signer.\n   */\n  NOT_INITIALIZED = 504,\n\n  /**\n   * A generic error.\n   * @see https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#errors\n   */\n  GENERIC_ERROR = 1000,\n\n  /**\n   * The request sent by the relying party is not supported by the signer.\n   *\n   * @see https://github.com/dfinity/wg-identity-authentication/blob/docs/fix-get-accounts/topics/icrc_25_signer_interaction_standard.md#errors-3\n   */\n  REQUEST_NOT_SUPPORTED = 2000,\n\n  /**\n   * An error is thrown when the permission to perform a feature is denied.\n   * @see https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#errors\n   */\n  PERMISSION_NOT_GRANTED = 3000,\n\n  /**\n   * An error is thrown when the user cancel or deny an action.\n   * @see https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#errors-3\n   */\n  ACTION_ABORTED = 3001,\n\n  /**\n   * An unexpected \"network\" error happened. Like not being able to call the IC.\n   * @see https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#errors-3\n   */\n  NETWORK_ERROR = 4000\n}\n\nexport const SIGNER_SUPPORTED_STANDARDS: IcrcSupportedStandards = Object.values(\n  IcrcStandardSchema.enum\n).map((name) => ({\n  name,\n  url: `https://github.com/dfinity/ICRC/blob/main/ICRCs/${name}/${name}.md`\n}));\n\nexport const SIGNER_DEFAULT_SCOPES: IcrcScopesArray = Object.values(\n  IcrcScopedMethodSchema.enum\n).map((method) => ({scope: {method}, state: ICRC25_PERMISSION_ASK_ON_USE}));\n\nexport const SIGNER_PERMISSION_VALIDITY_PERIOD_IN_MILLISECONDS = 7 * 24 * 60 * 60 * 1000; // 7 days\n", "import * as z from 'zod/v4';\n\n// JSON-RPC 2.0 Specification\n// https://www.jsonrpc.org/specification\n\nexport const JSON_RPC_VERSION_2 = '2.0';\n\nconst JsonRpcSchema = z.literal(JSON_RPC_VERSION_2);\n\nexport const RpcIdSchema = z.union([z.string(), z.number(), z.null()]);\n\nexport type RpcId = z.infer<typeof RpcIdSchema>;\n\nconst RpcSchema = z.object({\n  jsonrpc: JsonRpcSchema,\n  id: z.optional(RpcIdSchema)\n});\n\nexport const RpcRequestSchema = RpcSchema.extend({\n  id: RpcIdSchema\n})\n  .merge(\n    z.object({\n      method: z.string(),\n      params: z.optional(z.any())\n    })\n  )\n  .strict();\n\ntype _RpcRequest = z.infer<typeof RpcRequestSchema>;\n\nexport const inferRpcRequestWithoutParamsSchema = <M extends string>({method}: {method: M}) =>\n  RpcRequestSchema.omit({method: true, params: true})\n    .strict()\n    .extend({\n      id: RpcIdSchema,\n      method: z.literal(method)\n    });\n\ntype RpcRequestWithoutParamsReturnType<M extends string> = ReturnType<\n  typeof inferRpcRequestWithoutParamsSchema<M>\n>;\n\ntype _RpcRequestWithoutParams<M extends string> = z.infer<RpcRequestWithoutParamsReturnType<M>>;\n\nexport const inferRpcRequestWithParamsSchema = <T extends z.ZodTypeAny, M extends string>({\n  params,\n  method\n}: {\n  params: T;\n  method: M;\n}) =>\n  RpcRequestSchema.omit({method: true})\n    .extend({\n      id: RpcIdSchema,\n      method: z.literal(method)\n    })\n    .merge(\n      z.object({\n        params\n      })\n    );\n\nexport const RpcNotificationSchema = RpcRequestSchema.omit({id: true}).strict();\n\nexport enum RpcErrorCode {\n  /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */\n  PARSE_ERROR = -32700,\n  /**\n   * The JSON sent is not a valid Request object.\n   */\n  INVALID_REQUEST = -32600,\n  /**\n   * The method does not exist / is not available.\n   */\n  METHOD_NOT_FOUND = -32601,\n  /**\n   * Invalid method parameter(s).\n   */\n  INVALID_PARAMS = -32602,\n  /**\n   * Internal JSON-RPC error.\n   */\n  INTERNAL_ERROR = -32603,\n  /**\n   * Reserved for implementation-defined server-errors.\n   */\n  SERVER_ERROR = -32000\n}\n\nconst RpcResponseErrorCodeSchema = z.union([z.number(), z.nativeEnum(RpcErrorCode)]);\n\nexport type RpcResponseErrorCode = z.infer<typeof RpcResponseErrorCodeSchema>;\n\nconst RpcResponseErrorSchema = z.object({\n  code: RpcResponseErrorCodeSchema,\n  message: z.string(),\n  data: z.optional(z.never())\n});\n\nexport type RpcResponseError = z.infer<typeof RpcResponseErrorSchema>;\n\nconst RpcResponseSchema = RpcSchema.extend({\n  id: RpcIdSchema\n});\n\nexport type RpcResponse = z.infer<typeof RpcResponseSchema>;\n\nexport const RpcResponseWithErrorSchema = RpcResponseSchema.extend({\n  error: RpcResponseErrorSchema\n}).strict();\n\nexport type RpcResponseWithError = z.infer<typeof RpcResponseWithErrorSchema>;\n\nexport const inferRpcResponseSchema = <T extends z.ZodTypeAny>(result: T) =>\n  RpcResponseWithErrorSchema.omit({error: true})\n    .merge(\n      z\n        .object({\n          result,\n          error: RpcResponseErrorSchema\n        })\n        .partial()\n    )\n    .strict()\n    .refine(\n      ({result, error}) => result !== undefined || error !== undefined,\n      'Either result or error should be provided.'\n    );\n\nexport const RpcResponseWithResultOrErrorSchema = inferRpcResponseSchema(z.any());\n", "import {\n  JSON_RPC_VERSION_2,\n  type RpcResponse,\n  type RpcResponseError,\n  type RpcResponseWithError\n} from '../types/rpc';\nimport type {Notify} from '../types/signer-handlers';\n\nexport const notifyError = ({\n  id,\n  error,\n  origin\n}: {\n  error: RpcResponseError;\n} & Notify): void => {\n  const msg: RpcResponseWithError = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    error\n  };\n\n  notify({msg, origin});\n};\n\n// TODO: instead of window.opener try to sent the message to MessageEvent.source first.\n// This is safer in case the signer is opened with redirect in the future.\n// e.g. per user canister pattern\nexport const notify = ({msg, origin}: {msg: RpcResponse} & Pick<Notify, 'origin'>): void =>\n  window.opener.postMessage(msg, origin);\n", "import {SignerErrorCode} from '../constants/signer.constants';\nimport type {Notify} from '../types/signer-handlers';\nimport {notifyError} from './signer.handlers';\n\nexport const notifyErrorRequestNotSupported = ({\n  message,\n  ...notify\n}: Notify & {message?: string}): void => {\n  notifyError({\n    ...notify,\n    error: {\n      code: SignerErrorCode.REQUEST_NOT_SUPPORTED,\n      message: message ?? 'The request sent by the relying party is not supported by the signer.'\n    }\n  });\n};\n\nexport const notifyErrorActionAborted = (notify: Notify): void => {\n  notifyError({\n    ...notify,\n    error: {\n      code: SignerErrorCode.ACTION_ABORTED,\n      message: 'The signer has canceled the action requested by the relying party.'\n    }\n  });\n};\n\nexport const notifyNetworkError = ({message, ...notify}: Notify & {message: string}): void => {\n  notifyError({\n    ...notify,\n    error: {\n      code: SignerErrorCode.NETWORK_ERROR,\n      message\n    }\n  });\n};\n\nexport const notifyErrorPermissionNotGranted = (notify: Notify): void => {\n  notifyError({\n    ...notify,\n    error: {\n      code: SignerErrorCode.PERMISSION_NOT_GRANTED,\n      message:\n        'The signer has not granted the necessary permissions to process the request from the relying party.'\n    }\n  });\n};\n\nexport const notifyErrorMissingPrompt = (notify: Notify): void => {\n  notifyError({\n    ...notify,\n    error: {\n      code: SignerErrorCode.PERMISSIONS_PROMPT_NOT_REGISTERED,\n      message: 'The signer has not registered a prompt to respond to permission requests.'\n    }\n  });\n};\n\nexport const notifyErrorSenderNotAllowed = (notify: Notify): void => {\n  notifyError({\n    ...notify,\n    error: {\n      code: SignerErrorCode.SENDER_NOT_ALLOWED,\n      message: 'The sender must match the owner of the signer.'\n    }\n  });\n};\n\nexport const notifyErrorBusy = (notify: Notify): void => {\n  notifyError({\n    ...notify,\n    error: {\n      code: SignerErrorCode.BUSY,\n      message:\n        'The signer is currently processing a request and cannot handle new requests at this time.'\n    }\n  });\n};\n\nexport const notifyErrorNotInitialized = (notify: Notify): void => {\n  notifyError({\n    ...notify,\n    error: {\n      code: SignerErrorCode.NOT_INITIALIZED,\n      message: 'The signer does not have an owner set.'\n    }\n  });\n};\n", "import {SIGNER_SUPPORTED_STANDARDS} from '../constants/signer.constants';\nimport type {IcrcAccounts} from '../types/icrc-accounts';\nimport type {\n  IcrcAccountsResponse,\n  IcrcCallCanisterResponse,\n  IcrcCallCanisterResult,\n  IcrcReadyResponse,\n  IcrcScopesArray,\n  IcrcScopesResponse,\n  IcrcSupportedStandardsResponse\n} from '../types/icrc-responses';\nimport {JSON_RPC_VERSION_2} from '../types/rpc';\nimport type {Notify} from '../types/signer-handlers';\nimport {notify} from './signer.handlers';\n\nexport const notifyReady = ({id, origin}: Notify): void => {\n  const msg: IcrcReadyResponse = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    result: 'ready'\n  };\n\n  notify({msg, origin});\n};\n\nexport const notifySupportedStandards = ({id, origin}: Notify): void => {\n  const msg: IcrcSupportedStandardsResponse = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    result: {\n      supportedStandards: SIGNER_SUPPORTED_STANDARDS\n    }\n  };\n\n  notify({msg, origin});\n};\n\nexport type NotifyPermissions = Notify & {scopes: IcrcScopesArray};\n\nexport const notifyPermissionScopes = ({id, origin, scopes}: NotifyPermissions): void => {\n  const msg: IcrcScopesResponse = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    result: {scopes}\n  };\n\n  notify({msg, origin});\n};\n\nexport type NotifyAccounts = Notify & {accounts: IcrcAccounts};\n\nexport const notifyAccounts = ({id, origin, accounts}: NotifyAccounts): void => {\n  const msg: IcrcAccountsResponse = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    result: {accounts}\n  };\n\n  notify({msg, origin});\n};\n\nexport type NotifyCallCanister = Notify & {result: IcrcCallCanisterResult};\n\nexport const notifyCallCanister = ({id, origin, result}: NotifyCallCanister): void => {\n  const msg: IcrcCallCanisterResponse = {\n    jsonrpc: JSON_RPC_VERSION_2,\n    id,\n    result\n  };\n\n  notify({msg, origin});\n};\n", "import {uint8ToBuf} from '@dfinity/agent';\nimport {mapTokenMetadata} from '@dfinity/ledger-icrc';\nimport {Principal} from '@dfinity/principal';\nimport {base64ToUint8Array, isNullish, notEmptyString} from '@dfinity/utils';\nimport {SignerApi} from '../api/signer.api';\nimport {SIGNER_BUILDERS} from '../constants/signer.builders.constants';\nimport type {icrc21_consent_message_response} from '../declarations/icrc-21';\nimport {\n  notifyErrorActionAborted,\n  notifyErrorMissingPrompt,\n  notifyErrorRequestNotSupported,\n  notifyErrorSenderNotAllowed,\n  notifyNetworkError\n} from '../handlers/signer-errors.handlers';\nimport {notifyCallCanister} from '../handlers/signer-success.handlers';\nimport type {IcrcCallCanisterRequestParams} from '../types/icrc-requests';\nimport type {Notify} from '../types/signer-handlers';\nimport type {SignerOptions} from '../types/signer-options';\nimport type {\n  CallCanisterPrompt,\n  ConsentInfoWarn,\n  ConsentMessageApproval,\n  ConsentMessagePrompt,\n  ResultConsentMessage\n} from '../types/signer-prompts';\nimport {mapIcrc21ErrorToString} from '../utils/icrc-21.utils';\n\nexport class SignerService {\n  readonly #signerApi = new SignerApi();\n\n  async assertAndPromptConsentMessage({\n    params: {sender, ...params},\n    prompt,\n    notify,\n    options: {owner, host}\n  }: {\n    params: IcrcCallCanisterRequestParams;\n    prompt: ConsentMessagePrompt | undefined;\n    notify: Notify;\n    options: SignerOptions;\n  }): Promise<{result: 'approved' | 'rejected' | 'error'}> {\n    const {result: senderMatchOwner} = this.assertSender({sender, owner, notify});\n\n    if (senderMatchOwner === 'invalid') {\n      return {result: 'error'};\n    }\n\n    // The consumer currently has no way to unregister the prompt, so we know that it is defined. However, to be future-proof, it's better to ensure it is defined.\n    if (isNullish(prompt)) {\n      notifyErrorMissingPrompt(notify);\n      return {result: 'error'};\n    }\n\n    const {origin} = notify;\n\n    prompt({origin, status: 'loading'});\n\n    try {\n      const response = await this.loadConsentMessage({\n        params,\n        options: {host, owner}\n      });\n\n      if ('Err' in response) {\n        const {Err} = response;\n\n        prompt({origin, status: 'error', details: Err});\n\n        notifyErrorRequestNotSupported({\n          ...notify,\n          message: mapIcrc21ErrorToString(Err)\n        });\n\n        return {result: 'error'};\n      }\n\n      const {result} = await this.promptConsentMessage({\n        consentInfo: response,\n        prompt,\n        origin\n      });\n\n      if (result === 'rejected') {\n        notifyErrorActionAborted(notify);\n      }\n\n      return {result};\n    } catch (err: unknown) {\n      return this.notifyError({err, prompt, notify});\n    }\n  }\n\n  async callCanister({\n    params,\n    prompt,\n    notify,\n    options\n  }: {\n    params: IcrcCallCanisterRequestParams;\n    prompt: CallCanisterPrompt | undefined;\n    notify: Notify;\n    options: SignerOptions;\n  }): Promise<{result: 'success' | 'error'}> {\n    const {origin} = notify;\n\n    prompt?.({origin, status: 'executing'});\n\n    try {\n      const result = await this.#signerApi.call({\n        ...options,\n        params\n      });\n\n      notifyCallCanister({\n        ...notify,\n        result\n      });\n\n      prompt?.({origin, status: 'result', ...result});\n\n      return {result: 'success'};\n    } catch (err: unknown) {\n      prompt?.({origin, status: 'error', details: err});\n\n      notifyNetworkError({\n        ...notify,\n        message:\n          err instanceof Error && notEmptyString(err.message)\n            ? err.message\n            : 'An unknown error occurred'\n      });\n\n      return {result: 'error'};\n    }\n  }\n\n  private assertSender({\n    notify,\n    owner,\n    sender\n  }: {notify: Notify} & Pick<SignerOptions, 'owner'> &\n    Pick<IcrcCallCanisterRequestParams, 'sender'>): {result: 'valid' | 'invalid'} {\n    if (owner.getPrincipal().toText() === Principal.fromText(sender).toText()) {\n      return {result: 'valid'};\n    }\n\n    notifyErrorSenderNotAllowed(notify);\n\n    return {result: 'invalid'};\n  }\n\n  private async callConsentMessage({\n    params: {canisterId, method, arg},\n    options: {owner, host}\n  }: {\n    params: Omit<IcrcCallCanisterRequestParams, 'sender'>;\n    options: SignerOptions;\n  }): Promise<icrc21_consent_message_response> {\n    return await this.#signerApi.consentMessage({\n      owner,\n      host,\n      canisterId,\n      request: {\n        method,\n        arg: base64ToUint8Array(arg),\n        // TODO: consumer should be able to define user_preferences\n        user_preferences: {\n          metadata: {\n            // TODO: support i18n\n            language: 'en',\n            utc_offset_minutes: []\n          },\n          device_spec: []\n        }\n      }\n    });\n  }\n\n  private notifyError({\n    err,\n    notify,\n    prompt\n  }: {\n    err: unknown;\n    notify: Notify;\n    prompt: ConsentMessagePrompt;\n  }): {result: 'error'} {\n    // TODO: 2001 for not supported consent message - i.e. method is not implemented.\n    // see https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_49_call_canister.md#errors\n\n    // TODO: Likewise for example if canister is out of cycles or stopped etc. it should not throw 4000.\n\n    const {origin} = notify;\n\n    prompt({origin, status: 'error', details: err});\n\n    notifyNetworkError({\n      ...notify,\n      message:\n        err instanceof Error && notEmptyString(err.message)\n          ? err.message\n          : 'An unknown error occurred'\n    });\n\n    return {result: 'error'};\n  }\n\n  private async promptConsentMessage({\n    prompt,\n    ...payload\n  }: {\n    prompt: ConsentMessagePrompt;\n  } & Pick<ResultConsentMessage, 'consentInfo' | 'origin'>): Promise<{\n    result: 'approved' | 'rejected';\n  }> {\n    const promise = new Promise<{result: 'approved' | 'rejected'}>((resolve) => {\n      const approve: ConsentMessageApproval = () => {\n        resolve({result: 'approved'});\n      };\n\n      const userReject: ConsentMessageApproval = () => {\n        resolve({result: 'rejected'});\n      };\n\n      prompt({status: 'result', approve, reject: userReject, ...payload});\n    });\n\n    return await promise;\n  }\n\n  /**\n   * If the ICRC-21 call to fetch the consent message fails, it might be due to the fact\n   * that the targeted canister does not implement the ICRC-21 specification.\n   *\n   * To address the potential lack of support for the most common types of calls for ledgers,\n   * namely transfer and approve, we use custom builders. Those builders construct\n   * messages similar to those that would be implemented by the canisters.\n   *\n   * @param {Object} params - The parameters for loading the consent message.\n   * @param {Omit<IcrcCallCanisterRequestParams, 'sender'>} params.params - The ICRC call canister parameters minus the sender.\n   * @param {SignerOptions} params.options - The signer options - host and owner.\n   * @returns {Promise<icrc21_consent_message_response | ConsentInfoWarn>} - A consent message response. Returns \"Ok\" if the message was decoded by the targeted canister, or \"Warn\" if the fallback builder was used.\n   * @throws The potential original error from the ICRC-21 call. The errors related to\n   *         the custom builder is ignored.\n   **/\n  private async loadConsentMessage(params: {\n    params: Omit<IcrcCallCanisterRequestParams, 'sender'>;\n    options: SignerOptions;\n  }): Promise<icrc21_consent_message_response | ConsentInfoWarn> {\n    try {\n      return await this.callConsentMessage(params);\n    } catch (err: unknown) {\n      const fallbackMessage = await this.tryBuildConsentMessageOnError(params);\n\n      if ('Warn' in fallbackMessage) {\n        return fallbackMessage;\n      }\n\n      throw err;\n    }\n  }\n\n  /**\n   * Attempts to build a consent message when the signer cannot decode the arguments\n   * with the targeted canister. When decoding is attempted locally, user must be warned\n   * as specified by the ICRC-49 standards.\n   *\n   * Instead of returning \"Ok\" upon success, this function returns \"Warn\" to indicate\n   * that the signer performed the decoding rather than the canister.\n   *\n   * @see {@link https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_49_call_canister.md#message-processing ICRC-49 Message Processing}\n   *\n   * @param {Object} params - The parameters for building the consent message.\n   * @param {Object} params.params - The ICRC call canister parameters excluding the sender.\n   * @param {string} params.params.method - The method being called on the canister.\n   * @param {string} params.params.arg - The encoded arguments for the canister call.\n   * @param {string} params.params.canisterId - The ID of the targeted canister.\n   * @param {Object} params.options - The signer options including host and owner.\n   * @param {string} params.options.owner - The principal ID of the signer (caller).\n   * @param {string} params.options.host - The host URL for the signer environment.\n   *\n   * @returns {Promise<{NoFallback: null} | ConsentInfoWarn | {Err: unknown}>} -\n   *          - `{NoFallback: null}` if no fallback method is available.\n   *          - `ConsentInfoWarn` if a warning response is built successfully.\n   *          - `{Err: unknown}` if an error occurs during processing.\n   *\n   * @throws {Error} - Throws an error if building the consent message fails completely.\n   */\n  private async tryBuildConsentMessageOnError({\n    params: {method, arg, canisterId},\n    options: {owner, host}\n  }: {\n    params: Omit<IcrcCallCanisterRequestParams, 'sender'>;\n    options: SignerOptions;\n  }): Promise<{NoFallback: null} | ConsentInfoWarn | {Err: unknown}> {\n    const fn = SIGNER_BUILDERS[method];\n\n    if (isNullish(fn)) {\n      return {NoFallback: null};\n    }\n\n    try {\n      const tokenResponse = await this.#signerApi.ledgerMetadata({\n        params: {canisterId},\n        host,\n        owner\n      });\n\n      const token = mapTokenMetadata(tokenResponse);\n\n      if (isNullish(token)) {\n        return {Err: new Error('Incomplete token metadata.')};\n      }\n\n      const result = await fn({\n        arg: uint8ToBuf(base64ToUint8Array(arg)),\n        token,\n        owner: owner.getPrincipal()\n      });\n\n      if ('Err' in result) {\n        return {Err: result.Err};\n      }\n\n      return {\n        Warn: {\n          consentInfo: result.Ok,\n          method,\n          arg,\n          canisterId\n        }\n      };\n    } catch (err: unknown) {\n      return {Err: err};\n    }\n  }\n}\n", "import {IcrcLedgerCanister} from '@dfinity/ledger-icrc';\nimport type {IcrcTokenMetadataResponse} from '@dfinity/ledger-icrc/dist/types/types/ledger.responses';\nimport {Principal} from '@dfinity/principal';\nimport {arrayBufferToUint8Array, uint8ArrayToBase64} from '@dfinity/utils';\nimport {encode} from '../agent/agentjs-cbor-copy';\nimport type {CustomHttpAgentResponse} from '../agent/custom-http-agent';\nimport type {IcrcCallCanisterRequestParams} from '../types/icrc-requests';\nimport type {IcrcCallCanisterResult} from '../types/icrc-responses';\nimport type {SignerOptions} from '../types/signer-options';\nimport {Icrc21Canister} from './icrc21-canister.api';\n\nexport class SignerApi extends Icrc21Canister {\n  async call({\n    owner,\n    host,\n    params: {canisterId, method, arg, nonce}\n  }: {\n    params: IcrcCallCanisterRequestParams;\n  } & SignerOptions): Promise<IcrcCallCanisterResult> {\n    const agent = await this.getCustomAgent({host, owner});\n\n    const result = await agent.request({\n      canisterId,\n      method,\n      arg,\n      nonce\n    });\n\n    return this.encodeResult(result);\n  }\n\n  async ledgerMetadata({\n    host,\n    owner,\n    params: {canisterId}\n  }: {\n    params: Pick<IcrcCallCanisterRequestParams, 'canisterId'>;\n  } & SignerOptions): Promise<IcrcTokenMetadataResponse> {\n    const {agent} = await this.getDefaultAgent({host, owner});\n\n    // TODO: improve performance by caching the IcrcLedgerCanister?\n    const {metadata} = IcrcLedgerCanister.create({\n      agent,\n      canisterId: Principal.fromText(canisterId)\n    });\n\n    return await metadata({certified: true});\n  }\n\n  private encodeResult({\n    requestDetails: contentMap,\n    certificate\n  }: CustomHttpAgentResponse): IcrcCallCanisterResult {\n    const encodedCertificate = uint8ArrayToBase64(\n      arrayBufferToUint8Array(encode(certificate.cert))\n    );\n\n    const encodedContentMap = uint8ArrayToBase64(arrayBufferToUint8Array(encode(contentMap)));\n\n    return {\n      certificate: encodedCertificate,\n      contentMap: encodedContentMap\n    };\n  }\n}\n", "/* eslint-disable */\n\n/**\n * \u26A0\uFE0F !!!WARNING!!! \u26A0\uFE0F\n * This module is a copy/paste of the CBOR module, which is not exposed by Agent-js.\n * It is not covered by any tests (\u203C\uFE0F) in this library and contain multiple issues (\u203C\uFE0F) based on ESLint results.\n */\n\n// This file is based on:\n// https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses\nimport {concat, fromHex, toHex, uint8ToBuf} from '@dfinity/agent';\nimport {Principal} from '@dfinity/principal';\nimport borc from 'borc';\nimport * as cbor from 'simple-cbor';\nimport {CborEncoder, SelfDescribeCborSerializer} from 'simple-cbor';\n\n// We are using hansl/simple-cbor for CBOR serialization, to avoid issues with\n// encoding the uint64 values that the HTTP handler of the client expects for\n// canister IDs. However, simple-cbor does not yet provide deserialization so\n// we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR\n// decoder.\n\nclass PrincipalEncoder implements CborEncoder<Principal> {\n  public get name() {\n    return 'Principal';\n  }\n\n  public get priority() {\n    return 0;\n  }\n\n  public match(value: any): boolean {\n    return value && value._isPrincipal === true;\n  }\n\n  public encode(v: Principal): cbor.CborValue {\n    return cbor.value.bytes(uint8ToBuf(v.toUint8Array()));\n  }\n}\n\nclass BufferEncoder implements CborEncoder<ArrayBuffer> {\n  public get name() {\n    return 'Buffer';\n  }\n\n  public get priority() {\n    return 1;\n  }\n\n  public match(value: any): boolean {\n    return value instanceof ArrayBuffer || ArrayBuffer.isView(value);\n  }\n\n  public encode(v: ArrayBuffer): cbor.CborValue {\n    return cbor.value.bytes(v);\n  }\n}\n\nclass BigIntEncoder implements CborEncoder<BigInt> {\n  public get name() {\n    return 'BigInt';\n  }\n\n  public get priority() {\n    return 1;\n  }\n\n  public match(value: any): boolean {\n    return typeof value === `bigint`;\n  }\n\n  public encode(v: bigint): cbor.CborValue {\n    // Always use a bigint encoding.\n    if (v > BigInt(0)) {\n      return cbor.value.tagged(2, cbor.value.bytes(fromHex(v.toString(16))));\n    } else {\n      return cbor.value.tagged(3, cbor.value.bytes(fromHex((BigInt('-1') * v).toString(16))));\n    }\n  }\n}\n\nconst serializer = SelfDescribeCborSerializer.withDefaultEncoders(true);\nserializer.addEncoder(new PrincipalEncoder());\nserializer.addEncoder(new BufferEncoder());\nserializer.addEncoder(new BigIntEncoder());\n\nexport enum CborTag {\n  Uint64LittleEndian = 71,\n  Semantic = 55799\n}\n\n/**\n * Encode a JavaScript value into CBOR.\n */\nexport function encode(value: any): ArrayBuffer {\n  return serializer.serialize(value);\n}\n\nfunction decodePositiveBigInt(buf: Uint8Array): bigint {\n  const len = buf.byteLength;\n  let res = BigInt(0);\n  for (let i = 0; i < len; i++) {\n    res = res * BigInt(0x100) + BigInt(buf[i]);\n  }\n\n  return res;\n}\n\n// A BORC subclass that decodes byte strings to ArrayBuffer instead of the Buffer class.\nclass Uint8ArrayDecoder extends borc.Decoder {\n  public createByteString(raw: ArrayBuffer[]): ArrayBuffer {\n    return concat(...raw);\n  }\n\n  public createByteStringFromHeap(start: number, end: number): ArrayBuffer {\n    if (start === end) {\n      return new ArrayBuffer(0);\n    }\n\n    // @ts-ignore TS2740: Type Uint8Array<any> is missing the following properties from type ArrayBuffer\n    return new Uint8Array((this as any)._heap.slice(start, end));\n  }\n}\n\nexport function decode<T>(input: ArrayBuffer): T {\n  const buffer = new Uint8Array(input);\n  const decoder = new Uint8ArrayDecoder({\n    size: buffer.byteLength,\n    tags: {\n      // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).\n      2: (val) => decodePositiveBigInt(val),\n      3: (val) => -decodePositiveBigInt(val),\n      [CborTag.Semantic]: (value: T): T => value\n    }\n  });\n\n  try {\n    // @ts-ignore incorrect types - Uint8Array excepted by decodeFirst\n    return decoder.decodeFirst(buffer);\n  } catch (e: unknown) {\n    throw new Error(`Failed to decode CBOR: ${e}, input: ${toHex(uint8ToBuf(buffer))}`);\n  }\n}\n", "import {Actor, type ActorMethod, type ActorSubclass} from '@dfinity/agent';\nimport type {IDL} from '@dfinity/candid';\nimport {Principal} from '@dfinity/principal';\nimport {isNullish} from '@dfinity/utils';\nimport type {PrincipalText} from '@dfinity/zod-schemas';\nimport type {\n  _SERVICE as Icrc21Actor,\n  icrc21_consent_message_request,\n  icrc21_consent_message_response\n} from '../declarations/icrc-21';\n// eslint-disable-next-line import/no-relative-parent-imports\nimport {idlFactory} from '../declarations/icrc-21.idl';\nimport type {SignerOptions} from '../types/signer-options';\nimport {AgentApi} from './agent.api';\n\nexport class Icrc21Canister extends AgentApi {\n  #actors: Record<PrincipalText, ActorSubclass<Icrc21Actor>> | undefined;\n\n  async consentMessage({\n    request,\n    ...actorParams\n  }: {\n    canisterId: string | Principal;\n    request: icrc21_consent_message_request;\n  } & SignerOptions): Promise<icrc21_consent_message_response> {\n    const {icrc21_canister_call_consent_message: canisterCallConsentMessage} =\n      await this.getIcrc21Actor(actorParams);\n    return await canisterCallConsentMessage(request);\n  }\n\n  protected async getIcrc21Actor({\n    canisterId,\n    ...rest\n  }: {\n    canisterId: string | Principal;\n  } & SignerOptions): Promise<Icrc21Actor> {\n    const id = canisterId instanceof Principal ? canisterId.toText() : canisterId;\n\n    const {[id]: icrc21Actor} = this.#actors ?? {[id]: undefined};\n\n    if (isNullish(icrc21Actor)) {\n      const actor = await this.createActor<Icrc21Actor>({\n        canisterId,\n        idlFactory,\n        ...rest\n      });\n\n      this.#actors = {\n        ...(this.#actors ?? {}),\n        [id]: actor\n      };\n\n      return actor;\n    }\n\n    return icrc21Actor;\n  }\n\n  private async createActor<T = Record<string, ActorMethod>>({\n    canisterId,\n    idlFactory,\n    owner,\n    host\n  }: {\n    canisterId: string | Principal;\n    idlFactory: IDL.InterfaceFactory;\n  } & SignerOptions): Promise<ActorSubclass<T>> {\n    const {agent} = await this.getDefaultAgent({host, owner});\n\n    return await Actor.createActor(idlFactory, {\n      agent,\n      canisterId\n    });\n  }\n}\n", "/* Do not edit.  Compiled with ./scripts/compile-idl-js from src/declarations/icrc-21.did */\nexport const idlFactory = ({IDL}) => {\n  const icrc21_consent_message_metadata = IDL.Record({\n    utc_offset_minutes: IDL.Opt(IDL.Int16),\n    language: IDL.Text\n  });\n  const icrc21_consent_message_spec = IDL.Record({\n    metadata: icrc21_consent_message_metadata,\n    device_spec: IDL.Opt(\n      IDL.Variant({\n        GenericDisplay: IDL.Null,\n        LineDisplay: IDL.Record({\n          characters_per_line: IDL.Nat16,\n          lines_per_page: IDL.Nat16\n        })\n      })\n    )\n  });\n  const icrc21_consent_message_request = IDL.Record({\n    arg: IDL.Vec(IDL.Nat8),\n    method: IDL.Text,\n    user_preferences: icrc21_consent_message_spec\n  });\n  const icrc21_consent_message = IDL.Variant({\n    LineDisplayMessage: IDL.Record({\n      pages: IDL.Vec(IDL.Record({lines: IDL.Vec(IDL.Text)}))\n    }),\n    GenericDisplayMessage: IDL.Text\n  });\n  const icrc21_consent_info = IDL.Record({\n    metadata: icrc21_consent_message_metadata,\n    consent_message: icrc21_consent_message\n  });\n  const icrc21_error_info = IDL.Record({description: IDL.Text});\n  const icrc21_error = IDL.Variant({\n    GenericError: IDL.Record({\n      description: IDL.Text,\n      error_code: IDL.Nat\n    }),\n    InsufficientPayment: icrc21_error_info,\n    UnsupportedCanisterCall: icrc21_error_info,\n    ConsentMessageUnavailable: icrc21_error_info\n  });\n  const icrc21_consent_message_response = IDL.Variant({\n    Ok: icrc21_consent_info,\n    Err: icrc21_error\n  });\n  return IDL.Service({\n    icrc10_supported_standards: IDL.Func(\n      [],\n      [IDL.Vec(IDL.Record({url: IDL.Text, name: IDL.Text}))],\n      ['query']\n    ),\n    icrc21_canister_call_consent_message: IDL.Func(\n      [icrc21_consent_message_request],\n      [icrc21_consent_message_response],\n      []\n    )\n  });\n};\nexport const init = ({IDL}) => {\n  return [];\n};\n", "import {isNullish} from '@dfinity/utils';\nimport {CustomHttpAgent} from '../agent/custom-http-agent'; // Corrected import path\nimport {HttpAgentProvider} from '../agent/http-agent-provider';\nimport {MAINNET_REPLICA_URL} from '../constants/core.constants';\nimport type {SignerOptions} from '../types/signer-options';\n\nexport abstract class AgentApi {\n  #agents: Record<string, HttpAgentProvider> | undefined = undefined;\n\n  private async getAgent({\n    options,\n    type\n  }: {\n    options: SignerOptions;\n    type: 'default' | 'custom';\n  }): Promise<HttpAgentProvider | CustomHttpAgent> {\n    const {owner} = options;\n    const key = `${owner.getPrincipal().toText()}_${type}`;\n\n    if (isNullish(this.#agents) || isNullish(this.#agents[key])) {\n      const agent = await this.createAgent({options, type});\n\n      this.#agents = {\n        ...(this.#agents ?? {}),\n        [key]: agent\n      };\n\n      return agent;\n    }\n\n    return this.#agents[key];\n  }\n\n  private async createAgent({\n    options: {owner: identity, host},\n    type\n  }: {\n    options: SignerOptions;\n    type: 'default' | 'custom';\n  }): Promise<HttpAgentProvider | CustomHttpAgent> {\n    const {hostname} = new URL(host ?? MAINNET_REPLICA_URL);\n    const shouldFetchRootKey = ['localhost', '127.0.0.1'].includes(hostname);\n    const createOptions = {\n      identity,\n      host: host ?? MAINNET_REPLICA_URL,\n      shouldFetchRootKey\n    };\n\n    if (type === 'default') {\n      return await HttpAgentProvider.create(createOptions);\n    }\n    return await CustomHttpAgent.create(createOptions);\n  }\n\n  /**\n   *Returns a default `HttpAgentProvider` instance for the given signer options.\n   *This agent does not overwrite any default features provided by agent-js.\n   *\n   * @param {SignerOptions} options - The signer configuration including identity and host.\n   * @returns {Promise<HttpAgentProvider>} - A promise that resolves to a default agent instance.\n   */\n  protected async getDefaultAgent(options: SignerOptions): Promise<HttpAgentProvider> {\n    return (await this.getAgent({options, type: 'default'})) as HttpAgentProvider;\n  }\n\n  /**\n   * Returns a `CustomHttpAgent` instance for the given signer options.\n   * This agent uses custom transforms that are notably used to handle nonce in calls.\n   *\n   * @param {SignerOptions} options - The signer configuration including identity and host.\n   * @returns {Promise<CustomHttpAgent>} - A promise that resolves to a custom agent instance.\n   */\n  protected async getCustomAgent(options: SignerOptions): Promise<CustomHttpAgent> {\n    return (await this.getAgent({options, type: 'custom'})) as CustomHttpAgent;\n  }\n}\n", "import {\n  Certificate,\n  HttpAgent,\n  defaultStrategy,\n  lookupResultToBuffer,\n  pollForResponse as pollForResponseAgent,\n  uint8ToBuf,\n  type CallRequest,\n  type HttpAgentOptions,\n  type SubmitResponse\n} from '@dfinity/agent';\nimport {bufFromBufLike} from '@dfinity/candid';\nimport {Principal} from '@dfinity/principal';\nimport {base64ToUint8Array, isNullish, nonNullish} from '@dfinity/utils';\nimport type {IcrcCallCanisterRequestParams} from '../types/icrc-requests';\nimport {customAddTransform} from './custom-transform-agent';\nimport {HttpAgentProvider} from './http-agent-provider';\n\nexport type CustomHttpAgentResponse = Pick<Required<SubmitResponse>, 'requestDetails'> & {\n  certificate: Certificate;\n};\n\nexport class UndefinedRequestDetailsError extends Error {}\nexport class RequestError extends Error {}\nexport class InvalidCertificateReplyError extends Error {}\nexport class InvalidCertificateStatusError extends Error {}\nexport class UndefinedRootKeyError extends Error {}\n\nexport class CustomHttpAgent extends HttpAgentProvider {\n  private constructor(agent: HttpAgent) {\n    super(agent);\n    this._agent.addTransform('update', customAddTransform());\n  }\n\n  static async create(\n    options?: HttpAgentOptions & {shouldFetchRootKey?: boolean}\n  ): Promise<CustomHttpAgent> {\n    const agent = await HttpAgent.create(options);\n    return new CustomHttpAgent(agent);\n  }\n\n  request = async ({\n    arg,\n    canisterId,\n    method: methodName,\n    nonce\n  }: Omit<IcrcCallCanisterRequestParams, 'sender'>): Promise<CustomHttpAgentResponse> => {\n    const {requestDetails, ...restResponse} = await this._agent.call(canisterId, {\n      methodName,\n      arg: uint8ToBuf(base64ToUint8Array(arg)),\n      // effectiveCanisterId is optional but, actually mandatory according SDK team.\n      effectiveCanisterId: canisterId,\n      nonce: nonNullish(nonce) ? base64ToUint8Array(nonce) : undefined\n    });\n\n    this.assertRequestDetails(requestDetails);\n\n    if (isNullish(requestDetails)) {\n      throw new UndefinedRequestDetailsError();\n    }\n\n    const result = await this.readResponse({\n      callResponse: {requestDetails, ...restResponse},\n      canisterId\n    });\n\n    // I assume that if we get a result at this point, it means we can respond to the caller.\n    // However, this is not how it's handled in Agent-js. For some reason, regardless of whether they get a result at this point or not, if the response has a status of 202, they overwrite the result with pollForResponse, which seems incorrect.\n    // That is why we return the result if we get one.\n    // @see agent-js: https://github.com/dfinity/agent-js/blob/21cf4700eff1de7f6f15304b758a16e5881afca3/packages/agent/src/actor.ts#L567\n    if (nonNullish(result)) {\n      return result;\n    }\n\n    const {\n      response: {status}\n    } = restResponse;\n\n    // Fall back to polling if we receive an Accepted response code\n    if (status === 202) {\n      return await this.pollForResponse({\n        callResponse: {requestDetails, ...restResponse},\n        canisterId\n      });\n    }\n\n    throw new RequestError();\n  };\n\n  private async readResponse({\n    callResponse: {\n      requestId,\n      response: {body, status},\n      requestDetails\n    },\n    canisterId\n  }: {callResponse: Required<SubmitResponse>} & Pick<\n    IcrcCallCanisterRequestParams,\n    'canisterId'\n  >): Promise<CustomHttpAgentResponse | undefined> {\n    // Certificate is only support in v3.\n    if (isNullish(body) || !('certificate' in body)) {\n      return undefined;\n    }\n\n    // A response with a body.certificate is valid only for status 200 according specification\n    // https://github.com/dfinity/interface-spec/pull/265\n    if (status !== 200) {\n      throw new InvalidCertificateStatusError();\n    }\n\n    // I'm not sure why we don't check the response status, 202, before trying to search for a certificate. This seems inaccurate, but that's how Agent-js handles it.\n    // @see agent-js: https://github.com/dfinity/agent-js/blob/21cf4700eff1de7f6f15304b758a16e5881afca3/packages/agent/src/actor.ts#L545\n\n    const {certificate: cert} = body;\n\n    if (isNullish(this._agent.rootKey)) {\n      throw new UndefinedRootKeyError();\n    }\n\n    const certificate = await Certificate.create({\n      certificate: bufFromBufLike(cert),\n      rootKey: this._agent.rootKey,\n      canisterId: Principal.fromText(canisterId)\n    });\n\n    const {result: replyCheck} = this.assertReply({\n      certificate,\n      requestId\n    });\n\n    if (replyCheck !== 'valid') {\n      throw new InvalidCertificateReplyError();\n    }\n\n    return {certificate, requestDetails};\n  }\n\n  private assertRequestDetails(\n    requestDetails?: CallRequest\n  ): requestDetails is NonNullable<CallRequest> {\n    return nonNullish(requestDetails);\n  }\n\n  private assertReply({\n    certificate,\n    requestId\n  }: {certificate: Certificate} & Pick<SubmitResponse, 'requestId'>): {\n    result: 'valid' | 'invalid' | 'rejected' | 'empty';\n  } {\n    const path = [uint8ToBuf(new TextEncoder().encode('request_status')), requestId];\n\n    const status = new TextDecoder().decode(\n      lookupResultToBuffer(certificate.lookup([...path, 'status']))\n    );\n\n    switch (status) {\n      case 'replied':\n        // ESLint disabled because this code is copy/pasted without changes from agent-js.\n        // eslint-disable-next-line no-case-declarations\n        const reply = lookupResultToBuffer(certificate.lookup([...path, 'reply']));\n        return {result: nonNullish(reply) ? 'valid' : 'invalid'};\n      case 'rejected':\n        return {result: 'rejected'};\n      default:\n        // I'm not sure why undefined would be an acceptable result for this default implementation, but that's what Agent-js does.\n        // However, we consider it as not expected and we will throw an error if we get this.\n        return {result: 'empty'};\n    }\n  }\n\n  private async pollForResponse({\n    callResponse: {requestId, requestDetails},\n    canisterId\n  }: {callResponse: Pick<Required<SubmitResponse>, 'requestId' | 'requestDetails'>} & Pick<\n    IcrcCallCanisterRequestParams,\n    'canisterId'\n  >): Promise<CustomHttpAgentResponse> {\n    const {certificate} = await pollForResponseAgent(\n      this._agent,\n      Principal.fromText(canisterId),\n      requestId,\n      defaultStrategy()\n    );\n\n    return {certificate, requestDetails};\n  }\n}\n", "import type {Expiry, HttpAgentRequest, HttpAgentRequestTransformFn} from '@dfinity/agent';\nimport {hashObject, isNullish, nowInBigIntNanoSeconds, uint8ArrayToBase64} from '@dfinity/utils';\nimport type {HexString} from '../types/hex-string';\nimport type {IcrcCallCanisterRequestParams} from '../types/icrc-requests';\n\n/**\n * A custom transform function that processes the HTTP agent request.\n *\n * This transform function is intended to be used with the HttpAgent. It caches the expiry\n * time of requests based on a hash of the request data and checks whether the cache is expired.\n * If the cache is expired, it throws an error. If the cache is not expired, it reuses the cached\n * expiry value.\n *\n * @returns {HttpAgentRequestTransformFn} The transform function that processes the request.\n */\nexport const customAddTransform = (): HttpAgentRequestTransformFn => {\n  const cache: Map<HexString, Expiry> = new Map();\n\n  return async (request: HttpAgentRequest) => {\n    const {canister_id, sender, method_name, arg, ingress_expiry, nonce} = request.body;\n\n    /* If no nonce is provided, we don't need to cache or check expiry, so we return the request as is.\n     This behavior is by design, as nonces are necessary for identifying unique requests and ensuring\n     cache correctness.\n    */\n    if (isNullish(nonce)) {\n      return request;\n    }\n\n    const hashRequestData: IcrcCallCanisterRequestParams = {\n      canisterId: canister_id.toString(),\n      sender: sender.toString(),\n      method: method_name,\n      arg: uint8ArrayToBase64(arg),\n      nonce: uint8ArrayToBase64(nonce)\n    };\n\n    const hash = await hashObject(hashRequestData);\n    const cachedExpiry = cache.get(hash);\n\n    if (isNullish(cachedExpiry)) {\n      cache.set(hash, ingress_expiry);\n      return request;\n    }\n\n    if (cachedExpiry['_value'] <= nowInBigIntNanoSeconds()) {\n      throw Error(\n        'The request has expired and is no longer valid. Please try again with a new request.'\n      );\n    }\n\n    request.body.ingress_expiry = cachedExpiry;\n\n    return request;\n  };\n};\n", "import {HttpAgent, type HttpAgentOptions} from '@dfinity/agent';\n\n/**\n * HttpAgentProvider class provides access to the HttpAgent instance and\n * allows initialization and retrieval of the agent.\n */\nexport class HttpAgentProvider {\n  protected _agent: HttpAgent;\n\n  protected constructor(agent: HttpAgent) {\n    this._agent = agent;\n  }\n\n  /**\n   * Creates an HttpAgentProvider with the provided options.\n   * Optionally, you can request fetching of the root key with `shouldFetchRootKey`.\n   *\n   * @param {HttpAgentOptions} options - The options to configure the HttpAgent.\n   * @param {boolean} [options.shouldFetchRootKey] - A flag indicating if the root key should be fetched.\n   * @returns {Promise<HttpAgentProvider>} A promise that resolves to a new instance of HttpAgentProvider.\n   */\n  static async create(\n    options?: HttpAgentOptions & {shouldFetchRootKey?: boolean}\n  ): Promise<HttpAgentProvider> {\n    const agent = await HttpAgent.create(options);\n    return new HttpAgentProvider(agent);\n  }\n\n  /**\n   * We need to expose the agent to create the actor for requesting the consent message.\n   */\n  get agent(): HttpAgent {\n    return this._agent;\n  }\n}\n", "export const DEFAULT_POLLING_INTERVAL_IN_MILLISECONDS = 500;\n\nexport const LOCAL_REPLICA_URL = 'http://localhost:4943';\nexport const MAINNET_REPLICA_URL = 'https://icp-api.io';\n", "import {encodeIcrcAccount} from '@dfinity/ledger-icrc';\nimport {fromNullable, isNullish, nonNullish} from '@dfinity/utils';\nimport {TransferArgs} from '../constants/icrc-1.idl.constants';\nimport {ApproveArgs, TransferFromArgs} from '../constants/icrc-2.idl.constants';\nimport {MAX_CONSENT_MESSAGE_ARG_SIZE_BYTES} from '../constants/signer.builders.constants';\nimport type {TransferArgs as IcrcTransferArg} from '../declarations/icrc-1';\nimport type {\n  ApproveArgs as IcrcApproveArgs,\n  TransferFromArgs as IcrcTransferFromArgs\n} from '../declarations/icrc-2';\nimport type {icrc21_consent_info} from '../declarations/icrc-21';\nimport type {I18n} from '../types/i18n';\nimport type {\n  SignerBuilderFn,\n  SignerBuilderParams,\n  SignerBuildersResult\n} from '../types/signer-builders';\nimport {decodeMemo} from '../utils/builders.utils';\nimport {formatAmount, formatDate} from '../utils/format.utils';\nimport {decodeIdl} from '../utils/idl.utils';\n\n/**\n * Builds a content message for an ICRC-1 transfer by decoding the arguments for a potential call.\n * This is used as a workaround when the targeted canister does not comply with the ICRC-21 standard \u2014 i.e. it has not implemented the related endpoints.\n *\n * The implementation is similar to the Markdown generated by the ICRC ledger implementation.\n * @link https://github.com/dfinity/ic/blob/master/packages/icrc-ledger-types/src/icrc21/lib.rs#L153\n *\n * @param {Object} params - Parameters for building the consent message.\n * @param {Uint8Array} params.arg - Encoded arguments for the ICRC-1 transfer.\n * @param {Principal} params.owner - Principal ID of the sender (owner) account.\n * @param {Object} params.token - Token metadata including symbol, decimals, and fee.\n * @param {string} params.token.symbol - The symbol of the token.\n * @param {number} params.token.decimals - The number of decimals for the token.\n * @param {bigint} params.token.fee - Default fee for the token.\n * @returns {Promise<SignerBuildersResult>} - A result containing either the consent message or an error.\n *\n **/\nexport const buildContentMessageIcrc1Transfer: SignerBuilderFn = async ({\n  arg,\n  owner,\n  token: {symbol: tokenSymbol, decimals: tokenDecimals, fee: tokenFee}\n}): Promise<SignerBuildersResult> => {\n  const build = (en: I18n): {message: string[]} => {\n    const {\n      amount,\n      from_subaccount: fromSubaccount,\n      to: {owner: toOwner, subaccount: toSubaccount},\n      fee,\n      memo\n    } = decodeIdl<IcrcTransferArg>({\n      recordClass: TransferArgs,\n      bytes: arg\n    });\n\n    const {\n      core: {amount: amountLabel, from, to, fee: feeLabel},\n      icrc1_transfer: {title}\n    } = en;\n\n    // Title\n    const message = [`# ${title}`];\n\n    // - Amount\n    message.push(\n      `${section(amountLabel)}\\n${formatAmount({amount, decimals: tokenDecimals})} ${tokenSymbol}`\n    );\n\n    // - From\n    const fromNullishSubaccount = fromNullable(fromSubaccount);\n    const fromAccount = encodeIcrcAccount({\n      owner,\n      subaccount: fromNullishSubaccount\n    });\n    message.push(`${section(from)}\\n${fromAccount}`);\n\n    // - To\n    const toAccount = encodeIcrcAccount({\n      owner: toOwner,\n      subaccount: fromNullable(toSubaccount)\n    });\n    message.push(`${section(to)}\\n${toAccount}`);\n\n    // - Fee\n    message.push(\n      `${section(feeLabel)}\\n${formatAmount({amount: fromNullable(fee) ?? tokenFee, decimals: tokenDecimals})} ${tokenSymbol}`\n    );\n\n    // - Memo\n    const memoMessage = buildMemo({\n      memo,\n      en\n    });\n\n    return {message: [...message, ...memoMessage]};\n  };\n\n  return await buildContentMessage({arg, fn: build});\n};\n\n/**\n * Builds a content message for an ICRC-2 Approve by decoding the arguments for a potential call.\n * This is used as a workaround when the targeted canister does not comply with the ICRC-21 standard \u2014 i.e. it has not implemented the related endpoints.\n *\n * The implementation is similar to the Markdown generated by the ICRC ledger implementation.\n * @link https://github.com/dfinity/ic/blob/master/packages/icrc-ledger-types/src/icrc21/lib.rs#L194\n *\n * @param {Object} params - Parameters for building the consent message.\n * @param {Uint8Array} params.arg - Encoded arguments for the ICRC-2 approve.\n * @param {Principal} params.owner - Principal ID of the sender (owner) account.\n * @param {Object} params.token - Token metadata including symbol, decimals, and fee.\n * @param {string} params.token.symbol - The symbol of the token.\n * @param {number} params.token.decimals - The number of decimals for the token.\n * @param {bigint} params.token.fee - Default fee for the token.\n * @returns {Promise<SignerBuildersResult>} - A result containing either the consent message or an error.\n *\n **/\nexport const buildContentMessageIcrc2Approve: SignerBuilderFn = async ({\n  arg,\n  owner,\n  token: {symbol: tokenSymbol, decimals: tokenDecimals, fee: tokenFee}\n}): Promise<SignerBuildersResult> => {\n  const build = (en: I18n): {message: string[]} => {\n    const {\n      spender: {owner: spenderOwner, subaccount: spenderSubaccount},\n      from_subaccount: fromSubaccount,\n      amount,\n      expected_allowance,\n      expires_at,\n      fee: approveFee,\n      memo\n    } = decodeIdl<IcrcApproveArgs>({\n      recordClass: ApproveArgs,\n      bytes: arg\n    });\n\n    const {\n      icrc2_approve: {\n        title,\n        address_is_allowed,\n        your_account,\n        requested_withdrawal_allowance,\n        withdrawal_allowance: {none: withdrawalAllowanceNone, some: withdrawalAllowanceSome},\n        expiration_date: {title: expirationDateTitle, none: noExpirationDate},\n        approval_fee: approvalFeeLabel,\n        approver_account_transaction_fees\n      }\n    } = en;\n\n    // Title\n    const message = [`# ${title}`];\n\n    // - Spender\n    const spenderAccount = encodeIcrcAccount({\n      owner: spenderOwner,\n      subaccount: fromNullable(spenderSubaccount)\n    });\n    message.push(`${section(address_is_allowed)}\\n${spenderAccount}`);\n\n    // - Approver\n    const fromNullishSubaccount = fromNullable(fromSubaccount);\n    const fromAccount = encodeIcrcAccount({\n      owner,\n      subaccount: fromNullishSubaccount\n    });\n    message.push(`${section(your_account)}\\n${fromAccount}`);\n\n    // - Amount\n    message.push(\n      `${section(requested_withdrawal_allowance)}\\n${formatAmount({amount, decimals: tokenDecimals})} ${tokenSymbol}`\n    );\n\n    // - Expected allowance\n    const expectedAllowance = fromNullable(expected_allowance);\n    if (nonNullish(expectedAllowance)) {\n      message.push(\n        `${section(withdrawalAllowanceSome)}\\n${formatAmount({amount: expectedAllowance, decimals: tokenDecimals})} ${tokenSymbol}`\n      );\n    } else {\n      message.push(\n        `\u26A0 ${withdrawalAllowanceNone\n          .replace('{amount}', formatAmount({amount, decimals: tokenDecimals}))\n          .replace('{symbol}', tokenSymbol)}`\n      );\n    }\n\n    // - Expires at\n    const expiresAt = fromNullable(expires_at);\n    message.push(\n      `${section(expirationDateTitle)}\\n${nonNullish(expiresAt) ? formatDate(expiresAt) : noExpirationDate}`\n    );\n\n    // - Fee\n    message.push(\n      `${section(approvalFeeLabel)}\\n${formatAmount({amount: fromNullable(approveFee) ?? tokenFee, decimals: tokenDecimals})} ${tokenSymbol}`\n    );\n\n    // - Fee paid by\n    message.push(`${section(approver_account_transaction_fees)}\\n${fromAccount}`);\n\n    // - Memo\n    const memoMessage = buildMemo({\n      memo,\n      en\n    });\n\n    return {message: [...message, ...memoMessage]};\n  };\n\n  return await buildContentMessage({arg, fn: build});\n};\n\n/**\n * Builds a content message for an ICRC-2 TransferFrom by decoding the arguments for a potential call.\n * This is used as a workaround when the targeted canister does not comply with the ICRC-21 standard \u2014 i.e. it has not implemented the related endpoints.\n *\n * The implementation is similar to the Markdown generated by the ICRC ledger implementation.\n * @link https://github.com/dfinity/ic/blob/master/packages/icrc-ledger-types/src/icrc21/lib.rs#L287\n *\n * @param {Object} params - Parameters for building the consent message.\n * @param {Uint8Array} params.arg - Encoded arguments for the ICRC-2 transfer from.\n * @param {Principal} params.owner - Principal ID of the sender (owner) account.\n * @param {Object} params.token - Token metadata including symbol, decimals, and fee.\n * @param {string} params.token.symbol - The symbol of the token.\n * @param {number} params.token.decimals - The number of decimals for the token.\n * @param {bigint} params.token.fee - Default fee for the token.\n * @returns {Promise<SignerBuildersResult>} - A result containing either the consent message or an error.\n *\n **/\nexport const buildContentMessageIcrc2TransferFrom: SignerBuilderFn = async ({\n  arg,\n  owner,\n  token: {symbol: tokenSymbol, decimals: tokenDecimals, fee: tokenFee}\n}): Promise<SignerBuildersResult> => {\n  const build = (en: I18n): {message: string[]} => {\n    const {\n      from: {owner: fromOwner, subaccount: fromSubaccount},\n      to: {owner: toOwner, subaccount: toSubaccount},\n      spender_subaccount: spenderSubaccount,\n      amount,\n      fee,\n      memo\n    } = decodeIdl<IcrcTransferFromArgs>({\n      recordClass: TransferFromArgs,\n      bytes: arg\n    });\n\n    const {\n      core: {to},\n      icrc2_transfer_from: {\n        title,\n        withdrawal_account,\n        sending_the_transfer_request,\n        amount_to_withdraw,\n        fee_paid_by_withdrawal_account\n      }\n    } = en;\n\n    // Title\n    const message = [`# ${title}`];\n\n    // - From\n    const fromAccount = encodeIcrcAccount({\n      owner: fromOwner,\n      subaccount: fromNullable(fromSubaccount)\n    });\n    message.push(`${section(withdrawal_account)}\\n${fromAccount}`);\n\n    // - Spender\n    const spenderNullishSubaccount = fromNullable(spenderSubaccount);\n    const spenderAccount = encodeIcrcAccount({\n      owner,\n      subaccount: spenderNullishSubaccount\n    });\n    message.push(`${section(sending_the_transfer_request)}\\n${spenderAccount}`);\n\n    // - Amount\n    message.push(\n      `${section(amount_to_withdraw)}\\n${formatAmount({amount, decimals: tokenDecimals})} ${tokenSymbol}`\n    );\n\n    // - To\n    const toAccount = encodeIcrcAccount({\n      owner: toOwner,\n      subaccount: fromNullable(toSubaccount)\n    });\n    message.push(`${section(to)}\\n${toAccount}`);\n\n    // - Fee paid by\n    message.push(\n      `${section(fee_paid_by_withdrawal_account)}\\n${formatAmount({amount: fromNullable(fee) ?? tokenFee, decimals: tokenDecimals})} ${tokenSymbol}`\n    );\n\n    // - Memo\n    const memoMessage = buildMemo({\n      memo,\n      en\n    });\n\n    return {message: [...message, ...memoMessage]};\n  };\n\n  return await buildContentMessage({arg, fn: build});\n};\n\nconst section = (text: string): string => `**${text}:**`;\n\nconst buildMemo = ({memo, en}: {memo: [] | [Uint8Array | number[]]; en: I18n}): [] | [string] => {\n  const nullishMemo = fromNullable(memo);\n\n  if (isNullish(nullishMemo)) {\n    return [];\n  }\n\n  const {\n    core: {memo: memoLabel}\n  } = en;\n\n  return [`${section(memoLabel)}\\n${decodeMemo(nullishMemo)}`];\n};\n\nconst buildContentMessage = async ({\n  fn,\n  arg\n}: Pick<SignerBuilderParams, 'arg'> & {\n  fn: (en: I18n) => {message: string[]};\n}): Promise<SignerBuildersResult> => {\n  try {\n    assertArgSize({arg});\n\n    // TODO: support i18n\n    // eslint-disable-next-line import/no-relative-parent-imports\n    const {default: en} = await import('../i18n/en.json');\n\n    const {message} = fn(en);\n\n    const consentMessage: icrc21_consent_info = {\n      metadata: {\n        language: 'en',\n        utc_offset_minutes: []\n      },\n      consent_message: {\n        GenericDisplayMessage: message.join('\\n\\n')\n      }\n    };\n\n    return {Ok: consentMessage};\n  } catch (err: unknown) {\n    return {Err: err};\n  }\n};\n\nexport class ArgSizeError extends Error {}\n\n/**\n * Validates the size of the argument to prevent issues with the Candid parser.\n *\n * A similar assertion is implemented in the ICP ledger for building the consent message.\n *\n * @see {@link https://github.com/dfinity/ic/blob/master/packages/icrc-ledger-types/src/icrc21/lib.rs#L426}\n *\n * @param {object} params - The parameters for the function.\n * @param {ArrayBuffer} params.arg - The argument to validate, represented as an ArrayBuffer.\n * @throws {Error} Throws an error if the argument size exceeds the maximum allowed size.\n */\nconst assertArgSize = ({arg}: Pick<SignerBuilderParams, 'arg'>) => {\n  if (arg.byteLength > MAX_CONSENT_MESSAGE_ARG_SIZE_BYTES) {\n    throw new ArgSizeError(\n      `The argument size is too large. The maximum allowed size is ${MAX_CONSENT_MESSAGE_ARG_SIZE_BYTES} bytes.`\n    );\n  }\n};\n", "import {IDL} from '@dfinity/candid';\n\n/**\n * TODO: All the constants of this module should be exposed by the IDL files - i.e. should be generated as exposed by didc\n */\n\nconst Subaccount = IDL.Vec(IDL.Nat8);\nconst Account = IDL.Record({\n  owner: IDL.Principal,\n  subaccount: IDL.Opt(Subaccount)\n});\n\nconst Timestamp = IDL.Nat64;\n\nexport const TransferArgs = IDL.Record({\n  to: Account,\n  fee: IDL.Opt(IDL.Nat),\n  memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n  from_subaccount: IDL.Opt(Subaccount),\n  created_at_time: IDL.Opt(Timestamp),\n  amount: IDL.Nat\n});\n\nexport const TransferError = IDL.Variant({\n  GenericError: IDL.Record({\n    message: IDL.Text,\n    error_code: IDL.Nat\n  }),\n  TemporarilyUnavailable: IDL.Null,\n  BadBurn: IDL.Record({min_burn_amount: IDL.Nat}),\n  Duplicate: IDL.Record({duplicate_of: IDL.Nat}),\n  BadFee: IDL.Record({expected_fee: IDL.Nat}),\n  CreatedInFuture: IDL.Record({ledger_time: Timestamp}),\n  TooOld: IDL.Null,\n  InsufficientFunds: IDL.Record({balance: IDL.Nat})\n});\n\nexport const TransferResult = IDL.Variant({Ok: IDL.Nat, Err: TransferError});\n", "import {IDL} from '@dfinity/candid';\n\n/**\n * TODO: All the constants of this module should be exposed by the IDL files - i.e. should be generated as exposed by didc\n */\n\nconst Account = IDL.Record({\n  owner: IDL.Principal,\n  subaccount: IDL.Opt(IDL.Vec(IDL.Nat8))\n});\n\nexport const ApproveArgs = IDL.Record({\n  fee: IDL.Opt(IDL.Nat),\n  memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n  from_subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)),\n  created_at_time: IDL.Opt(IDL.Nat64),\n  amount: IDL.Nat,\n  expected_allowance: IDL.Opt(IDL.Nat),\n  expires_at: IDL.Opt(IDL.Nat64),\n  spender: Account\n});\n\nexport const TransferFromArgs = IDL.Record({\n  to: Account,\n  fee: IDL.Opt(IDL.Nat),\n  spender_subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)),\n  from: Account,\n  memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n  created_at_time: IDL.Opt(IDL.Nat64),\n  amount: IDL.Nat\n});\n\nconst ApproveError = IDL.Variant({\n  GenericError: IDL.Record({\n    message: IDL.Text,\n    error_code: IDL.Nat\n  }),\n  TemporarilyUnavailable: IDL.Null,\n  Duplicate: IDL.Record({duplicate_of: IDL.Nat}),\n  BadFee: IDL.Record({expected_fee: IDL.Nat}),\n  AllowanceChanged: IDL.Record({current_allowance: IDL.Nat}),\n  CreatedInFuture: IDL.Record({ledger_time: IDL.Nat64}),\n  TooOld: IDL.Null,\n  Expired: IDL.Record({ledger_time: IDL.Nat64}),\n  InsufficientFunds: IDL.Record({balance: IDL.Nat})\n});\n\nconst TransferFromError = IDL.Variant({\n  GenericError: IDL.Record({\n    message: IDL.Text,\n    error_code: IDL.Nat\n  }),\n  TemporarilyUnavailable: IDL.Null,\n  InsufficientAllowance: IDL.Record({allowance: IDL.Nat}),\n  BadBurn: IDL.Record({min_burn_amount: IDL.Nat}),\n  Duplicate: IDL.Record({duplicate_of: IDL.Nat}),\n  BadFee: IDL.Record({expected_fee: IDL.Nat}),\n  CreatedInFuture: IDL.Record({ledger_time: IDL.Nat64}),\n  TooOld: IDL.Null,\n  InsufficientFunds: IDL.Record({balance: IDL.Nat})\n});\n\nexport const ApproveResult = IDL.Variant({Ok: IDL.Nat, Err: ApproveError});\nexport const TransferFromResult = IDL.Variant({Ok: IDL.Nat, Err: TransferFromError});\n", "import {arrayOfNumberToUint8Array, uint8ArrayToHexString} from '@dfinity/utils';\n\n/**\n * Decodes a memo into an utf-8 string. If decoding fails, fallback to hex.\n *\n * This is similar to how the decoder for consent messages of the ICP ledger handles the memo.\n *\n * @see {@link https://github.com/dfinity/ic/blob/master/packages/icrc-ledger-types/src/icrc21/lib.rs#L348}\n *\n * @param {Uint8Array | number[]} memo - The memo to decode. It can be either a `Uint8Array` or an array of numbers.\n * @returns {string} The decoded string if successful, or the hexadecimal string representation if decoding fails.\n */\nexport const decodeMemo = (memo: Uint8Array | number[]): string => {\n  const memoArray = memo instanceof Uint8Array ? memo : arrayOfNumberToUint8Array(memo);\n\n  try {\n    return new TextDecoder('utf-8').decode(memoArray);\n  } catch (_err: unknown) {\n    return `0x${uint8ArrayToHexString(memo)}`;\n  }\n};\n", "export const formatAmount = ({amount, decimals}: {amount: bigint; decimals: number}): string => {\n  const converted = Number(amount) / 10 ** decimals;\n\n  // For ease of readability we want to display two decimals at least but, handle edge case where ledgers have none or 1 decimal set.\n  const minimumFractionDigits = decimals >= 1 ? 1 : decimals;\n\n  return new Intl.NumberFormat('en-US', {\n    minimumFractionDigits,\n    maximumFractionDigits: decimals\n  }).format(converted);\n};\n\nexport const formatDate = (nanoseconds: bigint): string => {\n  const options: Intl.DateTimeFormatOptions = {\n    weekday: 'short',\n    month: 'short',\n    day: 'numeric',\n    year: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n    timeZone: 'UTC',\n    timeZoneName: 'short'\n  };\n\n  const date = new Date(Number(nanoseconds / 1_000_000n));\n  return date.toLocaleDateString('en', options);\n};\n", "import {IDL} from '@dfinity/candid';\nimport type {RecordClass, VariantClass} from '@dfinity/candid/lib/cjs/idl';\nimport {uint8ArrayToBase64} from '@dfinity/utils';\nimport type {IcrcBlob} from '../types/blob';\n\nexport const encodeIdl = <T>({\n  recordClass,\n  rawArgs\n}: {\n  recordClass: RecordClass | VariantClass;\n  rawArgs: T;\n}): IcrcBlob => uint8ArrayToBase64(new Uint8Array(IDL.encode([recordClass], [rawArgs])));\n\nexport const decodeIdl = <T>({\n  recordClass,\n  bytes\n}: {\n  recordClass: RecordClass | VariantClass;\n  bytes: ArrayBuffer;\n}): T => {\n  const result = IDL.decode([recordClass], bytes);\n\n  if (result.length !== 1) {\n    throw new Error('More than one object returned. This is unexpected.');\n  }\n\n  // We have to use another ugly type cast because IDL.decode does not accept generics. Additionally, the agent-js implementation does not provide any hints, as its decodeReturnValue relies on the type 'any,' which is bad practice.\n  const [response] = result as unknown as [T];\n  return response;\n};\n", "import {\n  buildContentMessageIcrc1Transfer,\n  buildContentMessageIcrc2Approve,\n  buildContentMessageIcrc2TransferFrom\n} from '../builders/signer.builders';\nimport type {SignerBuilderFn, SignerBuilderMethods} from '../types/signer-builders';\n\n// @see {@link https://github.com/dfinity/ic/blob/master/packages/icrc-ledger-types/src/icrc21/lib.rs#L20}\nexport const MAX_CONSENT_MESSAGE_ARG_SIZE_BYTES = 500;\n\nexport const SIGNER_BUILDERS: Record<SignerBuilderMethods, SignerBuilderFn> = {\n  icrc1_transfer: buildContentMessageIcrc1Transfer,\n  icrc2_approve: buildContentMessageIcrc2Approve,\n  icrc2_transfer_from: buildContentMessageIcrc2TransferFrom\n};\n", "import type {icrc21_error} from '../declarations/icrc-21';\n\nexport const mapIcrc21ErrorToString = (error: icrc21_error): string => {\n  if ('GenericError' in error) {\n    return `Error: ${error.GenericError.description} (Code: ${error.GenericError.error_code})`;\n  }\n\n  if ('InsufficientPayment' in error) {\n    return `Insufficient Payment: ${error.InsufficientPayment.description}`;\n  }\n\n  if ('UnsupportedCanisterCall' in error) {\n    return `Unsupported Canister Call: ${error.UnsupportedCanisterCall.description}`;\n  }\n\n  if ('ConsentMessageUnavailable' in error) {\n    return `Consent Message Unavailable: ${error.ConsentMessageUnavailable.description}`;\n  }\n\n  return 'Unknown error';\n};\n", "import type {Principal} from '@dfinity/principal';\nimport {isNullish} from '@dfinity/utils';\nimport {ICRC25_PERMISSION_ASK_ON_USE} from '../constants/icrc.constants';\nimport {SIGNER_PERMISSION_VALIDITY_PERIOD_IN_MILLISECONDS} from '../constants/signer.constants';\nimport type {IcrcScopesArray} from '../types/icrc-responses';\nimport type {IcrcPermissionState, IcrcScopedMethod} from '../types/icrc-standards';\nimport type {Origin} from '../types/post-message';\nimport type {SignerOptions} from '../types/signer-options';\nimport type {SessionIcrcScope, SessionPermissions} from '../types/signer-sessions';\nimport {get, set} from '../utils/storage.utils';\n\nconst KEY_PREFIX = 'oisy_signer';\n\ninterface SessionIdentifier {\n  owner: Principal;\n  origin: Origin;\n}\n\nconst key = ({owner, origin}: SessionIdentifier): string =>\n  `${KEY_PREFIX}_${origin}_${owner.toText()}`;\n\nexport const saveSessionScopes = ({\n  scopes,\n  ...rest\n}: SessionIdentifier & {\n  scopes: IcrcScopesArray;\n}): void => {\n  const permissionKey = key(rest);\n\n  const permissions = get<SessionPermissions>({key: permissionKey});\n\n  const retainScopes = (permissions?.scopes ?? []).filter(\n    ({scope: {method: existingMethod}}) =>\n      scopes.find(({scope: {method}}) => existingMethod === method) === undefined\n  );\n\n  const now = Date.now();\n\n  const updateScopes = scopes.reduce<SessionIcrcScope[]>(\n    (acc, {scope: {method, ...scopeRest}, ...rest}) => {\n      const existingScope: SessionIcrcScope | undefined = (permissions?.scopes ?? []).find(\n        ({scope: {method: existingMethod}}) => existingMethod === method\n      );\n\n      return [\n        ...acc,\n        {\n          ...rest,\n          scope: {\n            ...scopeRest,\n            method\n          },\n          createdAt: existingScope?.createdAt ?? now,\n          updatedAt: now\n        }\n      ];\n    },\n    []\n  );\n\n  const updatedPermissions: SessionPermissions = {\n    scopes: [...retainScopes, ...updateScopes],\n    createdAt: permissions?.createdAt ?? now,\n    updatedAt: now\n  };\n\n  // TODO: To prevent overwriting permissions when the user has multiple wallets open in different windows, we should ensure that permissions are not overwritten by asserting based on their timestamps.\n  set({key: permissionKey, value: updatedPermissions});\n};\n\nexport const readSessionValidScopes = ({\n  sessionOptions,\n  ...params\n}: SessionIdentifier & Pick<SignerOptions, 'sessionOptions'>): IcrcScopesArray | undefined => {\n  const permissions = get<SessionPermissions>({key: key(params)});\n\n  if (isNullish(permissions)) {\n    return undefined;\n  }\n\n  // TODO: We can improve the UX by \"tracking\" when the user is using a feature of the signer.\n  // For example:\n  // 1. Checking if the signer was last used within the past seven days.\n  // 2. Comparing the creation date was granted within the last 30 days.\n  return permissions.scopes\n    .filter(\n      ({updatedAt}) =>\n        updatedAt >=\n        Date.now() -\n          (sessionOptions?.sessionPermissionExpirationInMilliseconds ??\n            SIGNER_PERMISSION_VALIDITY_PERIOD_IN_MILLISECONDS)\n    )\n    .map(({updatedAt: _, createdAt: __, ...rest}) => ({...rest}));\n};\n\nexport const sessionScopeState = ({\n  method,\n  ...rest\n}: SessionIdentifier & {method: IcrcScopedMethod}): IcrcPermissionState => {\n  const scopes = readSessionValidScopes(rest);\n\n  return (\n    scopes?.find(({scope: {method: m}}) => m === method)?.state ?? ICRC25_PERMISSION_ASK_ON_USE\n  );\n};\n", "import {nonNullish} from '@dfinity/utils';\n\nexport const set = <T>({key, value}: {key: string; value: T}): void => {\n  try {\n    localStorage.setItem(key, JSON.stringify(value));\n  } catch (err: unknown) {\n    // We use local storage to save the signer's permissions for convenience and to improve the UX.\n    // If this fails, meaning permissions are not saved in storage, the user will always be prompted about the permissions.\n    console.error(err);\n  }\n};\n\nexport const del = ({key}: {key: string}): void => {\n  try {\n    localStorage.removeItem(key);\n  } catch (err: unknown) {\n    // See comment in set.error\n    console.error(err);\n  }\n};\n\nexport const get = <T>({key}: {key: string}): T | undefined => {\n  try {\n    const value = localStorage.getItem(key);\n    return nonNullish(value) ? JSON.parse(value) : undefined;\n  } catch (err: unknown) {\n    // See comment in set.error\n    console.error(err);\n    return undefined;\n  }\n};\n", "import {base64ToUint8Array, isNullish} from '@dfinity/utils';\nimport {PrincipalTextSchema} from '@dfinity/zod-schemas';\nimport * as z from 'zod/v4';\nimport {\n  ICRC25_PERMISSIONS,\n  ICRC25_REQUEST_PERMISSIONS,\n  ICRC25_SUPPORTED_STANDARDS,\n  ICRC27_ACCOUNTS,\n  ICRC29_STATUS,\n  ICRC49_CALL_CANISTER\n} from '../constants/icrc.constants';\nimport {IcrcBlobSchema} from './blob';\nimport {IcrcScopedMethodSchema} from './icrc-standards';\nimport {inferRpcRequestWithParamsSchema, inferRpcRequestWithoutParamsSchema} from './rpc';\n\n// icrc25_request_permissions\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_request_permissions\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst IcrcRequestedScopesSchema = z.object({\n  scopes: z\n    .array(\n      z.object({\n        method: IcrcScopedMethodSchema\n      })\n    )\n    .min(1)\n});\n\nexport type IcrcRequestedScopes = z.infer<typeof IcrcRequestedScopesSchema>;\n\nconst IcrcAnyRequestedScopesSchema = z.object({\n  scopes: z\n    .array(\n      z.object({\n        // According to the specification, the relying party can request permissions for random, unspecified methods, and these should \"just\" be ignored by the wallet.\n        method: z.string()\n      })\n    )\n    .min(1)\n});\n\nexport type IcrcAnyRequestedScopes = z.infer<typeof IcrcAnyRequestedScopesSchema>;\n\nexport const IcrcRequestAnyPermissionsRequestSchema = inferRpcRequestWithParamsSchema({\n  method: ICRC25_REQUEST_PERMISSIONS,\n  params: IcrcAnyRequestedScopesSchema\n});\n\nexport type IcrcRequestAnyPermissionsRequest = z.infer<\n  typeof IcrcRequestAnyPermissionsRequestSchema\n>;\n\n// icrc25_permissions\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_permissions\nexport const IcrcPermissionsRequestSchema = inferRpcRequestWithoutParamsSchema({\n  method: ICRC25_PERMISSIONS\n});\n\nexport type IcrcPermissionsRequest = z.infer<typeof IcrcPermissionsRequestSchema>;\n\n// icrc25_supported_standards\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_supported_standards\nexport const IcrcSupportedStandardsRequestSchema = inferRpcRequestWithoutParamsSchema({\n  method: ICRC25_SUPPORTED_STANDARDS\n});\n\nexport type IcrcSupportedStandardsRequest = z.infer<typeof IcrcSupportedStandardsRequestSchema>;\n\n// icrc29_status\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_29_window_post_message_transport.md\nexport const IcrcStatusRequestSchema = inferRpcRequestWithoutParamsSchema({\n  method: ICRC29_STATUS\n});\n\nexport type IcrcStatusRequest = z.infer<typeof IcrcStatusRequestSchema>;\n\n// icrc27_accounts\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_27_accounts.md\nexport const IcrcAccountsRequestSchema = inferRpcRequestWithoutParamsSchema({\n  method: ICRC27_ACCOUNTS\n});\n\nexport type IcrcAccountsRequest = z.infer<typeof IcrcAccountsRequestSchema>;\n\n// icrc49_call_canister\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_49_call_canister.md\n\nconst MethodSchema = z.string().trim().min(1);\n\nexport type Method = z.infer<typeof MethodSchema>;\n\nexport const IcrcCallCanisterRequestParamsSchema = z.object({\n  canisterId: PrincipalTextSchema,\n  sender: PrincipalTextSchema,\n  method: MethodSchema,\n  arg: IcrcBlobSchema,\n  nonce: IcrcBlobSchema.optional().refine(\n    (blob) => {\n      try {\n        return isNullish(blob) || base64ToUint8Array(blob).length <= 32;\n      } catch (_err: unknown) {\n        return false;\n      }\n    },\n    {\n      message: 'Nonce must be a Uint8Array with a maximum length of 32 bytes'\n    }\n  )\n});\n\nexport type IcrcCallCanisterRequestParams = z.infer<typeof IcrcCallCanisterRequestParamsSchema>;\n\nexport const IcrcCallCanisterRequestSchema = inferRpcRequestWithParamsSchema({\n  method: ICRC49_CALL_CANISTER,\n  params: IcrcCallCanisterRequestParamsSchema\n});\n\nexport type IcrcCallCanisterRequest = z.infer<typeof IcrcCallCanisterRequestSchema>;\n", "import * as z from 'zod/v4';\n\nexport const IcrcBlobSchema = z.string().refine(\n  (val) => {\n    try {\n      return btoa(atob(val)) === val;\n    } catch (_err: unknown) {\n      return false;\n    }\n  },\n  {\n    message: 'Invalid base64 string'\n  }\n);\n\nexport type IcrcBlob = z.infer<typeof IcrcBlobSchema>;\n", "export class MissingPromptError extends Error {}\n", "import * as z from 'zod/v4';\nimport {\n  ICRC21_CALL_CONSENT_MESSAGE,\n  ICRC25_REQUEST_PERMISSIONS,\n  ICRC27_ACCOUNTS,\n  ICRC49_CALL_CANISTER\n} from '../constants/icrc.constants';\nimport type {icrc21_consent_info} from '../declarations/icrc-21';\nimport {createFunctionSchema} from '../utils/zod.utils';\nimport {IcrcAccountsSchema} from './icrc-accounts';\nimport {IcrcCallCanisterRequestParamsSchema} from './icrc-requests';\nimport {IcrcCallCanisterResultSchema, IcrcScopesArraySchema} from './icrc-responses';\nimport {OriginSchema} from './post-message';\n\n// Exposed for testing purposes\nexport const PromptMethodSchema = z.enum([\n  ICRC21_CALL_CONSENT_MESSAGE,\n  ICRC25_REQUEST_PERMISSIONS,\n  ICRC27_ACCOUNTS,\n  ICRC49_CALL_CANISTER\n]);\n\nexport interface Prompts {\n  [PromptMethodSchema.enum.icrc21_call_consent_message]: ConsentMessagePrompt;\n  [PromptMethodSchema.enum.icrc25_request_permissions]: PermissionsPrompt;\n  [PromptMethodSchema.enum.icrc27_accounts]: AccountsPrompt;\n  [PromptMethodSchema.enum.icrc49_call_canister]: CallCanisterPrompt;\n}\n\nexport interface RegisterPrompts<T extends keyof Prompts> {\n  method: T;\n  prompt: Prompts[T];\n}\n\nconst PayloadOriginSchema = z.object({\n  origin: OriginSchema\n});\n\nexport type PayloadOrigin = z.infer<typeof PayloadOriginSchema>;\n\nconst RejectionSchema = createFunctionSchema(z.function({output: z.void()}));\n\nexport type Rejection = z.infer<typeof RejectionSchema>;\n\nconst StatusSchema = z.enum(['result', 'error']);\n\nconst ErrorSchema = PayloadOriginSchema.extend({\n  status: z.literal(StatusSchema.enum.error),\n  details: z.unknown().optional()\n});\n\n// Prompt for permissions\n\nconst PermissionsConfirmationSchema = createFunctionSchema(\n  z.function({input: z.tuple([IcrcScopesArraySchema]), output: z.void()})\n);\n\nexport type PermissionsConfirmation = z.infer<typeof PermissionsConfirmationSchema>;\n\nconst PermissionsPromptPayloadSchema = PayloadOriginSchema.extend({\n  requestedScopes: IcrcScopesArraySchema,\n  confirm: PermissionsConfirmationSchema\n});\n\nexport type PermissionsPromptPayload = z.infer<typeof PermissionsPromptPayloadSchema>;\n\n/**\n * A function that is invoked when the signer requires the user to confirm (grant or deny) requested permissions.\n *\n * This function may be triggered in two scenarios:\n * 1. When the relying party explicitly requests permissions.\n * 2. When the relying party attempts to access a feature that requires permissions that have not yet been granted by the user.\n *\n * @param {PermissionsPromptPayload} params - An object containing the requested permissions and a function to confirm them.\n * @param {IcrcScopes[]} params.requestedScopes - An array of IcrcScopes representing the permissions being requested.\n * @param {PermissionsConfirmation} params.confirm - A function to be called by the consumer to confirm (grant or deny) the requested, a subset, or none of the permissions. Skipping a permission is equivalent to preserving its current state.\n */\nexport const PermissionsPromptSchema = createFunctionSchema(\n  z.function({\n    input: z.tuple([PermissionsPromptPayloadSchema]),\n    output: z.void()\n  })\n);\n\nexport type PermissionsPrompt = z.infer<typeof PermissionsPromptSchema>;\n\n// Prompt for accounts\n\nconst AccountsApprovalSchema = createFunctionSchema(\n  z.function({input: z.tuple([IcrcAccountsSchema]), output: z.void()})\n);\n\nexport type AccountsApproval = z.infer<typeof AccountsApprovalSchema>;\n\nconst AccountsPromptPayloadSchema = PayloadOriginSchema.extend({\n  approve: AccountsApprovalSchema,\n  reject: RejectionSchema\n});\n\nexport type AccountsPromptPayload = z.infer<typeof AccountsPromptPayloadSchema>;\n\n/**\n * A function that is invoked when the signer requires the user - or consumer of the library - to confirm (select or reject) accounts.\n *\n * @param {AccountsPromptPayload} params - An object containing a function to confirm the accounts.\n * @param {IcrcAccounts[]} params.approve - A function to be called by the consumer to confirm (select or reject) the provided accounts.\n */\nexport const AccountsPromptSchema = createFunctionSchema(\n  z.function({\n    input: z.tuple([AccountsPromptPayloadSchema]),\n    output: z.void()\n  })\n);\n\nexport type AccountsPrompt = z.infer<typeof AccountsPromptSchema>;\n\n// Prompt for consent message\n\nconst ConsentMessageApprovalSchema = createFunctionSchema(z.function({output: z.void()}));\n\nexport type ConsentMessageApproval = z.infer<typeof ConsentMessageApprovalSchema>;\n\nconst LoadingConsentMessageStatusSchema = z.enum(['loading']);\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst ConsentMessageStatusSchema = LoadingConsentMessageStatusSchema.or(StatusSchema);\n\nexport type ConsentMessageStatus = z.infer<typeof ConsentMessageStatusSchema>;\n\nconst LoadingConsentMessageSchema = PayloadOriginSchema.extend({\n  status: z.literal(LoadingConsentMessageStatusSchema.enum.loading)\n});\n\nconst ConsentInfoSchema = z.custom<icrc21_consent_info>();\n\nconst ConsentInfoOkSchema = z.object({\n  Ok: ConsentInfoSchema\n});\n\nexport type ConsentInfoOk = z.infer<typeof ConsentInfoOkSchema>;\n\nconst ConsentInfoWarnSchema = z.object({\n  Warn: IcrcCallCanisterRequestParamsSchema.pick({\n    canisterId: true,\n    method: true,\n    arg: true\n  }).extend({\n    consentInfo: ConsentInfoSchema\n  })\n});\n\nexport type ConsentInfoWarn = z.infer<typeof ConsentInfoWarnSchema>;\n\nconst ResultConsentInfoSchema = z.union([ConsentInfoOkSchema, ConsentInfoWarnSchema]);\n\nexport type ResultConsentInfo = z.infer<typeof ResultConsentInfoSchema>;\n\nconst ResultConsentMessageSchema = PayloadOriginSchema.extend({\n  status: z.literal(StatusSchema.enum.result),\n  consentInfo: ResultConsentInfoSchema,\n  approve: ConsentMessageApprovalSchema,\n  reject: RejectionSchema\n});\n\nexport type ResultConsentMessage = z.infer<typeof ResultConsentMessageSchema>;\n\nconst ConsentMessagePromptPayloadSchema = z.union([\n  LoadingConsentMessageSchema,\n  ResultConsentMessageSchema,\n  ErrorSchema\n]);\n\nexport type ConsentMessagePromptPayload = z.infer<typeof ConsentMessagePromptPayloadSchema>;\n\n/**\n * A function that is invoked when the signer requires the user - or consumer of the library - to approve or reject a consent message.\n *\n * @param {ConsentMessagePromptPayload} params - An object containing the consent information and functions to handle approval or rejection.\n * @param {icrc21_consent_info} params.consentInfo - An object containing the consent information that needs to be approved or rejected.\n * @param {() => void} params.approve - A function to be called by the consumer to approve the consent message.\n * @param {() => void} params.reject - A function to be called by the consumer to reject the consent message.\n */\nexport const ConsentMessagePromptSchema = createFunctionSchema(\n  z.function({\n    input: z.tuple([ConsentMessagePromptPayloadSchema]),\n    output: z.void()\n  })\n);\n\nexport type ConsentMessagePrompt = z.infer<typeof ConsentMessagePromptSchema>;\n\n// Prompt for call canister\n\nconst ExecutingCallCanisterStatusSchema = z.enum(['executing']);\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst CallCanisterStatusSchema = ExecutingCallCanisterStatusSchema.or(StatusSchema);\n\nexport type CallCanisterStatus = z.infer<typeof CallCanisterStatusSchema>;\n\nconst ExecutingCallCanisterSchema = PayloadOriginSchema.extend({\n  status: z.literal(ExecutingCallCanisterStatusSchema.enum.executing)\n});\n\nconst ResultCallCanisterSchema = z.intersection(\n  PayloadOriginSchema.extend({\n    status: z.literal(StatusSchema.enum.result)\n  }),\n  IcrcCallCanisterResultSchema\n);\n\nconst CallCanisterPromptPayloadSchema = z.union([\n  ExecutingCallCanisterSchema,\n  ResultCallCanisterSchema,\n  ErrorSchema\n]);\n\nexport type CallCanisterPromptPayload = z.infer<typeof CallCanisterPromptPayloadSchema>;\n\nexport const CallCanisterPromptSchema = createFunctionSchema(\n  z.function({\n    input: z.tuple([CallCanisterPromptPayloadSchema]),\n    output: z.void()\n  })\n);\n\nexport type CallCanisterPrompt = z.infer<typeof CallCanisterPromptSchema>;\n", "import * as z from 'zod/v4';\n\n/**\n * In Zod v4, functions are no longer treated as standard Zod schemas (see: https://zod.dev/v4/changelog?id=zfunction).\n * Since this library uses functions as schemas, we need a workaround to parse them.\n * This utility provides that workaround, following the approach recommended\n * in the Zod migration guide:\n * https://github.com/colinhacks/zod/issues/4143#issuecomment-2845134912\n *\n * Note: The downside of this workaround is that using `safeParse` to validate a function schema\n * will throw an error instead of returning a success or failure result. However, since our implementation\n * exclusively uses `parse`, this utility is acceptable for our use case.\n */\nexport const createFunctionSchema = <T extends z.core.$ZodFunction>(schema: T) =>\n  z.custom<Parameters<T['implement']>[0]>((fn) =>\n    schema.implement(fn as Parameters<T['implement']>[0])\n  );\n", "import {base64ToUint8Array} from '@dfinity/utils';\nimport {PrincipalTextSchema} from '@dfinity/zod-schemas';\nimport * as z from 'zod/v4';\nimport {IcrcBlobSchema} from './blob';\n\nconst IcrcSubaccountSchema = IcrcBlobSchema.refine(\n  (value) => {\n    try {\n      return base64ToUint8Array(value).length === 32;\n    } catch (_err: unknown) {\n      return false;\n    }\n  },\n  {\n    message: 'Subaccount must be exactly 32 bytes long.'\n  }\n);\n\nexport const IcrcAccountSchema = z\n  .object({\n    owner: PrincipalTextSchema,\n    subaccount: IcrcSubaccountSchema.optional()\n  })\n  .strict();\n\nexport type IcrcAccount = z.infer<typeof IcrcAccountSchema>;\n\nexport const IcrcAccountsSchema = z.array(IcrcAccountSchema).min(1);\n\nexport type IcrcAccounts = z.infer<typeof IcrcAccountsSchema>;\n", "import {UrlSchema} from '@dfinity/zod-schemas';\nimport * as z from 'zod/v4';\nimport {IcrcBlobSchema} from './blob';\nimport {IcrcAccountsSchema} from './icrc-accounts';\nimport {\n  IcrcPermissionStateSchema,\n  IcrcScopedMethodSchema,\n  IcrcStandardSchema\n} from './icrc-standards';\nimport {inferRpcResponseSchema} from './rpc';\n\nconst IcrcScopeMethodSchema = z.object({\n  method: IcrcScopedMethodSchema\n});\n\nexport type IcrcScopeMethod = z.infer<typeof IcrcScopeMethodSchema>;\n\nexport const IcrcScopeSchema = z\n  .object({\n    scope: IcrcScopeMethodSchema,\n    state: IcrcPermissionStateSchema\n  })\n  .strict();\n\nexport type IcrcScope = z.infer<typeof IcrcScopeSchema>;\n\nexport const IcrcScopesArraySchema = z.array(IcrcScopeSchema);\n\nexport type IcrcScopesArray = z.infer<typeof IcrcScopesArraySchema>;\n\nexport const IcrcScopesSchema = z\n  .object({\n    scopes: IcrcScopesArraySchema\n  })\n  .strict();\n\nexport type IcrcScopes = z.infer<typeof IcrcScopesSchema>;\n\n// icrc25_request_permissions and icrc25_permissions\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_request_permissions\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_permissions\nexport const IcrcScopesResponseSchema = inferRpcResponseSchema(IcrcScopesSchema);\n\nexport type IcrcScopesResponse = z.infer<typeof IcrcScopesResponseSchema>;\n\n// icrc25_supported_standards\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_25_signer_interaction_standard.md#icrc25_supported_standards\nconst urlRegex =\n  /^https:\\/\\/github\\.com\\/dfinity\\/ICRC\\/blob\\/main\\/ICRCs\\/ICRC-\\d+\\/ICRC-\\d+\\.md$/;\n\nconst SupportedStandardsUrlSchema = z\n  .url()\n  .regex(urlRegex)\n  .refine(\n    (url) => {\n      try {\n        UrlSchema.parse(url);\n      } catch (_err: unknown) {\n        return false;\n      }\n\n      const match = /(ICRC-\\d+)\\.md/g.exec(url);\n\n      if (match === null) {\n        return false;\n      }\n\n      const [_, icrc] = match;\n\n      return Object.keys(IcrcStandardSchema.enum).includes(icrc);\n    },\n    {\n      message: 'The URL does not match any of the IcrcStandard values.'\n    }\n  );\n\nexport const IcrcSupportedStandardsSchema = z\n  .array(\n    z\n      .object({\n        name: IcrcStandardSchema,\n        url: SupportedStandardsUrlSchema\n      })\n      .strict()\n  )\n  .min(1);\n\nexport type IcrcSupportedStandards = z.infer<typeof IcrcSupportedStandardsSchema>;\n\nexport const IcrcSupportedStandardsResponseSchema = inferRpcResponseSchema(\n  z.object({\n    supportedStandards: IcrcSupportedStandardsSchema\n  })\n);\n\nexport type IcrcSupportedStandardsResponse = z.infer<typeof IcrcSupportedStandardsResponseSchema>;\n\n// icrc29_status\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_29_window_post_message_transport.md\n\nexport const IcrcReadyResponseSchema = inferRpcResponseSchema(z.literal('ready'));\n\nexport type IcrcReadyResponse = z.infer<typeof IcrcReadyResponseSchema>;\n\n// icrc27_accounts\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_27_accounts.md#icrc-27-get-accounts\n\nexport const IcrcAccountsResponseSchema = inferRpcResponseSchema(\n  z.object({\n    accounts: IcrcAccountsSchema\n  })\n);\n\nexport type IcrcAccountsResponse = z.infer<typeof IcrcAccountsResponseSchema>;\n\n// icrc49_call_canister\n// https://github.com/dfinity/wg-identity-authentication/blob/main/topics/icrc_49_call_canister.md\n\nexport const IcrcCallCanisterResultSchema = z\n  .object({\n    contentMap: IcrcBlobSchema,\n    certificate: IcrcBlobSchema\n  })\n  .strict();\n\nexport type IcrcCallCanisterResult = z.infer<typeof IcrcCallCanisterResultSchema>;\n\nexport const IcrcCallCanisterResponseSchema = inferRpcResponseSchema(\n  IcrcCallCanisterResultSchema.strict()\n);\n\nexport type IcrcCallCanisterResponse = z.infer<typeof IcrcCallCanisterResponseSchema>;\n", "import {UrlSchema} from '@dfinity/zod-schemas';\nimport type * as z from 'zod/v4';\n\nexport const OriginSchema = UrlSchema;\n\nexport type Origin = z.infer<typeof OriginSchema>;\n"],
  "mappings": "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",
  "names": ["require_en", "__commonJSMin", "exports", "module", "assertNonNullish", "isNullish", "nonNullish", "ICRC21_CALL_CONSENT_MESSAGE", "ICRC25_REQUEST_PERMISSIONS", "ICRC25_PERMISSIONS", "ICRC25_SUPPORTED_STANDARDS", "ICRC27_ACCOUNTS", "ICRC29_STATUS", "ICRC49_CALL_CANISTER", "ICRC25_PERMISSION_GRANTED", "ICRC25_PERMISSION_DENIED", "ICRC25_PERMISSION_ASK_ON_USE", "ICRC21", "ICRC25", "ICRC27", "ICRC29", "ICRC49", "z", "IcrcMethodSchema", "ICRC21_CALL_CONSENT_MESSAGE", "ICRC25_REQUEST_PERMISSIONS", "ICRC25_PERMISSIONS", "ICRC25_SUPPORTED_STANDARDS", "ICRC27_ACCOUNTS", "ICRC29_STATUS", "ICRC49_CALL_CANISTER", "IcrcScopedMethodSchema", "IcrcPermissionStateSchema", "ICRC25_PERMISSION_GRANTED", "ICRC25_PERMISSION_DENIED", "ICRC25_PERMISSION_ASK_ON_USE", "IcrcStandardSchema", "ICRC21", "ICRC25", "ICRC27", "ICRC29", "ICRC49", "SIGNER_SUPPORTED_STANDARDS", "IcrcStandardSchema", "name", "SIGNER_DEFAULT_SCOPES", "IcrcScopedMethodSchema", "method", "ICRC25_PERMISSION_ASK_ON_USE", "SIGNER_PERMISSION_VALIDITY_PERIOD_IN_MILLISECONDS", "z", "JSON_RPC_VERSION_2", "JsonRpcSchema", "RpcIdSchema", "RpcSchema", "RpcRequestSchema", "inferRpcRequestWithoutParamsSchema", "method", "inferRpcRequestWithParamsSchema", "params", "RpcNotificationSchema", "RpcErrorCode", "RpcResponseErrorCodeSchema", "RpcResponseErrorSchema", "RpcResponseSchema", "RpcResponseWithErrorSchema", "inferRpcResponseSchema", "result", "error", "RpcResponseWithResultOrErrorSchema", "notifyError", "id", "error", "origin", "notify", "JSON_RPC_VERSION_2", "msg", "notifyErrorRequestNotSupported", "message", "notify", "notifyError", "notifyErrorActionAborted", "notifyNetworkError", "notifyErrorPermissionNotGranted", "notifyErrorMissingPrompt", "notifyErrorSenderNotAllowed", "notifyErrorBusy", "notifyReady", "id", "origin", "notify", "JSON_RPC_VERSION_2", "notifySupportedStandards", "SIGNER_SUPPORTED_STANDARDS", "notifyPermissionScopes", "scopes", "notifyAccounts", "accounts", "notifyCallCanister", "result", "uint8ToBuf", "mapTokenMetadata", "Principal", "base64ToUint8Array", "isNullish", "notEmptyString", "IcrcLedgerCanister", "Principal", "arrayBufferToUint8Array", "uint8ArrayToBase64", "concat", "fromHex", "toHex", "uint8ToBuf", "borc", "cbor", "SelfDescribeCborSerializer", "PrincipalEncoder", "value", "v", "BufferEncoder", "BigIntEncoder", "serializer", "encode", "value", "serializer", "Uint8ArrayDecoder", "borc", "raw", "concat", "start", "end", "Actor", "Principal", "isNullish", "idlFactory", "IDL", "icrc21_consent_message_metadata", "icrc21_consent_message_spec", "icrc21_consent_message_request", "icrc21_consent_message", "icrc21_consent_info", "icrc21_error_info", "icrc21_error", "icrc21_consent_message_response", "isNullish", "Certificate", "HttpAgent", "defaultStrategy", "lookupResultToBuffer", "pollForResponseAgent", "uint8ToBuf", "bufFromBufLike", "Principal", "base64ToUint8Array", "isNullish", "nonNullish", "hashObject", "isNullish", "nowInBigIntNanoSeconds", "uint8ArrayToBase64", "customAddTransform", "cache", "request", "canister_id", "sender", "method_name", "arg", "ingress_expiry", "nonce", "hashRequestData", "hash", "cachedExpiry", "HttpAgent", "HttpAgentProvider", "_HttpAgentProvider", "agent", "options", "UndefinedRequestDetailsError", "RequestError", "InvalidCertificateReplyError", "InvalidCertificateStatusError", "UndefinedRootKeyError", "CustomHttpAgent", "_CustomHttpAgent", "HttpAgentProvider", "agent", "customAddTransform", "options", "HttpAgent", "arg", "canisterId", "methodName", "nonce", "requestDetails", "restResponse", "uint8ToBuf", "base64ToUint8Array", "nonNullish", "isNullish", "result", "status", "requestId", "body", "cert", "certificate", "Certificate", "bufFromBufLike", "Principal", "replyCheck", "path", "lookupResultToBuffer", "reply", "pollForResponseAgent", "defaultStrategy", "MAINNET_REPLICA_URL", "AgentApi", "#agents", "options", "type", "owner", "key", "isNullish", "agent", "identity", "host", "hostname", "MAINNET_REPLICA_URL", "shouldFetchRootKey", "createOptions", "HttpAgentProvider", "CustomHttpAgent", "Icrc21Canister", "AgentApi", "#actors", "request", "actorParams", "canisterCallConsentMessage", "canisterId", "rest", "id", "Principal", "icrc21Actor", "isNullish", "actor", "idlFactory", "owner", "host", "agent", "Actor", "SignerApi", "Icrc21Canister", "owner", "host", "canisterId", "method", "arg", "nonce", "result", "agent", "metadata", "IcrcLedgerCanister", "Principal", "contentMap", "certificate", "encodedCertificate", "uint8ArrayToBase64", "arrayBufferToUint8Array", "encode", "encodedContentMap", "encodeIcrcAccount", "fromNullable", "isNullish", "nonNullish", "IDL", "Subaccount", "Account", "Timestamp", "TransferArgs", "TransferError", "TransferResult", "IDL", "Account", "ApproveArgs", "TransferFromArgs", "ApproveError", "TransferFromError", "ApproveResult", "TransferFromResult", "arrayOfNumberToUint8Array", "uint8ArrayToHexString", "decodeMemo", "memo", "memoArray", "formatAmount", "amount", "decimals", "converted", "minimumFractionDigits", "formatDate", "nanoseconds", "options", "IDL", "uint8ArrayToBase64", "decodeIdl", "recordClass", "bytes", "result", "IDL", "response", "buildContentMessageIcrc1Transfer", "arg", "owner", "tokenSymbol", "tokenDecimals", "tokenFee", "buildContentMessage", "en", "amount", "fromSubaccount", "toOwner", "toSubaccount", "fee", "memo", "decodeIdl", "TransferArgs", "amountLabel", "from", "to", "feeLabel", "title", "message", "section", "formatAmount", "fromNullishSubaccount", "fromNullable", "fromAccount", "encodeIcrcAccount", "toAccount", "memoMessage", "buildMemo", "buildContentMessageIcrc2Approve", "spenderOwner", "spenderSubaccount", "expected_allowance", "expires_at", "approveFee", "ApproveArgs", "address_is_allowed", "your_account", "requested_withdrawal_allowance", "withdrawalAllowanceNone", "withdrawalAllowanceSome", "expirationDateTitle", "noExpirationDate", "approvalFeeLabel", "approver_account_transaction_fees", "spenderAccount", "expectedAllowance", "nonNullish", "expiresAt", "formatDate", "buildContentMessageIcrc2TransferFrom", "fromOwner", "TransferFromArgs", "withdrawal_account", "sending_the_transfer_request", "amount_to_withdraw", "fee_paid_by_withdrawal_account", "spenderNullishSubaccount", "text", "nullishMemo", "isNullish", "memoLabel", "decodeMemo", "fn", "assertArgSize", "err", "ArgSizeError", "MAX_CONSENT_MESSAGE_ARG_SIZE_BYTES", "MAX_CONSENT_MESSAGE_ARG_SIZE_BYTES", "SIGNER_BUILDERS", "buildContentMessageIcrc1Transfer", "buildContentMessageIcrc2Approve", "buildContentMessageIcrc2TransferFrom", "mapIcrc21ErrorToString", "error", "SignerService", "#signerApi", "SignerApi", "sender", "params", "prompt", "notify", "owner", "host", "senderMatchOwner", "isNullish", "notifyErrorMissingPrompt", "origin", "response", "Err", "notifyErrorRequestNotSupported", "mapIcrc21ErrorToString", "result", "notifyErrorActionAborted", "err", "options", "notifyCallCanister", "notifyNetworkError", "notEmptyString", "Principal", "notifyErrorSenderNotAllowed", "canisterId", "method", "arg", "base64ToUint8Array", "payload", "resolve", "fallbackMessage", "fn", "SIGNER_BUILDERS", "tokenResponse", "token", "mapTokenMetadata", "uint8ToBuf", "isNullish", "nonNullish", "set", "key", "value", "err", "get", "key", "value", "nonNullish", "err", "KEY_PREFIX", "key", "owner", "origin", "saveSessionScopes", "scopes", "rest", "permissionKey", "permissions", "get", "retainScopes", "existingMethod", "method", "now", "updateScopes", "acc", "scopeRest", "existingScope", "updatedPermissions", "set", "readSessionValidScopes", "sessionOptions", "params", "isNullish", "updatedAt", "SIGNER_PERMISSION_VALIDITY_PERIOD_IN_MILLISECONDS", "_", "__", "sessionScopeState", "m", "ICRC25_PERMISSION_ASK_ON_USE", "base64ToUint8Array", "isNullish", "PrincipalTextSchema", "z", "z", "IcrcBlobSchema", "val", "IcrcRequestedScopesSchema", "IcrcScopedMethodSchema", "IcrcAnyRequestedScopesSchema", "IcrcRequestAnyPermissionsRequestSchema", "inferRpcRequestWithParamsSchema", "ICRC25_REQUEST_PERMISSIONS", "IcrcPermissionsRequestSchema", "inferRpcRequestWithoutParamsSchema", "ICRC25_PERMISSIONS", "IcrcSupportedStandardsRequestSchema", "ICRC25_SUPPORTED_STANDARDS", "IcrcStatusRequestSchema", "ICRC29_STATUS", "IcrcAccountsRequestSchema", "ICRC27_ACCOUNTS", "MethodSchema", "IcrcCallCanisterRequestParamsSchema", "PrincipalTextSchema", "IcrcBlobSchema", "blob", "isNullish", "base64ToUint8Array", "IcrcCallCanisterRequestSchema", "ICRC49_CALL_CANISTER", "MissingPromptError", "z", "z", "createFunctionSchema", "schema", "fn", "base64ToUint8Array", "PrincipalTextSchema", "z", "IcrcSubaccountSchema", "IcrcBlobSchema", "value", "base64ToUint8Array", "IcrcAccountSchema", "PrincipalTextSchema", "IcrcAccountsSchema", "UrlSchema", "z", "IcrcScopeMethodSchema", "IcrcScopedMethodSchema", "IcrcScopeSchema", "IcrcPermissionStateSchema", "IcrcScopesArraySchema", "IcrcScopesSchema", "IcrcScopesResponseSchema", "inferRpcResponseSchema", "urlRegex", "SupportedStandardsUrlSchema", "url", "UrlSchema", "match", "_", "icrc", "IcrcStandardSchema", "IcrcSupportedStandardsSchema", "IcrcSupportedStandardsResponseSchema", "IcrcReadyResponseSchema", "IcrcAccountsResponseSchema", "IcrcAccountsSchema", "IcrcCallCanisterResultSchema", "IcrcBlobSchema", "IcrcCallCanisterResponseSchema", "UrlSchema", "OriginSchema", "PromptMethodSchema", "ICRC21_CALL_CONSENT_MESSAGE", "ICRC25_REQUEST_PERMISSIONS", "ICRC27_ACCOUNTS", "ICRC49_CALL_CANISTER", "PayloadOriginSchema", "OriginSchema", "RejectionSchema", "createFunctionSchema", "StatusSchema", "ErrorSchema", "PermissionsConfirmationSchema", "IcrcScopesArraySchema", "PermissionsPromptPayloadSchema", "PermissionsPromptSchema", "AccountsApprovalSchema", "IcrcAccountsSchema", "AccountsPromptPayloadSchema", "AccountsPromptSchema", "ConsentMessageApprovalSchema", "LoadingConsentMessageStatusSchema", "ConsentMessageStatusSchema", "LoadingConsentMessageSchema", "ConsentInfoSchema", "ConsentInfoOkSchema", "ConsentInfoWarnSchema", "IcrcCallCanisterRequestParamsSchema", "ResultConsentInfoSchema", "ResultConsentMessageSchema", "ConsentMessagePromptPayloadSchema", "ConsentMessagePromptSchema", "ExecutingCallCanisterStatusSchema", "CallCanisterStatusSchema", "ExecutingCallCanisterSchema", "ResultCallCanisterSchema", "IcrcCallCanisterResultSchema", "CallCanisterPromptPayloadSchema", "CallCanisterPromptSchema", "Signer", "_Signer", "#signerOptions", "#walletOrigin", "#permissionsPrompt", "#accountsPrompt", "#consentMessagePrompt", "#callCanisterPrompt", "#busy", "#signerService", "SignerService", "options", "message", "data", "origin", "success", "requestData", "RpcRequestSchema", "handledReadOnly", "busy", "handled", "notifyErrorRequestNotSupported", "statusRequestHandled", "supportedStandardsRequestHandled", "valid", "permissionsHandled", "requestsPermissionsHandled", "accountsHandled", "callCanisterHandled", "nonNullish", "msgData", "notifyError", "notifyErrorBusy", "handler", "isNullish", "method", "prompt", "ICRC21_CALL_CONSENT_MESSAGE", "ConsentMessagePromptSchema", "ICRC25_REQUEST_PERMISSIONS", "PermissionsPromptSchema", "ICRC27_ACCOUNTS", "AccountsPromptSchema", "ICRC49_CALL_CANISTER", "CallCanisterPromptSchema", "rest", "isStatusRequest", "statusData", "IcrcStatusRequestSchema", "id", "notifyReady", "isSupportedStandardsRequest", "supportedStandardsData", "IcrcSupportedStandardsRequestSchema", "notifySupportedStandards", "isPermissionsRequestRequest", "permissionsRequestData", "IcrcPermissionsRequestSchema", "isRequestPermissionsRequest", "requestPermissionsData", "IcrcRequestAnyPermissionsRequestSchema", "requestId", "requestedScopes", "supportedRequestedScopes", "requestedMethod", "IcrcScopedMethodSchema", "IcrcPermissionStateSchema", "methodA", "methodB", "promptFn", "confirmedScopes", "payload", "resolve", "reject", "confirm", "scopes", "MissingPromptError", "assertNonNullish", "owner", "sessionOptions", "readSessionValidScopes", "allScopes", "SIGNER_DEFAULT_SCOPES", "defaultMethod", "notifyPermissionScopes", "notifyErrorMissingPrompt", "saveSessionScopes", "isAccountsRequest", "accountsData", "IcrcAccountsRequestSchema", "notifyAccounts", "result", "accounts", "notifyErrorActionAborted", "ICRC25_PERMISSION_DENIED", "notifyErrorPermissionNotGranted", "ICRC25_PERMISSION_GRANTED", "err", "userReject", "approve", "isCallCanisterRequest", "callData", "IcrcCallCanisterRequestSchema", "params", "notify", "userConsent", "currentPermission", "sessionScopeState", "ICRC25_PERMISSION_ASK_ON_USE", "m", "state"]
}
