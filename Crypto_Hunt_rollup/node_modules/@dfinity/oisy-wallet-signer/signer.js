var Cr=Object.create;var et=Object.defineProperty;var _r=Object.getOwnPropertyDescriptor;var Pr=Object.getOwnPropertyNames;var Ar=Object.getPrototypeOf,xr=Object.prototype.hasOwnProperty;var Nr=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var wr=(t,e,r,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of Pr(e))!xr.call(t,o)&&o!==r&&et(t,o,{get:()=>e[o],enumerable:!(s=_r(e,o))||s.enumerable});return t};var Er=(t,e,r)=>(r=t!=null?Cr(Ar(t)):{},wr(e||!t||!t.__esModule?et(r,"default",{value:t,enumerable:!0}):r,t));var Ft=Nr((on,os)=>{os.exports={core:{amount:"Amount",from:"From",to:"To",fee:"Fee",memo:"Memo"},icrc1_transfer:{title:"Approve the transfer of funds"},icrc2_approve:{title:"Authorize another address to withdraw from your account",address_is_allowed:"The following address is allowed to withdraw from your account",your_account:"Your account",requested_withdrawal_allowance:"Requested withdrawal allowance",withdrawal_allowance:{some:"Current withdrawal allowance",none:"The allowance will be set to {amount} {symbol} independently of any previous allowance. Until this transaction has been executed the spender can still exercise the previous allowance (if any) to it's full amount."},expiration_date:{title:"Expiration date",none:"No expiration."},approval_fee:"Approval fee",approver_account_transaction_fees:"Transaction fees to be paid by"},icrc2_transfer_from:{title:"Transfer from a withdrawal account",withdrawal_account:"Withdrawal account",sending_the_transfer_request:"Account sending the transfer request",amount_to_withdraw:"Amount to withdraw",fee_paid_by_withdrawal_account:"Fee paid by withdrawal account"}}});import{assertNonNullish as Qe,isNullish as se,nonNullish as Sr}from"@dfinity/utils";var H="icrc21_call_consent_message",O="icrc25_request_permissions",oe="icrc25_permissions",ne="icrc25_supported_standards",P="icrc27_accounts",ae="icrc29_status",A="icrc49_call_canister",L="granted",B="denied",v="ask_on_use",tt="ICRC-21",rt="ICRC-25",st="ICRC-27",ot="ICRC-29",nt="ICRC-49";import*as ce from"zod/v4";var br=ce.enum([H,O,oe,ne,P,ae,A]),M=br.extract([P,A]),ie=ce.enum([L,B,v]),X=ce.enum([tt,rt,st,ot,nt]);var at=Object.values(X.enum).map(t=>({name:t,url:`https://github.com/dfinity/ICRC/blob/main/ICRCs/${t}/${t}.md`})),ct=Object.values(M.enum).map(t=>({scope:{method:t},state:v})),it=7*24*60*60*1e3;import*as u from"zod/v4";var w="2.0",Tr=u.literal(w),ee=u.union([u.string(),u.number(),u.null()]),pt=u.object({jsonrpc:Tr,id:u.optional(ee)}),k=pt.extend({id:ee}).merge(u.object({method:u.string(),params:u.optional(u.any())})).strict(),te=({method:t})=>k.omit({method:!0,params:!0}).strict().extend({id:ee,method:u.literal(t)}),Ne=({params:t,method:e})=>k.omit({method:!0}).extend({id:ee,method:u.literal(e)}).merge(u.object({params:t})),Qs=k.omit({id:!0}).strict(),mt=(n=>(n[n.PARSE_ERROR=-32700]="PARSE_ERROR",n[n.INVALID_REQUEST=-32600]="INVALID_REQUEST",n[n.METHOD_NOT_FOUND=-32601]="METHOD_NOT_FOUND",n[n.INVALID_PARAMS=-32602]="INVALID_PARAMS",n[n.INTERNAL_ERROR=-32603]="INTERNAL_ERROR",n[n.SERVER_ERROR=-32e3]="SERVER_ERROR",n))(mt||{}),Or=u.union([u.number(),u.nativeEnum(mt)]),ut=u.object({code:Or,message:u.string(),data:u.optional(u.never())}),vr=pt.extend({id:ee}),Mr=vr.extend({error:ut}).strict(),U=t=>Mr.omit({error:!0}).merge(u.object({result:t,error:ut}).partial()).strict().refine(({result:e,error:r})=>e!==void 0||r!==void 0,"Either result or error should be provided."),Ys=U(u.any());var C=({id:t,error:e,origin:r})=>{F({msg:{jsonrpc:w,id:t,error:e},origin:r})},F=({msg:t,origin:e})=>window.opener.postMessage(t,e);var pe=({message:t,...e})=>{C({...e,error:{code:2e3,message:t??"The request sent by the relying party is not supported by the signer."}})},me=t=>{C({...t,error:{code:3001,message:"The signer has canceled the action requested by the relying party."}})},we=({message:t,...e})=>{C({...e,error:{code:4e3,message:t}})},Ee=t=>{C({...t,error:{code:3e3,message:"The signer has not granted the necessary permissions to process the request from the relying party."}})},ue=t=>{C({...t,error:{code:501,message:"The signer has not registered a prompt to respond to permission requests."}})},dt=t=>{C({...t,error:{code:502,message:"The sender must match the owner of the signer."}})},lt=t=>{C({...t,error:{code:503,message:"The signer is currently processing a request and cannot handle new requests at this time."}})};var ft=({id:t,origin:e})=>{F({msg:{jsonrpc:w,id:t,result:"ready"},origin:e})},ht=({id:t,origin:e})=>{F({msg:{jsonrpc:w,id:t,result:{supportedStandards:at}},origin:e})},yt=({id:t,origin:e,scopes:r})=>{F({msg:{jsonrpc:w,id:t,result:{scopes:r}},origin:e})},St=({id:t,origin:e,accounts:r})=>{F({msg:{jsonrpc:w,id:t,result:{accounts:r}},origin:e})},gt=({id:t,origin:e,result:r})=>{F({msg:{jsonrpc:w,id:t,result:r},origin:e})};import{uint8ToBuf as cs}from"@dfinity/agent";import{mapTokenMetadata as is}from"@dfinity/ledger-icrc";import{Principal as ps}from"@dfinity/principal";import{base64ToUint8Array as Vt,isNullish as Ge,notEmptyString as Wt}from"@dfinity/utils";import{IcrcLedgerCanister as Zr}from"@dfinity/ledger-icrc";import{Principal as Qr}from"@dfinity/principal";import{arrayBufferToUint8Array as Tt,uint8ArrayToBase64 as Ot}from"@dfinity/utils";import{concat as zr,fromHex as Rt,toHex as io,uint8ToBuf as qr}from"@dfinity/agent";import Br from"borc";import*as $ from"simple-cbor";import{SelfDescribeCborSerializer as kr}from"simple-cbor";var be=class{get name(){return"Principal"}get priority(){return 0}match(e){return e&&e._isPrincipal===!0}encode(e){return $.value.bytes(qr(e.toUint8Array()))}},Te=class{get name(){return"Buffer"}get priority(){return 1}match(e){return e instanceof ArrayBuffer||ArrayBuffer.isView(e)}encode(e){return $.value.bytes(e)}},Oe=class{get name(){return"BigInt"}get priority(){return 1}match(e){return typeof e=="bigint"}encode(e){return e>BigInt(0)?$.value.tagged(2,$.value.bytes(Rt(e.toString(16)))):$.value.tagged(3,$.value.bytes(Rt((BigInt("-1")*e).toString(16))))}},de=kr.withDefaultEncoders(!0);de.addEncoder(new be);de.addEncoder(new Te);de.addEncoder(new Oe);function ve(t){return de.serialize(t)}var It=class extends Br.Decoder{createByteString(e){return zr(...e)}createByteStringFromHeap(e,r){return e===r?new ArrayBuffer(0):new Uint8Array(this._heap.slice(e,r))}};import{Actor as Vr}from"@dfinity/agent";import{Principal as Wr}from"@dfinity/principal";import{isNullish as Kr}from"@dfinity/utils";var Ct=({IDL:t})=>{let e=t.Record({utc_offset_minutes:t.Opt(t.Int16),language:t.Text}),r=t.Record({metadata:e,device_spec:t.Opt(t.Variant({GenericDisplay:t.Null,LineDisplay:t.Record({characters_per_line:t.Nat16,lines_per_page:t.Nat16})}))}),s=t.Record({arg:t.Vec(t.Nat8),method:t.Text,user_preferences:r}),o=t.Variant({LineDisplayMessage:t.Record({pages:t.Vec(t.Record({lines:t.Vec(t.Text)}))}),GenericDisplayMessage:t.Text}),c=t.Record({metadata:e,consent_message:o}),n=t.Record({description:t.Text}),p=t.Variant({GenericError:t.Record({description:t.Text,error_code:t.Nat}),InsufficientPayment:n,UnsupportedCanisterCall:n,ConsentMessageUnavailable:n}),m=t.Variant({Ok:c,Err:p});return t.Service({icrc10_supported_standards:t.Func([],[t.Vec(t.Record({url:t.Text,name:t.Text}))],["query"]),icrc21_canister_call_consent_message:t.Func([s],[m],[])})};import{isNullish as bt}from"@dfinity/utils";import{Certificate as jr,HttpAgent as Dr,defaultStrategy as Hr,lookupResultToBuffer as xt,pollForResponse as Lr,uint8ToBuf as Nt}from"@dfinity/agent";import{bufFromBufLike as Gr}from"@dfinity/candid";import{Principal as wt}from"@dfinity/principal";import{base64ToUint8Array as Et,isNullish as Me,nonNullish as le}from"@dfinity/utils";import{hashObject as Ur,isNullish as _t,nowInBigIntNanoSeconds as Fr,uint8ArrayToBase64 as Pt}from"@dfinity/utils";var At=()=>{let t=new Map;return async e=>{let{canister_id:r,sender:s,method_name:o,arg:c,ingress_expiry:n,nonce:p}=e.body;if(_t(p))return e;let m={canisterId:r.toString(),sender:s.toString(),method:o,arg:Pt(c),nonce:Pt(p)},d=await Ur(m),f=t.get(d);if(_t(f))return t.set(d,n),e;if(f._value<=Fr())throw Error("The request has expired and is no longer valid. Please try again with a new request.");return e.body.ingress_expiry=f,e}};import{HttpAgent as $r}from"@dfinity/agent";var G=class t{_agent;constructor(e){this._agent=e}static async create(e){let r=await $r.create(e);return new t(r)}get agent(){return this._agent}};var ze=class extends Error{},qe=class extends Error{},Be=class extends Error{},ke=class extends Error{},Ue=class extends Error{},fe=class t extends G{constructor(e){super(e),this._agent.addTransform("update",At())}static async create(e){let r=await Dr.create(e);return new t(r)}request=async({arg:e,canisterId:r,method:s,nonce:o})=>{let{requestDetails:c,...n}=await this._agent.call(r,{methodName:s,arg:Nt(Et(e)),effectiveCanisterId:r,nonce:le(o)?Et(o):void 0});if(this.assertRequestDetails(c),Me(c))throw new ze;let p=await this.readResponse({callResponse:{requestDetails:c,...n},canisterId:r});if(le(p))return p;let{response:{status:m}}=n;if(m===202)return await this.pollForResponse({callResponse:{requestDetails:c,...n},canisterId:r});throw new qe};async readResponse({callResponse:{requestId:e,response:{body:r,status:s},requestDetails:o},canisterId:c}){if(Me(r)||!("certificate"in r))return;if(s!==200)throw new ke;let{certificate:n}=r;if(Me(this._agent.rootKey))throw new Ue;let p=await jr.create({certificate:Gr(n),rootKey:this._agent.rootKey,canisterId:wt.fromText(c)}),{result:m}=this.assertReply({certificate:p,requestId:e});if(m!=="valid")throw new Be;return{certificate:p,requestDetails:o}}assertRequestDetails(e){return le(e)}assertReply({certificate:e,requestId:r}){let s=[Nt(new TextEncoder().encode("request_status")),r];switch(new TextDecoder().decode(xt(e.lookup([...s,"status"])))){case"replied":let c=xt(e.lookup([...s,"reply"]));return{result:le(c)?"valid":"invalid"};case"rejected":return{result:"rejected"};default:return{result:"empty"}}}async pollForResponse({callResponse:{requestId:e,requestDetails:r},canisterId:s}){let{certificate:o}=await Lr(this._agent,wt.fromText(s),e,Hr());return{certificate:o,requestDetails:r}}};var Fe="https://icp-api.io";var he=class{#e=void 0;async getAgent({options:e,type:r}){let{owner:s}=e,o=`${s.getPrincipal().toText()}_${r}`;if(bt(this.#e)||bt(this.#e[o])){let c=await this.createAgent({options:e,type:r});return this.#e={...this.#e??{},[o]:c},c}return this.#e[o]}async createAgent({options:{owner:e,host:r},type:s}){let{hostname:o}=new URL(r??Fe),c=["localhost","127.0.0.1"].includes(o),n={identity:e,host:r??Fe,shouldFetchRootKey:c};return s==="default"?await G.create(n):await fe.create(n)}async getDefaultAgent(e){return await this.getAgent({options:e,type:"default"})}async getCustomAgent(e){return await this.getAgent({options:e,type:"custom"})}};var ye=class extends he{#e;async consentMessage({request:e,...r}){let{icrc21_canister_call_consent_message:s}=await this.getIcrc21Actor(r);return await s(e)}async getIcrc21Actor({canisterId:e,...r}){let s=e instanceof Wr?e.toText():e,{[s]:o}=this.#e??{[s]:void 0};if(Kr(o)){let c=await this.createActor({canisterId:e,idlFactory:Ct,...r});return this.#e={...this.#e??{},[s]:c},c}return o}async createActor({canisterId:e,idlFactory:r,owner:s,host:o}){let{agent:c}=await this.getDefaultAgent({host:o,owner:s});return await Vr.createActor(r,{agent:c,canisterId:e})}};var Se=class extends ye{async call({owner:e,host:r,params:{canisterId:s,method:o,arg:c,nonce:n}}){let m=await(await this.getCustomAgent({host:r,owner:e})).request({canisterId:s,method:o,arg:c,nonce:n});return this.encodeResult(m)}async ledgerMetadata({host:e,owner:r,params:{canisterId:s}}){let{agent:o}=await this.getDefaultAgent({host:e,owner:r}),{metadata:c}=Zr.create({agent:o,canisterId:Qr.fromText(s)});return await c({certified:!0})}encodeResult({requestDetails:e,certificate:r}){let s=Ot(Tt(ve(r.cert))),o=Ot(Tt(ve(e)));return{certificate:s,contentMap:o}}};import{encodeIcrcAccount as j}from"@dfinity/ledger-icrc";import{fromNullable as g,isNullish as ns,nonNullish as $t}from"@dfinity/utils";import{IDL as l}from"@dfinity/candid";var vt=l.Vec(l.Nat8),Yr=l.Record({owner:l.Principal,subaccount:l.Opt(vt)}),Mt=l.Nat64,zt=l.Record({to:Yr,fee:l.Opt(l.Nat),memo:l.Opt(l.Vec(l.Nat8)),from_subaccount:l.Opt(vt),created_at_time:l.Opt(Mt),amount:l.Nat}),Jr=l.Variant({GenericError:l.Record({message:l.Text,error_code:l.Nat}),TemporarilyUnavailable:l.Null,BadBurn:l.Record({min_burn_amount:l.Nat}),Duplicate:l.Record({duplicate_of:l.Nat}),BadFee:l.Record({expected_fee:l.Nat}),CreatedInFuture:l.Record({ledger_time:Mt}),TooOld:l.Null,InsufficientFunds:l.Record({balance:l.Nat})}),Go=l.Variant({Ok:l.Nat,Err:Jr});import{IDL as a}from"@dfinity/candid";var $e=a.Record({owner:a.Principal,subaccount:a.Opt(a.Vec(a.Nat8))}),qt=a.Record({fee:a.Opt(a.Nat),memo:a.Opt(a.Vec(a.Nat8)),from_subaccount:a.Opt(a.Vec(a.Nat8)),created_at_time:a.Opt(a.Nat64),amount:a.Nat,expected_allowance:a.Opt(a.Nat),expires_at:a.Opt(a.Nat64),spender:$e}),Bt=a.Record({to:$e,fee:a.Opt(a.Nat),spender_subaccount:a.Opt(a.Vec(a.Nat8)),from:$e,memo:a.Opt(a.Vec(a.Nat8)),created_at_time:a.Opt(a.Nat64),amount:a.Nat}),Xr=a.Variant({GenericError:a.Record({message:a.Text,error_code:a.Nat}),TemporarilyUnavailable:a.Null,Duplicate:a.Record({duplicate_of:a.Nat}),BadFee:a.Record({expected_fee:a.Nat}),AllowanceChanged:a.Record({current_allowance:a.Nat}),CreatedInFuture:a.Record({ledger_time:a.Nat64}),TooOld:a.Null,Expired:a.Record({ledger_time:a.Nat64}),InsufficientFunds:a.Record({balance:a.Nat})}),es=a.Variant({GenericError:a.Record({message:a.Text,error_code:a.Nat}),TemporarilyUnavailable:a.Null,InsufficientAllowance:a.Record({allowance:a.Nat}),BadBurn:a.Record({min_burn_amount:a.Nat}),Duplicate:a.Record({duplicate_of:a.Nat}),BadFee:a.Record({expected_fee:a.Nat}),CreatedInFuture:a.Record({ledger_time:a.Nat64}),TooOld:a.Null,InsufficientFunds:a.Record({balance:a.Nat})}),Ko=a.Variant({Ok:a.Nat,Err:Xr}),Zo=a.Variant({Ok:a.Nat,Err:es});import{arrayOfNumberToUint8Array as ts,uint8ArrayToHexString as rs}from"@dfinity/utils";var kt=t=>{let e=t instanceof Uint8Array?t:ts(t);try{return new TextDecoder("utf-8").decode(e)}catch{return`0x${rs(t)}`}};var E=({amount:t,decimals:e})=>{let r=Number(t)/10**e,s=e>=1?1:e;return new Intl.NumberFormat("en-US",{minimumFractionDigits:s,maximumFractionDigits:e}).format(r)},Ut=t=>{let e={weekday:"short",month:"short",day:"numeric",year:"numeric",hour:"2-digit",minute:"2-digit",second:"2-digit",hour12:!1,timeZone:"UTC",timeZoneName:"short"};return new Date(Number(t/1000000n)).toLocaleDateString("en",e)};import{IDL as ss}from"@dfinity/candid";import{uint8ArrayToBase64 as rn}from"@dfinity/utils";var ge=({recordClass:t,bytes:e})=>{let r=ss.decode([t],e);if(r.length!==1)throw new Error("More than one object returned. This is unexpected.");let[s]=r;return s};var jt=async({arg:t,owner:e,token:{symbol:r,decimals:s,fee:o}})=>await Le({arg:t,fn:n=>{let{amount:p,from_subaccount:m,to:{owner:d,subaccount:f},fee:h,memo:T}=ge({recordClass:zt,bytes:t}),{core:{amount:x,from:q,to:W,fee:K},icrc1_transfer:{title:Z}}=n,N=[`# ${Z}`];N.push(`${y(x)}
${E({amount:p,decimals:s})} ${r}`);let Q=g(m),Y=j({owner:e,subaccount:Q});N.push(`${y(q)}
${Y}`);let _=j({owner:d,subaccount:g(f)});N.push(`${y(W)}
${_}`),N.push(`${y(K)}
${E({amount:g(h)??o,decimals:s})} ${r}`);let J=He({memo:T,en:n});return{message:[...N,...J]}}}),Dt=async({arg:t,owner:e,token:{symbol:r,decimals:s,fee:o}})=>await Le({arg:t,fn:n=>{let{spender:{owner:p,subaccount:m},from_subaccount:d,amount:f,expected_allowance:h,expires_at:T,fee:x,memo:q}=ge({recordClass:qt,bytes:t}),{icrc2_approve:{title:W,address_is_allowed:K,your_account:Z,requested_withdrawal_allowance:N,withdrawal_allowance:{none:Q,some:Y},expiration_date:{title:_,none:J},approval_fee:Pe,approver_account_transaction_fees:Ae}}=n,I=[`# ${W}`],xe=j({owner:p,subaccount:g(m)});I.push(`${y(K)}
${xe}`);let Rr=g(d),Ye=j({owner:e,subaccount:Rr});I.push(`${y(Z)}
${Ye}`),I.push(`${y(N)}
${E({amount:f,decimals:s})} ${r}`);let Je=g(h);$t(Je)?I.push(`${y(Y)}
${E({amount:Je,decimals:s})} ${r}`):I.push(`\u26A0 ${Q.replace("{amount}",E({amount:f,decimals:s})).replace("{symbol}",r)}`);let Xe=g(T);I.push(`${y(_)}
${$t(Xe)?Ut(Xe):J}`),I.push(`${y(Pe)}
${E({amount:g(x)??o,decimals:s})} ${r}`),I.push(`${y(Ae)}
${Ye}`);let Ir=He({memo:q,en:n});return{message:[...I,...Ir]}}}),Ht=async({arg:t,owner:e,token:{symbol:r,decimals:s,fee:o}})=>await Le({arg:t,fn:n=>{let{from:{owner:p,subaccount:m},to:{owner:d,subaccount:f},spender_subaccount:h,amount:T,fee:x,memo:q}=ge({recordClass:Bt,bytes:t}),{core:{to:W},icrc2_transfer_from:{title:K,withdrawal_account:Z,sending_the_transfer_request:N,amount_to_withdraw:Q,fee_paid_by_withdrawal_account:Y}}=n,_=[`# ${K}`],J=j({owner:p,subaccount:g(m)});_.push(`${y(Z)}
${J}`);let Pe=g(h),Ae=j({owner:e,subaccount:Pe});_.push(`${y(N)}
${Ae}`),_.push(`${y(Q)}
${E({amount:T,decimals:s})} ${r}`);let I=j({owner:d,subaccount:g(f)});_.push(`${y(W)}
${I}`),_.push(`${y(Y)}
${E({amount:g(x)??o,decimals:s})} ${r}`);let xe=He({memo:q,en:n});return{message:[..._,...xe]}}}),y=t=>`**${t}:**`,He=({memo:t,en:e})=>{let r=g(t);if(ns(r))return[];let{core:{memo:s}}=e;return[`${y(s)}
${kt(r)}`]},Le=async({fn:t,arg:e})=>{try{as({arg:e});let{default:r}=await Promise.resolve().then(()=>Er(Ft(),1)),{message:s}=t(r);return{Ok:{metadata:{language:"en",utc_offset_minutes:[]},consent_message:{GenericDisplayMessage:s.join(`

`)}}}}catch(r){return{Err:r}}},je=class extends Error{},as=({arg:t})=>{if(t.byteLength>De)throw new je(`The argument size is too large. The maximum allowed size is ${De} bytes.`)};var De=500,Lt={icrc1_transfer:jt,icrc2_approve:Dt,icrc2_transfer_from:Ht};var Gt=t=>"GenericError"in t?`Error: ${t.GenericError.description} (Code: ${t.GenericError.error_code})`:"InsufficientPayment"in t?`Insufficient Payment: ${t.InsufficientPayment.description}`:"UnsupportedCanisterCall"in t?`Unsupported Canister Call: ${t.UnsupportedCanisterCall.description}`:"ConsentMessageUnavailable"in t?`Consent Message Unavailable: ${t.ConsentMessageUnavailable.description}`:"Unknown error";var Re=class{#e=new Se;async assertAndPromptConsentMessage({params:{sender:e,...r},prompt:s,notify:o,options:{owner:c,host:n}}){let{result:p}=this.assertSender({sender:e,owner:c,notify:o});if(p==="invalid")return{result:"error"};if(Ge(s))return ue(o),{result:"error"};let{origin:m}=o;s({origin:m,status:"loading"});try{let d=await this.loadConsentMessage({params:r,options:{host:n,owner:c}});if("Err"in d){let{Err:h}=d;return s({origin:m,status:"error",details:h}),pe({...o,message:Gt(h)}),{result:"error"}}let{result:f}=await this.promptConsentMessage({consentInfo:d,prompt:s,origin:m});return f==="rejected"&&me(o),{result:f}}catch(d){return this.notifyError({err:d,prompt:s,notify:o})}}async callCanister({params:e,prompt:r,notify:s,options:o}){let{origin:c}=s;r?.({origin:c,status:"executing"});try{let n=await this.#e.call({...o,params:e});return gt({...s,result:n}),r?.({origin:c,status:"result",...n}),{result:"success"}}catch(n){return r?.({origin:c,status:"error",details:n}),we({...s,message:n instanceof Error&&Wt(n.message)?n.message:"An unknown error occurred"}),{result:"error"}}}assertSender({notify:e,owner:r,sender:s}){return r.getPrincipal().toText()===ps.fromText(s).toText()?{result:"valid"}:(dt(e),{result:"invalid"})}async callConsentMessage({params:{canisterId:e,method:r,arg:s},options:{owner:o,host:c}}){return await this.#e.consentMessage({owner:o,host:c,canisterId:e,request:{method:r,arg:Vt(s),user_preferences:{metadata:{language:"en",utc_offset_minutes:[]},device_spec:[]}}})}notifyError({err:e,notify:r,prompt:s}){let{origin:o}=r;return s({origin:o,status:"error",details:e}),we({...r,message:e instanceof Error&&Wt(e.message)?e.message:"An unknown error occurred"}),{result:"error"}}async promptConsentMessage({prompt:e,...r}){return await new Promise(o=>{e({status:"result",approve:()=>{o({result:"approved"})},reject:()=>{o({result:"rejected"})},...r})})}async loadConsentMessage(e){try{return await this.callConsentMessage(e)}catch(r){let s=await this.tryBuildConsentMessageOnError(e);if("Warn"in s)return s;throw r}}async tryBuildConsentMessageOnError({params:{method:e,arg:r,canisterId:s},options:{owner:o,host:c}}){let n=Lt[e];if(Ge(n))return{NoFallback:null};try{let p=await this.#e.ledgerMetadata({params:{canisterId:s},host:c,owner:o}),m=is(p);if(Ge(m))return{Err:new Error("Incomplete token metadata.")};let d=await n({arg:cs(Vt(r)),token:m,owner:o.getPrincipal()});return"Err"in d?{Err:d.Err}:{Warn:{consentInfo:d.Ok,method:e,arg:r,canisterId:s}}}catch(p){return{Err:p}}}};import{isNullish as us}from"@dfinity/utils";import{nonNullish as ms}from"@dfinity/utils";var Kt=({key:t,value:e})=>{try{localStorage.setItem(t,JSON.stringify(e))}catch(r){console.error(r)}};var Ve=({key:t})=>{try{let e=localStorage.getItem(t);return ms(e)?JSON.parse(e):void 0}catch(e){console.error(e);return}};var ds="oisy_signer",Zt=({owner:t,origin:e})=>`${ds}_${e}_${t.toText()}`,Qt=({scopes:t,...e})=>{let r=Zt(e),s=Ve({key:r}),o=(s?.scopes??[]).filter(({scope:{method:m}})=>t.find(({scope:{method:d}})=>m===d)===void 0),c=Date.now(),n=t.reduce((m,{scope:{method:d,...f},...h})=>{let T=(s?.scopes??[]).find(({scope:{method:x}})=>x===d);return[...m,{...h,scope:{...f,method:d},createdAt:T?.createdAt??c,updatedAt:c}]},[]),p={scopes:[...o,...n],createdAt:s?.createdAt??c,updatedAt:c};Kt({key:r,value:p})},We=({sessionOptions:t,...e})=>{let r=Ve({key:Zt(e)});if(!us(r))return r.scopes.filter(({updatedAt:s})=>s>=Date.now()-(t?.sessionPermissionExpirationInMilliseconds??it)).map(({updatedAt:s,createdAt:o,...c})=>({...c}))},Yt=({method:t,...e})=>We(e)?.find(({scope:{method:s}})=>s===t)?.state??v;import{base64ToUint8Array as ls,isNullish as fs}from"@dfinity/utils";import{PrincipalTextSchema as Xt}from"@dfinity/zod-schemas";import*as R from"zod/v4";import*as Jt from"zod/v4";var z=Jt.string().refine(t=>{try{return btoa(atob(t))===t}catch{return!1}},{message:"Invalid base64 string"});var Dn=R.object({scopes:R.array(R.object({method:M})).min(1)}),hs=R.object({scopes:R.array(R.object({method:R.string()})).min(1)}),er=Ne({method:O,params:hs}),tr=te({method:oe}),rr=te({method:ne}),sr=te({method:ae}),or=te({method:P}),ys=R.string().trim().min(1),Ke=R.object({canisterId:Xt,sender:Xt,method:ys,arg:z,nonce:z.optional().refine(t=>{try{return fs(t)||ls(t).length<=32}catch{return!1}},{message:"Nonce must be a Uint8Array with a maximum length of 32 bytes"})}),nr=Ne({method:A,params:Ke});var V=class extends Error{};import*as i from"zod/v4";import*as ar from"zod/v4";var b=t=>ar.custom(e=>t.implement(e));import{base64ToUint8Array as Ss}from"@dfinity/utils";import{PrincipalTextSchema as gs}from"@dfinity/zod-schemas";import*as Ie from"zod/v4";var Rs=z.refine(t=>{try{return Ss(t).length===32}catch{return!1}},{message:"Subaccount must be exactly 32 bytes long."}),Is=Ie.object({owner:gs,subaccount:Rs.optional()}).strict(),Ce=Ie.array(Is).min(1);import{UrlSchema as Cs}from"@dfinity/zod-schemas";import*as S from"zod/v4";var _s=S.object({method:M}),Ps=S.object({scope:_s,state:ie}).strict(),_e=S.array(Ps),As=S.object({scopes:_e}).strict(),ta=U(As),xs=/^https:\/\/github\.com\/dfinity\/ICRC\/blob\/main\/ICRCs\/ICRC-\d+\/ICRC-\d+\.md$/,Ns=S.url().regex(xs).refine(t=>{try{Cs.parse(t)}catch{return!1}let e=/(ICRC-\d+)\.md/g.exec(t);if(e===null)return!1;let[r,s]=e;return Object.keys(X.enum).includes(s)},{message:"The URL does not match any of the IcrcStandard values."}),ws=S.array(S.object({name:X,url:Ns}).strict()).min(1),ra=U(S.object({supportedStandards:ws})),sa=U(S.literal("ready")),oa=U(S.object({accounts:Ce})),Ze=S.object({contentMap:z,certificate:z}).strict(),na=U(Ze.strict());import{UrlSchema as Es}from"@dfinity/zod-schemas";var cr=Es;var ha=i.enum([H,O,P,A]),D=i.object({origin:cr}),ir=b(i.function({output:i.void()})),re=i.enum(["result","error"]),pr=D.extend({status:i.literal(re.enum.error),details:i.unknown().optional()}),bs=b(i.function({input:i.tuple([_e]),output:i.void()})),Ts=D.extend({requestedScopes:_e,confirm:bs}),mr=b(i.function({input:i.tuple([Ts]),output:i.void()})),Os=b(i.function({input:i.tuple([Ce]),output:i.void()})),vs=D.extend({approve:Os,reject:ir}),ur=b(i.function({input:i.tuple([vs]),output:i.void()})),Ms=b(i.function({output:i.void()})),dr=i.enum(["loading"]),ya=dr.or(re),zs=D.extend({status:i.literal(dr.enum.loading)}),lr=i.custom(),qs=i.object({Ok:lr}),Bs=i.object({Warn:Ke.pick({canisterId:!0,method:!0,arg:!0}).extend({consentInfo:lr})}),ks=i.union([qs,Bs]),Us=D.extend({status:i.literal(re.enum.result),consentInfo:ks,approve:Ms,reject:ir}),Fs=i.union([zs,Us,pr]),fr=b(i.function({input:i.tuple([Fs]),output:i.void()})),hr=i.enum(["executing"]),Sa=hr.or(re),$s=D.extend({status:i.literal(hr.enum.executing)}),js=i.intersection(D.extend({status:i.literal(re.enum.result)}),Ze),Ds=i.union([$s,js,pr]),yr=b(i.function({input:i.tuple([Ds]),output:i.void()}));var gr=class t{#e;#t;#r;#s;#n;#a;#o=!1;#c=new Re;constructor(e){this.#e=e,window.addEventListener("message",this.onMessageListener)}static init(e){return new t(e)}disconnect=()=>{window.removeEventListener("message",this.onMessageListener),this.#t=null};onMessageListener=e=>{this.onMessage(e)};onMessage=async e=>{let{data:r,origin:s}=e,{success:o,data:c}=k.safeParse(r);if(!o)return;let{handled:n}=this.handleReadOnlyMessage(e);if(n)return;let{busy:p}=this.assertNotBusy(e);if(p)return;let{handled:m}=await this.handleMessage(e);m||pe({id:c?.id??null,origin:s})};handleReadOnlyMessage(e){let{handled:r}=this.handleStatusRequest(e);if(r)return{handled:!0};let{handled:s}=this.handleSupportedStandards(e);return s?{handled:!0}:{handled:!1}}async handleMessage(e){let{valid:r}=this.assertNotUndefinedAndSameOrigin(e);if(!r)return{handled:!0};let{handled:s}=this.handlePermissionsRequest(e);if(s)return{handled:!0};let{handled:o}=await this.handleRequestPermissionsRequest(e);if(o)return{handled:!0};let{handled:c}=await this.handleAccounts(e);if(c)return{handled:!0};let{handled:n}=await this.handleCallCanister(e);return n?{handled:!0}:{handled:!1}}setWalletOrigin({origin:e}){Sr(this.#t)||(this.#t=e)}assertUndefinedOrSameOrigin({data:e,origin:r}){if(Sr(this.#t)&&this.#t!==r){let{data:s}=k.safeParse(e);return C({id:s?.id??null,origin:r,error:{code:500,message:"The relying party's origin is not permitted to obtain the status of the signer."}}),{valid:!1}}return{valid:!0}}assertNotBusy({data:e,origin:r}){return this.#o?(lt({id:e?.id??null,origin:r}),{busy:!0}):{busy:!1}}async handleWithBusy(e){this.#o=!0;try{return await e()}finally{this.setIdle()}}setIdle(){this.#o=!1}assertNotUndefinedAndSameOrigin({data:e,origin:r}){if(se(this.#t)||this.#t!==r){let{data:s}=k.safeParse(e);return C({id:s?.id??null,origin:r,error:{code:500,message:se(this.#t)?"The relying party has not established a connection to the signer.":"The relying party's origin is not allowed to interact with the signer."}}),{valid:!1}}return{valid:!0}}register=({method:e,prompt:r})=>{switch(e){case H:{fr.parse(r),this.#n=r;return}case O:{mr.parse(r),this.#r=r;return}case P:{ur.parse(r),this.#s=r;return}case A:{yr.parse(r),this.#a=r;return}}throw new Error("The specified method is not supported. Please ensure you are using a supported standard.")};handleStatusRequest({data:e,origin:r,...s}){let{success:o,data:c}=sr.safeParse(e);if(o){let{valid:n}=this.assertUndefinedOrSameOrigin({data:e,origin:r,...s});if(!n)return{handled:!0};let{id:p}=c;return ft({id:p,origin:r}),this.setWalletOrigin({origin:r}),{handled:!0}}return{handled:!1}}handleSupportedStandards({data:e,origin:r}){let{success:s,data:o}=rr.safeParse(e);if(s){let{id:c}=o;return ht({id:c,origin:r}),{handled:!0}}return{handled:!1}}handlePermissionsRequest({data:e}){let{success:r,data:s}=tr.safeParse(e);if(r){let{id:o}=s;return this.emitPermissions({id:o}),{handled:!0}}return{handled:!1}}async handleRequestPermissionsRequest({data:e,origin:r}){let s=async()=>{let{success:o,data:c}=er.safeParse(e);if(!o)return{handled:!1};let{id:n,params:{scopes:p}}=c;if(se(this.#r))return this.assertWalletOriginAndNotifyMissingPromptError(n),{handled:!0};let m=p.filter(({method:f})=>M.safeParse(f).success).map(({method:f})=>({scope:{method:f},state:ie.enum.denied})).sort(({scope:{method:f}},{scope:{method:h}})=>f.localeCompare(h)),d=async()=>{let f=await this.promptPermissions({requestedScopes:m,origin:r});this.savePermissions({scopes:f}),this.emitPermissions({id:n})};return await this.prompt({requestId:n,promptFn:d}),{handled:!0}};return await this.handleWithBusy(s)}async promptPermissions(e){return await new Promise((s,o)=>{let c=n=>{s(n)};if(se(this.#r)){o(new V);return}this.#r({...e,confirm:c})})}emitPermissions({id:e}){Qe(this.#t,"The relying party's origin is unknown.");let{owner:r,sessionOptions:s}=this.#e,o=We({owner:r.getPrincipal(),origin:this.#t,sessionOptions:s}),c=[...o??[],...ct.filter(({scope:{method:n}})=>(o??[]).find(({scope:{method:p}})=>p===n)===void 0)];yt({id:e,origin:this.#t,scopes:c})}assertWalletOriginAndNotifyMissingPromptError(e){Qe(this.#t,"The relying party's origin is unknown."),ue({id:e??null,origin:this.#t})}savePermissions({scopes:e}){Qe(this.#t,"The relying party's origin is unknown.");let{owner:r}=this.#e;Qt({owner:r.getPrincipal(),origin:this.#t,scopes:e})}async handleAccounts({data:e,origin:r}){let s=async()=>{let{success:o,data:c}=or.safeParse(e);if(!o)return{handled:!1};let{id:n}=c,p=async()=>{let d=async()=>{let{result:f,accounts:h}=await this.promptAccounts({origin:r});if(f==="rejected"){me({id:n,origin:r});return}St({accounts:h,id:n,origin:r})};await this.prompt({requestId:n,promptFn:d})};switch(await this.assertAndPromptPermissions({method:P,requestId:n,origin:r})){case B:{Ee({id:n??null,origin:r});break}case L:{await p();break}}return{handled:!0}};return await this.handleWithBusy(s)}async prompt({requestId:e,promptFn:r}){try{await r()}catch(s){if(s instanceof V){this.assertWalletOriginAndNotifyMissingPromptError(e);return}throw s}}async promptAccounts(e){return await new Promise((s,o)=>{let c=()=>{s({result:"rejected",accounts:[]})},n=p=>{s({result:"approved",accounts:p})};if(se(this.#s)){o(new V);return}this.#s({approve:n,reject:c,...e})})}async handleCallCanister({data:e,origin:r}){let s=async()=>{let{success:o,data:c}=nr.safeParse(e);if(!o)return{handled:!1};let{id:n,params:p}=c;if(await this.assertAndPromptPermissions({method:A,requestId:n,origin:r})===B)return Ee({id:n??null,origin:r}),{handled:!0};let d={id:n,origin:r},{result:f}=await this.#c.assertAndPromptConsentMessage({notify:d,params:p,prompt:this.#n,options:this.#e});return f!=="approved"?{handled:!0}:(await this.#c.callCanister({notify:d,params:p,options:this.#e,prompt:this.#a}),{handled:!0})};return await this.handleWithBusy(s)}async assertAndPromptPermissions({method:e,origin:r,requestId:s}){let{owner:o}=this.#e,c=Yt({owner:o.getPrincipal(),origin:r,method:e});switch(c){case v:return await new Promise((p,m)=>{let d=async()=>{let f=[{scope:{method:e},state:B}],h=await this.promptPermissions({requestedScopes:f,origin:r});if(this.savePermissions({scopes:h}),h.find(({scope:{method:x},state:q})=>x===e&&q===L)!==void 0){p(L);return}p(B)};this.prompt({requestId:s,promptFn:d}).catch(f=>{m(f)})});default:return c}}};export{gr as Signer};
//# sourceMappingURL=signer.js.map
